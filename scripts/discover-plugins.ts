#!/usr/bin/env tsx

/**
 * Plugin Auto-Discovery Script
 *
 * Automatically discovers all plugins in the plugins/ directory and generates
 * the plugins/index.ts file with imports. Also updates the README.md with
 * the current list of available actions.
 *
 * Run this script:
 * - Manually: pnpm discover-plugins
 * - Automatically: Before build (in package.json)
 */

import {
  existsSync,
  readdirSync,
  readFileSync,
  statSync,
  writeFileSync,
} from "node:fs";
import { join } from "node:path";

const PLUGINS_DIR = join(process.cwd(), "plugins");
const OUTPUT_FILE = join(PLUGINS_DIR, "index.ts");
const OUTPUT_CONFIGS_FILE = join(
  process.cwd(),
  "lib",
  "output-display-configs.ts"
);
const README_FILE = join(process.cwd(), "README.md");
const PLUGINS_MARKER_REGEX =
  /<!-- PLUGINS:START[^>]*-->[\s\S]*?<!-- PLUGINS:END -->/;

/**
 * Discover all plugin directories
 */
function discoverPlugins(): string[] {
  const entries = readdirSync(PLUGINS_DIR);

  const plugins = entries.filter((entry) => {
    // Skip special directories and files
    if (
      entry.startsWith("_") ||
      entry.startsWith(".") ||
      entry === "index.ts" ||
      entry === "registry.ts"
    ) {
      return false;
    }

    // Only include directories
    const fullPath = join(PLUGINS_DIR, entry);
    try {
      return statSync(fullPath).isDirectory();
    } catch {
      return false;
    }
  });

  return plugins.sort();
}

/**
 * Generate the plugins/index.ts file
 */
function generateIndexFile(plugins: string[]): void {
  const imports = plugins.map((plugin) => `import "./${plugin}";`).join("\n");

  const content = `/**
 * Plugins Index (Auto-Generated)
 *
 * This file is automatically generated by scripts/discover-plugins.ts
 * DO NOT EDIT MANUALLY - your changes will be overwritten!
 *
 * To add a new integration:
 * 1. Create a new directory in plugins/ (e.g., plugins/my-integration/)
 * 2. Add your plugin files (index.tsx, etc.)
 * 3. Run: pnpm discover-plugins (or it runs automatically on build)
 *
 * To remove an integration:
 * 1. Delete the plugin directory
 * 2. Run: pnpm discover-plugins (or it runs automatically on build)
 */

${imports || "// No plugins discovered"}

export type {
  ActionConfigField,
  ActionConfigFieldBase,
  ActionConfigFieldGroup,
  ActionWithFullId,
  IntegrationPlugin,
  PluginAction,
} from "./registry";

// Export the registry utilities
export {
  computeActionId,
  findActionById,
  flattenConfigFields,
  generateAIActionPrompts,
  getActionsByCategory,
  getAllActions,
  getAllDependencies,
  getAllEnvVars,
  getAllIntegrations,
  getCredentialMapping,
  getDependenciesForActions,
  getIntegration,
  getIntegrationLabels,
  getPluginEnvVars,
  getPluginTypes,
  getSortedPluginTypes,
  isFieldGroup,
  parseActionId,
  registerIntegration,
} from "./registry";
`;

  writeFileSync(OUTPUT_FILE, content, "utf-8");
}

/**
 * Update the README.md with the current list of actions
 */
async function updateReadme(): Promise<void> {
  // Dynamically import the plugins to populate the registry
  // This works because we already generated plugins/index.ts above
  await import("@/plugins/index");

  // Now import the registry utilities
  const { getAllIntegrations } = await import("@/plugins/registry");

  const integrations = getAllIntegrations();

  if (integrations.length === 0) {
    console.log("No integrations found, skipping README update");
    return;
  }

  // Generate markdown list grouped by integration
  const actionsList = integrations
    .map((integration) => {
      const actionLabels = integration.actions.map((a) => a.label).join(", ");
      return `- **${integration.label}**: ${actionLabels}`;
    })
    .join("\n");

  // Read current README (skip if file doesn't exist, e.g., in DevSpace containers)
  if (!existsSync(README_FILE)) {
    console.log("README.md not found, skipping README update");
    return;
  }
  const readme = readFileSync(README_FILE, "utf-8");

  // Check if markers exist
  if (!readme.includes("<!-- PLUGINS:START")) {
    console.log("README markers not found, skipping README update");
    return;
  }

  // Replace content between markers
  const updated = readme.replace(
    PLUGINS_MARKER_REGEX,
    `<!-- PLUGINS:START - Do not remove. Auto-generated by discover-plugins -->\n${actionsList}\n<!-- PLUGINS:END -->`
  );

  writeFileSync(README_FILE, updated, "utf-8");
  console.log(`Updated README.md with ${integrations.length} integration(s)`);
}

/**
 * Generate the lib/output-display-configs.ts file (client-safe)
 * This file can be imported in client components
 */
async function generateOutputDisplayConfigs(): Promise<void> {
  const { getAllIntegrations, computeActionId } = await import(
    "@/plugins/registry"
  );
  const integrations = getAllIntegrations();

  // Collect output configs (only built-in types, not component types)
  const outputConfigs: Array<{
    actionId: string;
    type: string;
    field: string;
  }> = [];

  for (const integration of integrations) {
    for (const action of integration.actions) {
      // Only include built-in config types (image/video/url), not component types
      if (action.outputConfig && action.outputConfig.type !== "component") {
        outputConfigs.push({
          actionId: computeActionId(integration.type, action.slug),
          type: action.outputConfig.type,
          field: action.outputConfig.field,
        });
      }
    }
  }

  // Generate output config entries
  const outputConfigEntries = outputConfigs
    .map(
      ({ actionId, type, field }) =>
        `  "${actionId}": { type: "${type}", field: "${field}" },`
    )
    .join("\n");

  const content = `/**
 * Output Display Configs (Auto-Generated)
 *
 * This file is automatically generated by scripts/discover-plugins.ts
 * DO NOT EDIT MANUALLY - your changes will be overwritten!
 *
 * This file is CLIENT-SAFE and can be imported in client components.
 * It maps action IDs to their output display configuration.
 *
 * Generated configs: ${outputConfigs.length}
 */

export type OutputDisplayConfig = {
  type: "image" | "video" | "url";
  field: string;
};

/**
 * Output display configs - maps action IDs to their display configuration
 * Used for rendering outputs in the workflow runs panel
 */
export const OUTPUT_DISPLAY_CONFIGS: Record<string, OutputDisplayConfig> = {
${outputConfigEntries}
};

/**
 * Get the output display config for an action type
 */
export function getOutputDisplayConfig(actionType: string): OutputDisplayConfig | undefined {
  return OUTPUT_DISPLAY_CONFIGS[actionType];
}
`;

  writeFileSync(OUTPUT_CONFIGS_FILE, content, "utf-8");
  console.log(
    `Generated lib/output-display-configs.ts with ${outputConfigs.length} config(s)`
  );
}

/**
 * Main execution
 */
async function main(): Promise<void> {
  console.log("Discovering plugins...");

  const plugins = discoverPlugins();

  if (plugins.length === 0) {
    console.log("No plugins found in plugins/ directory");
  } else {
    console.log(`Found ${plugins.length} plugin(s):`);
    for (const plugin of plugins) {
      console.log(`   - ${plugin}`);
    }
  }

  console.log("\nGenerating plugins/index.ts...");
  generateIndexFile(plugins);

  console.log("Updating README.md...");
  await updateReadme();

  console.log("Generating lib/output-display-configs.ts...");
  await generateOutputDisplayConfigs();

  console.log("Done! Plugin registry updated.\n");
}

main().catch((error) => {
  console.error("Error:", error);
  process.exit(1);
});
