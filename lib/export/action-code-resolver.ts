import { getAutoGeneratedTemplate } from "@/lib/codegen-registry";

export type ActionCodeSource =
	| "system-template"
	| "auto-generated-template"
	| "namespaced-wrapper"
	| "fallback";

export type ResolvedActionCode = {
	filename: string;
	language: "typescript";
	content: string;
	source: ActionCodeSource;
};

type ResolveActionCodeOptions = {
	actionType?: string;
	config?: Record<string, unknown>;
	nodeId?: string;
	nodeName?: string;
};

const ACTION_CONFIG_EXCLUDED_FIELDS = new Set([
	"actionType",
	"integrationId",
	"auth",
]);

const SYSTEM_ACTION_ALIASES: Record<string, string> = {
	"HTTP Request": "system/http-request",
	"Database Query": "system/database-query",
	Condition: "system/condition",
};

function normalizeActionType(actionType?: string): string {
	if (!actionType) {
		return "";
	}
	return SYSTEM_ACTION_ALIASES[actionType] ?? actionType;
}

function toTypeScriptType(value: unknown): string {
	if (value === null || value === undefined) {
		return "unknown";
	}

	if (Array.isArray(value)) {
		return "unknown[]";
	}

	if (typeof value === "string") {
		return "string";
	}

	if (typeof value === "number") {
		return "number";
	}

	if (typeof value === "boolean") {
		return "boolean";
	}

	if (typeof value === "object") {
		return "Record<string, unknown>";
	}

	return "unknown";
}

function sanitizeIdentifier(rawValue: string): string {
	const sanitized = rawValue
		.replace(/[^a-zA-Z0-9_]/g, "_")
		.replace(/_{2,}/g, "_")
		.replace(/^_+|_+$/g, "");

	if (!sanitized) {
		return "step";
	}

	if (/^\d/.test(sanitized)) {
		return `step_${sanitized}`;
	}

	return sanitized;
}

function toPascalCase(value: string): string {
	const normalized = value
		.split(/[^a-zA-Z0-9]+/)
		.filter(Boolean)
		.map((part) => part.charAt(0).toUpperCase() + part.slice(1));

	return normalized.join("") || "Step";
}

function sanitizeFileName(input: string): string {
	return input
		.toLowerCase()
		.replace(/[^a-z0-9]+/g, "-")
		.replace(/-+/g, "-")
		.replace(/^-|-$/g, "");
}

function sanitizeActionFileName(actionType: string): string {
	const name = sanitizeFileName(actionType.replace("/", "-"));
	return `${name || "action"}.ts`;
}

function extractInputConfig(
	config: Record<string, unknown> | undefined,
): Record<string, unknown> {
	if (!config) {
		return {};
	}

	const input: Record<string, unknown> = {};
	for (const [key, value] of Object.entries(config)) {
		if (!ACTION_CONFIG_EXCLUDED_FIELDS.has(key)) {
			input[key] = value;
		}
	}
	return input;
}

function buildInputTypeLines(input: Record<string, unknown>): string[] {
	const keys = Object.keys(input);
	if (keys.length === 0) {
		return ["  [key: string]: unknown;"];
	}

	return keys.map(
		(key) => `  ${sanitizeIdentifier(key)}?: ${toTypeScriptType(input[key])};`,
	);
}

function generateHttpRequestTemplate(
	config: Record<string, unknown> | undefined,
): string {
	const method = String(config?.httpMethod || "POST");
	const endpoint = String(config?.endpoint || "");
	const headersRaw =
		typeof config?.httpHeaders === "string" ? config.httpHeaders : "{}";
	const bodyRaw = typeof config?.httpBody === "string" ? config.httpBody : "{}";

	return `export type HttpRequestStepInput = {
  httpMethod?: "GET" | "POST" | "PUT" | "PATCH" | "DELETE";
  endpoint: string;
  httpHeaders?: string;
  httpBody?: string;
};

export async function httpRequestStep(
  input: HttpRequestStepInput
): Promise<{ success: true; data: unknown } | { success: false; error: { message: string } }> {
  "use step";

  const method = input.httpMethod || "${method}";
  const endpoint = input.endpoint || "${endpoint.replace(/"/g, '\\"')}";
  const headersJson = input.httpHeaders || ${JSON.stringify(headersRaw)};
  const bodyJson = input.httpBody || ${JSON.stringify(bodyRaw)};

  if (!endpoint) {
    return { success: false, error: { message: "Endpoint is required." } };
  }

  let parsedHeaders: Record<string, string> = {};
  let parsedBody: unknown = undefined;

  try {
    parsedHeaders = headersJson ? (JSON.parse(headersJson) as Record<string, string>) : {};
  } catch {
    return { success: false, error: { message: "Invalid JSON in headers." } };
  }

  if (method !== "GET") {
    try {
      parsedBody = bodyJson ? JSON.parse(bodyJson) : undefined;
    } catch {
      return { success: false, error: { message: "Invalid JSON in body." } };
    }
  }

  try {
    const response = await fetch(endpoint, {
      method,
      headers: {
        "Content-Type": "application/json",
        ...parsedHeaders,
      },
      body: method === "GET" ? undefined : JSON.stringify(parsedBody ?? {}),
    });

    const text = await response.text();
    const data = text ? JSON.parse(text) : null;

    if (!response.ok) {
      return {
        success: false,
        error: { message: "HTTP request failed with status " + response.status },
      };
    }

    return { success: true, data };
  } catch (error) {
    return {
      success: false,
      error: {
        message:
          error instanceof Error ? error.message : "Request failed unexpectedly.",
      },
    };
  }
}
`;
}

function generateDatabaseQueryTemplate(
	config: Record<string, unknown> | undefined,
): string {
	const query = String(config?.dbQuery || "SELECT 1");

	return `export type DatabaseQueryStepInput = {
  dbQuery: string;
};

export async function databaseQueryStep(
  input: DatabaseQueryStepInput
): Promise<{ success: true; data: { query: string } } | { success: false; error: { message: string } }> {
  "use step";

  const query = input.dbQuery || ${JSON.stringify(query)};
  if (!query.trim()) {
    return { success: false, error: { message: "Query is required." } };
  }

  // This code sample reflects node behavior. For real execution,
  // use your database client and DATABASE_URL in your runtime.
  return {
    success: true,
    data: { query },
  };
}
`;
}

function generateConditionTemplate(
	config: Record<string, unknown> | undefined,
): string {
	const condition = String(config?.condition || "true");
	const escapedCondition = condition.replace(/"/g, '\\"');

	return `export type ConditionStepInput = {
  condition?: string;
};

export async function conditionStep(
  input: ConditionStepInput
): Promise<{ success: true; data: { passed: boolean; expression: string } } | { success: false; error: { message: string } }> {
  "use step";

  const expression = input.condition || "${escapedCondition}";
  if (!expression.trim()) {
    return { success: false, error: { message: "Condition expression is required." } };
  }

  try {
    const passed = Boolean(Function("return (" + expression + ")")());
    return { success: true, data: { passed, expression } };
  } catch (error) {
    return {
      success: false,
      error: {
        message:
          error instanceof Error ? error.message : "Failed to evaluate condition.",
      },
    };
  }
}
`;
}

function generateNamespacedActionWrapper(
	actionType: string,
	config: Record<string, unknown> | undefined,
	nodeId: string,
	nodeName: string,
): string {
	const [integration, action] = actionType.split("/", 2);
	const normalizedIntegration = integration || "integration";
	const normalizedAction = action || "action";

	const input = extractInputConfig(config);
	const inputTypeName = `${toPascalCase(normalizedIntegration)}${toPascalCase(normalizedAction)}Input`;
	const fnName = `${sanitizeIdentifier(normalizedIntegration)}${toPascalCase(normalizedAction)}Step`;
	const inputTypeLines = buildInputTypeLines(input);

	return `export type ${inputTypeName} = {
${inputTypeLines.join("\n")}
};

type RouterExecuteResult =
  | { success: true; data: unknown }
  | { success: false; error?: { message?: string } | string };

export async function ${fnName}(
  input: ${inputTypeName}
): Promise<{ success: true; data: unknown } | { success: false; error: { message: string } }> {
  "use step";

  const routerUrl =
    process.env.FUNCTION_ROUTER_URL || "http://function-router:8080/execute";

  const payload = {
    activity_id: "${actionType}",
    execution_id: "export-preview",
    workflow_id: "export-preview",
    node_id: ${JSON.stringify(nodeId)},
    node_name: ${JSON.stringify(nodeName)},
    input,
  };

  try {
    const response = await fetch(routerUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });

    const result = (await response.json()) as RouterExecuteResult;
    if (!response.ok || !result.success) {
      const message =
        typeof result.error === "string"
          ? result.error
          : result.error?.message || "Action execution failed.";
      return { success: false, error: { message } };
    }

    return { success: true, data: result.data };
  } catch (error) {
    return {
      success: false,
      error: {
        message:
          error instanceof Error ? error.message : "Failed to reach function router.",
      },
    };
  }
}
`;
}

function generateFallbackTemplate(
	actionType: string,
	nodeId: string,
	nodeName: string,
): string {
	return `export async function actionStep(
  input: Record<string, unknown>
): Promise<{ success: true; data: Record<string, unknown> }> {
  "use step";

  return {
    success: true,
    data: {
      actionType: ${JSON.stringify(actionType)},
      nodeId: ${JSON.stringify(nodeId)},
      nodeName: ${JSON.stringify(nodeName)},
      input,
    },
  };
}
`;
}

export function resolveActionCode(
	options: ResolveActionCodeOptions,
): ResolvedActionCode {
	const normalizedActionType = normalizeActionType(options.actionType);
	const config = options.config || {};
	const nodeId = options.nodeId || "node";
	const nodeName = options.nodeName || "Action";

	if (!normalizedActionType) {
		return {
			filename: "action.ts",
			language: "typescript",
			content: generateFallbackTemplate("unknown", nodeId, nodeName),
			source: "fallback",
		};
	}

	if (normalizedActionType === "system/http-request") {
		return {
			filename: sanitizeActionFileName(normalizedActionType),
			language: "typescript",
			content: generateHttpRequestTemplate(config),
			source: "system-template",
		};
	}

	if (normalizedActionType === "system/database-query") {
		return {
			filename: sanitizeActionFileName(normalizedActionType),
			language: "typescript",
			content: generateDatabaseQueryTemplate(config),
			source: "system-template",
		};
	}

	if (normalizedActionType === "system/condition") {
		return {
			filename: sanitizeActionFileName(normalizedActionType),
			language: "typescript",
			content: generateConditionTemplate(config),
			source: "system-template",
		};
	}

	const autoGeneratedTemplate = getAutoGeneratedTemplate(normalizedActionType);
	if (autoGeneratedTemplate) {
		return {
			filename: sanitizeActionFileName(normalizedActionType),
			language: "typescript",
			content: autoGeneratedTemplate,
			source: "auto-generated-template",
		};
	}

	if (normalizedActionType.includes("/")) {
		return {
			filename: sanitizeActionFileName(normalizedActionType),
			language: "typescript",
			content: generateNamespacedActionWrapper(
				normalizedActionType,
				config,
				nodeId,
				nodeName,
			),
			source: "namespaced-wrapper",
		};
	}

	return {
		filename: sanitizeActionFileName(normalizedActionType),
		language: "typescript",
		content: generateFallbackTemplate(normalizedActionType, nodeId, nodeName),
		source: "fallback",
	};
}
