/**
 * GitOps Deployer
 *
 * Commits workflow definitions and Kubernetes manifests to a Git repository
 * for GitOps-based deployment via ArgoCD or Flux.
 *
 * Flow:
 * 1. User saves workflow in the visual builder
 * 2. This module generates:
 *    - Workflow definition JSON
 *    - Knative/Kustomize manifests (optional)
 * 3. Files are committed to the configured Git repository
 * 4. ArgoCD/Flux detects changes and deploys to the cluster
 */

import type { WorkflowNode, WorkflowEdge } from "./workflow-store";
import {
  generateWorkflowDefinition,
  generateWorkflowDefinitionJson,
} from "./dapr-codegen";
import type { WorkflowDefinition } from "./workflow-definition";

/**
 * GitOps configuration
 */
export interface GitOpsConfig {
  /** Git repository URL */
  repoUrl: string;
  /** Branch to commit to */
  branch: string;
  /** Path within the repo for workflow definitions */
  definitionsPath: string;
  /** Path within the repo for Kubernetes manifests */
  manifestsPath: string;
  /** Git author name */
  authorName: string;
  /** Git author email */
  authorEmail: string;
  /** Optional GitHub token for authentication */
  githubToken?: string;
}

/**
 * Generated files for GitOps deployment
 */
export interface GitOpsFiles {
  /** Workflow definition JSON */
  definition: {
    path: string;
    content: string;
  };
  /** Kustomization files (optional) */
  kustomization?: {
    path: string;
    content: string;
  };
}

/**
 * Result of a GitOps deployment
 */
export interface GitOpsDeployResult {
  success: boolean;
  commitSha?: string;
  commitUrl?: string;
  error?: string;
  files: string[];
}

/**
 * Default GitOps configuration from environment variables
 */
export function getDefaultGitOpsConfig(): GitOpsConfig | null {
  const repoUrl = process.env.GITOPS_REPO_URL;
  if (!repoUrl) {
    return null;
  }

  return {
    repoUrl,
    branch: process.env.GITOPS_BRANCH || "main",
    definitionsPath: process.env.GITOPS_DEFINITIONS_PATH || "workflows/definitions",
    manifestsPath: process.env.GITOPS_MANIFESTS_PATH || "workflows/manifests",
    authorName: process.env.GITOPS_AUTHOR_NAME || "Workflow Builder",
    authorEmail: process.env.GITOPS_AUTHOR_EMAIL || "workflow-builder@example.com",
    githubToken: process.env.GITHUB_TOKEN,
  };
}

/**
 * Generate GitOps files for a workflow
 */
export function generateGitOpsFiles(
  nodes: WorkflowNode[],
  edges: WorkflowEdge[],
  workflowId: string,
  workflowName: string,
  config: GitOpsConfig
): GitOpsFiles {
  // Generate workflow definition
  const definition = generateWorkflowDefinition(
    nodes,
    edges,
    workflowId,
    workflowName
  );

  const definitionPath = `${config.definitionsPath}/${workflowId}.json`;

  return {
    definition: {
      path: definitionPath,
      content: JSON.stringify(definition, null, 2),
    },
    kustomization: generateKustomizationFiles(workflowId, workflowName, config),
  };
}

/**
 * Generate Kustomization files for the workflow
 */
function generateKustomizationFiles(
  workflowId: string,
  workflowName: string,
  config: GitOpsConfig
): { path: string; content: string } | undefined {
  // Only generate if manifests path is configured
  if (!config.manifestsPath) {
    return undefined;
  }

  const kustomizePath = `${config.manifestsPath}/${workflowId}/kustomization.yaml`;

  const content = `# Kustomization for workflow: ${workflowName}
# Generated by Workflow Builder
#
# This file is managed by GitOps. Manual changes may be overwritten.
---
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

commonLabels:
  workflow.builder.io/workflow-id: "${workflowId}"
  workflow.builder.io/workflow-name: "${sanitizeLabel(workflowName)}"

# Reference the base workflow infrastructure
resources:
  - ../../base

# ConfigMap with workflow definition
configMapGenerator:
  - name: workflow-${workflowId}-definition
    files:
      - definition.json=../../definitions/${workflowId}.json
`;

  return {
    path: kustomizePath,
    content,
  };
}

/**
 * Sanitize a string for use as a Kubernetes label value
 */
function sanitizeLabel(value: string): string {
  return value
    .toLowerCase()
    .replace(/[^a-z0-9-_.]/g, "-")
    .replace(/^-+|-+$/g, "")
    .substring(0, 63);
}

/**
 * Deploy workflow to GitOps repository
 *
 * This function commits the generated files to the configured Git repository.
 * Note: This is a placeholder implementation. In production, you would use:
 * - GitHub API for GitHub repositories
 * - GitLab API for GitLab repositories
 * - Or a Git library for direct Git operations
 */
export async function deployToGitOps(
  nodes: WorkflowNode[],
  edges: WorkflowEdge[],
  workflowId: string,
  workflowName: string,
  config?: GitOpsConfig
): Promise<GitOpsDeployResult> {
  const gitOpsConfig = config || getDefaultGitOpsConfig();

  if (!gitOpsConfig) {
    return {
      success: false,
      error: "GitOps not configured. Set GITOPS_REPO_URL environment variable.",
      files: [],
    };
  }

  try {
    // Generate files
    const files = generateGitOpsFiles(
      nodes,
      edges,
      workflowId,
      workflowName,
      gitOpsConfig
    );

    const filePaths: string[] = [files.definition.path];
    if (files.kustomization) {
      filePaths.push(files.kustomization.path);
    }

    // In a real implementation, this would:
    // 1. Clone or fetch the repository
    // 2. Create/update the files
    // 3. Commit and push the changes
    //
    // For now, we'll use the GitHub API if a token is provided

    if (gitOpsConfig.githubToken && gitOpsConfig.repoUrl.includes("github.com")) {
      return await deployToGitHub(
        files,
        workflowId,
        workflowName,
        gitOpsConfig
      );
    }

    // Return a placeholder result for non-GitHub repos
    console.log(`[GitOps] Would deploy workflow ${workflowId} to ${gitOpsConfig.repoUrl}`);
    console.log(`[GitOps] Files: ${filePaths.join(", ")}`);

    return {
      success: true,
      files: filePaths,
      commitSha: "placeholder",
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error("[GitOps] Deployment failed:", error);

    return {
      success: false,
      error: errorMessage,
      files: [],
    };
  }
}

/**
 * Deploy to GitHub using the GitHub API
 */
async function deployToGitHub(
  files: GitOpsFiles,
  workflowId: string,
  workflowName: string,
  config: GitOpsConfig
): Promise<GitOpsDeployResult> {
  if (!config.githubToken) {
    return {
      success: false,
      error: "GitHub token not configured",
      files: [],
    };
  }

  // Parse repo URL to get owner and repo
  const match = config.repoUrl.match(
    /github\.com[:/]([^/]+)\/([^/.]+)/
  );

  if (!match) {
    return {
      success: false,
      error: "Invalid GitHub repository URL",
      files: [],
    };
  }

  const [, owner, repo] = match;
  const filePaths: string[] = [];

  try {
    // Create or update definition file
    await createOrUpdateGitHubFile(
      owner,
      repo,
      files.definition.path,
      files.definition.content,
      `Update workflow definition: ${workflowName}`,
      config
    );
    filePaths.push(files.definition.path);

    // Create or update kustomization file if present
    if (files.kustomization) {
      await createOrUpdateGitHubFile(
        owner,
        repo,
        files.kustomization.path,
        files.kustomization.content,
        `Update workflow manifests: ${workflowName}`,
        config
      );
      filePaths.push(files.kustomization.path);
    }

    console.log(`[GitOps] Successfully deployed workflow ${workflowId} to GitHub`);

    return {
      success: true,
      files: filePaths,
      commitUrl: `https://github.com/${owner}/${repo}/tree/${config.branch}/${files.definition.path}`,
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error("[GitOps] GitHub deployment failed:", error);

    return {
      success: false,
      error: `GitHub API error: ${errorMessage}`,
      files: filePaths,
    };
  }
}

/**
 * Create or update a file in a GitHub repository
 */
async function createOrUpdateGitHubFile(
  owner: string,
  repo: string,
  path: string,
  content: string,
  message: string,
  config: GitOpsConfig
): Promise<void> {
  const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;

  // Check if file exists to get SHA
  let sha: string | undefined;
  try {
    const getResponse = await fetch(
      `${apiUrl}?ref=${config.branch}`,
      {
        headers: {
          Authorization: `Bearer ${config.githubToken}`,
          Accept: "application/vnd.github.v3+json",
        },
      }
    );

    if (getResponse.ok) {
      const data = await getResponse.json();
      sha = data.sha;
    }
  } catch {
    // File doesn't exist, that's fine
  }

  // Create or update file
  const response = await fetch(apiUrl, {
    method: "PUT",
    headers: {
      Authorization: `Bearer ${config.githubToken}`,
      Accept: "application/vnd.github.v3+json",
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      message,
      content: Buffer.from(content).toString("base64"),
      branch: config.branch,
      sha,
      committer: {
        name: config.authorName,
        email: config.authorEmail,
      },
    }),
  });

  if (!response.ok) {
    const errorBody = await response.text();
    throw new Error(`GitHub API error (${response.status}): ${errorBody}`);
  }
}

/**
 * Check if GitOps is configured
 */
export function isGitOpsConfigured(): boolean {
  return !!process.env.GITOPS_REPO_URL;
}

/**
 * Get GitOps status for a workflow
 */
export async function getGitOpsStatus(
  workflowId: string,
  config?: GitOpsConfig
): Promise<{
  deployed: boolean;
  lastDeployed?: string;
  commitUrl?: string;
}> {
  const gitOpsConfig = config || getDefaultGitOpsConfig();

  if (!gitOpsConfig) {
    return { deployed: false };
  }

  // Check if definition file exists in the repo
  if (gitOpsConfig.githubToken && gitOpsConfig.repoUrl.includes("github.com")) {
    const match = gitOpsConfig.repoUrl.match(
      /github\.com[:/]([^/]+)\/([^/.]+)/
    );

    if (match) {
      const [, owner, repo] = match;
      const path = `${gitOpsConfig.definitionsPath}/${workflowId}.json`;

      try {
        const response = await fetch(
          `https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${gitOpsConfig.branch}`,
          {
            headers: {
              Authorization: `Bearer ${gitOpsConfig.githubToken}`,
              Accept: "application/vnd.github.v3+json",
            },
          }
        );

        if (response.ok) {
          return {
            deployed: true,
            commitUrl: `https://github.com/${owner}/${repo}/blob/${gitOpsConfig.branch}/${path}`,
          };
        }
      } catch {
        // File doesn't exist or API error
      }
    }
  }

  return { deployed: false };
}
