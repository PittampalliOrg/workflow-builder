Directory structure:
└── shopify-remote-dom/
    ├── README.md
    ├── CODE_OF_CONDUCT.md
    ├── CONTRIBUTING.md
    ├── LICENSE.md
    ├── package.json
    ├── playwright.config.ts
    ├── pnpm-workspace.yaml
    ├── shipit.production.yml
    ├── tsconfig.json
    ├── vitest.workspace.js
    ├── .nvmrc
    ├── .prettierignore
    ├── documentation/
    │   └── migrations/
    │       └── remote-ui-to-remote-dom.md
    ├── e2e/
    │   └── basic.e2e.ts
    ├── examples/
    │   ├── custom-element/
    │   │   ├── README.md
    │   │   ├── CHANGELOG.md
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   └── app/
    │   │       ├── index.html
    │   │       └── remote.html
    │   ├── getting-started/
    │   │   ├── README.md
    │   │   ├── CHANGELOG.md
    │   │   ├── package.json
    │   │   ├── vite.config.js
    │   │   └── app/
    │   │       ├── index.html
    │   │       └── remote.html
    │   └── kitchen-sink/
    │       ├── README.md
    │       ├── CHANGELOG.md
    │       ├── package.json
    │       ├── tsconfig.json
    │       ├── vite.config.js
    │       └── app/
    │           ├── host.tsx
    │           ├── index.html
    │           ├── style.css
    │           ├── types.ts
    │           ├── vite-env.d.ts
    │           ├── host/
    │           │   ├── components.tsx
    │           │   └── state.ts
    │           └── remote/
    │               ├── elements.ts
    │               ├── render.ts
    │               ├── examples/
    │               │   ├── App.svelte
    │               │   ├── App.vue
    │               │   ├── htm.ts
    │               │   ├── preact.tsx
    │               │   ├── react-remote-ui.tsx
    │               │   ├── react.tsx
    │               │   ├── svelte.ts
    │               │   ├── vanilla.ts
    │               │   └── vue.ts
    │               ├── iframe/
    │               │   ├── index.html
    │               │   └── sandbox.ts
    │               └── worker/
    │                   └── sandbox.ts
    ├── packages/
    │   ├── compat/
    │   │   ├── README.md
    │   │   ├── CHANGELOG.md
    │   │   ├── package.json
    │   │   ├── rollup.config.js
    │   │   ├── tsconfig.json
    │   │   ├── vite.config.js
    │   │   └── source/
    │   │       ├── index.ts
    │   │       ├── adapter/
    │   │       │   └── host.ts
    │   │       └── tests/
    │   │           └── adapter.test.ts
    │   ├── core/
    │   │   ├── README.md
    │   │   ├── CHANGELOG.md
    │   │   ├── package.json
    │   │   ├── rollup.config.js
    │   │   ├── tsconfig.json
    │   │   ├── vite.config.js
    │   │   └── source/
    │   │       ├── connection.ts
    │   │       ├── constants.ts
    │   │       ├── elements.ts
    │   │       ├── html.ts
    │   │       ├── index.ts
    │   │       ├── receivers.ts
    │   │       ├── types.ts
    │   │       ├── elements/
    │   │       │   ├── connection.ts
    │   │       │   ├── internals.ts
    │   │       │   ├── RemoteElement.ts
    │   │       │   ├── RemoteEvent.ts
    │   │       │   ├── RemoteFragmentElement.ts
    │   │       │   ├── RemoteMutationObserver.ts
    │   │       │   ├── RemoteReceiverElement.ts
    │   │       │   ├── RemoteRootElement.ts
    │   │       │   ├── types.ts
    │   │       │   ├── decorators/
    │   │       │   │   ├── custom-element.ts
    │   │       │   │   ├── remote-properties.ts
    │   │       │   │   ├── remote-property.ts
    │   │       │   │   └── remote-slots.ts
    │   │       │   ├── property-types/
    │   │       │   │   └── BooleanOrString.ts
    │   │       │   └── tests/
    │   │       │       ├── connection.test.ts
    │   │       │       └── RemoteMutationObserver.test.ts
    │   │       ├── polyfill/
    │   │       │   ├── hooks.ts
    │   │       │   ├── polyfill.ts
    │   │       │   └── window.ts
    │   │       ├── receivers/
    │   │       │   ├── DOMRemoteReceiver.ts
    │   │       │   ├── RemoteReceiver.ts
    │   │       │   └── shared.ts
    │   │       └── tests/
    │   │           ├── elements.test.ts
    │   │           └── html.test.ts
    │   ├── polyfill/
    │   │   ├── README.md
    │   │   ├── CHANGELOG.md
    │   │   ├── package.json
    │   │   ├── rollup.config.js
    │   │   ├── tsconfig.json
    │   │   └── source/
    │   │       ├── Attr.ts
    │   │       ├── CharacterData.ts
    │   │       ├── ChildNode.ts
    │   │       ├── ClipboardEvent.ts
    │   │       ├── Comment.ts
    │   │       ├── constants.ts
    │   │       ├── CustomElementRegistry.ts
    │   │       ├── CustomEvent.ts
    │   │       ├── Document.ts
    │   │       ├── DocumentFragment.ts
    │   │       ├── Element.ts
    │   │       ├── ErrorEvent.ts
    │   │       ├── Event.ts
    │   │       ├── EventTarget.ts
    │   │       ├── FocusEvent.ts
    │   │       ├── hooks.ts
    │   │       ├── HTMLBodyElement.ts
    │   │       ├── HTMLElement.ts
    │   │       ├── HTMLHeadElement.ts
    │   │       ├── HTMLHtmlElement.ts
    │   │       ├── HTMLTemplateElement.ts
    │   │       ├── index.ts
    │   │       ├── MutationObserver.ts
    │   │       ├── NamedNodeMap.ts
    │   │       ├── Node.ts
    │   │       ├── NodeList.ts
    │   │       ├── ParentNode.ts
    │   │       ├── PromiseRejectionEvent.ts
    │   │       ├── selectors.ts
    │   │       ├── serialization.ts
    │   │       ├── shared.ts
    │   │       ├── SVGElement.ts
    │   │       ├── Text.ts
    │   │       ├── ToggleEvent.ts
    │   │       ├── Window.ts
    │   │       └── tests/
    │   │           ├── global-errors.test.ts
    │   │           ├── selectors.test.ts
    │   │           └── serialization.test.ts
    │   ├── preact/
    │   │   ├── README.md
    │   │   ├── CHANGELOG.md
    │   │   ├── package.json
    │   │   ├── rollup.config.js
    │   │   ├── tsconfig.json
    │   │   ├── vite.config.js
    │   │   └── source/
    │   │       ├── component.tsx
    │   │       ├── host.ts
    │   │       ├── html.ts
    │   │       ├── index.ts
    │   │       ├── types.ts
    │   │       ├── host/
    │   │       │   ├── component.tsx
    │   │       │   ├── constants.ts
    │   │       │   ├── hooks.ts
    │   │       │   ├── node.tsx
    │   │       │   ├── RemoteFragmentRenderer.tsx
    │   │       │   ├── RemoteRootRenderer.tsx
    │   │       │   ├── types.ts
    │   │       │   └── hooks/
    │   │       │       └── props-for-element.tsx
    │   │       └── tests/
    │   │           └── e2e.test.tsx
    │   ├── react/
    │   │   ├── README.md
    │   │   ├── CHANGELOG.md
    │   │   ├── package.json
    │   │   ├── rollup.config.js
    │   │   ├── tsconfig.json
    │   │   ├── vite.config.js
    │   │   └── source/
    │   │       ├── component.tsx
    │   │       ├── host.ts
    │   │       ├── html.ts
    │   │       ├── index.ts
    │   │       ├── polyfill.ts
    │   │       ├── types.ts
    │   │       ├── host/
    │   │       │   ├── component.tsx
    │   │       │   ├── constants.ts
    │   │       │   ├── hooks.ts
    │   │       │   ├── node.tsx
    │   │       │   ├── RemoteFragmentRenderer.tsx
    │   │       │   ├── RemoteRootRenderer.tsx
    │   │       │   ├── RemoteTextRenderer.tsx
    │   │       │   ├── types.ts
    │   │       │   └── hooks/
    │   │       │       ├── props-for-element.tsx
    │   │       │       └── remote-received.ts
    │   │       └── tests/
    │   │           └── e2e.test.tsx
    │   └── signals/
    │       ├── README.md
    │       ├── CHANGELOG.md
    │       ├── package.json
    │       ├── rollup.config.js
    │       ├── tsconfig.json
    │       └── source/
    │           ├── index.ts
    │           └── SignalRemoteReceiver.ts
    ├── .changeset/
    │   ├── README.md
    │   └── config.json
    └── .github/
        ├── dependabot.yml
        └── workflows/
            ├── changesets-reminder.yml
            ├── changesets.yml
            ├── checks.yml
            ├── ci.yml
            ├── cla.yml
            ├── deploy.yml
            ├── preview-versions.yml
            ├── snapit.yml
            └── actions/
                └── prepare/
                    └── action.yml

================================================
FILE: README.md
================================================
# Remote DOM

Remote DOM lets you take a tree of [DOM elements](https://developer.mozilla.org/en-US/docs/Web/API/Document_object_model/Using_the_Document_Object_Model) created in a sandboxed JavaScript environment, and render them to the DOM in a different JavaScript environment. This allows you to isolate potentially-untrusted code off the [main thread](https://developer.mozilla.org/en-US/docs/Glossary/Main_thread), but still allow that code to render a controlled set of UI elements to the main page.

The easiest way to use Remote DOM is to synchronize elements between a hidden [`<iframe>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) and the top-level page. To help you create more lightweight sandboxed JavaScript environments, Remote DOM also offers a [minimal polyfill of key DOM APIs](/packages/core/README.md#remote-domcorepolyfill). This lets you use a [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API) to run JavaScript libraries that would usually need to be run on the top-level HTML page, like [Preact](https://preactjs.com) and [Svelte](https://svelte.dev).

## Examples

- [Getting started](./examples/getting-started/), where we show the most basic usage of Remote DOM in order to synchronize the text content of an element between a main page and an `<iframe>`. Run `pnpm example:getting-started` to see this example in your browser.
- [Custom element](./examples/custom-element/), where we extend the first example to allow the sandboxed environment to render custom button element. Run `pnpm example:custom-element` to see this example in your browser.
- [The “kitchen sink”](./examples/kitchen-sink/), where we show off a more fully-featured implementation of Remote DOM. This includes custom elements with properties, events, and methods, and the ability to sandbox UI in a web worker. The same sandboxed example is implemented in “vanilla” JavaScript, [htm](https://github.com/developit/htm), [Preact](https://preactjs.com), [React](https://react.dev), [Svelte](https://svelte.dev), and [Vue](https://vuejs.org). Run `pnpm example:kitchen-sink` to see this example in your browser.

## Building a project with Remote DOM

To use Remote DOM, you’ll need a web project that is able to run two JavaScript environments: the “host” environment, which runs on the main HTML page and renders actual UI elements, and the “remote” environment, which is sandboxed and renders an invisible version of the DOM that will be mirrored by the host. You can [mix-and-match any combination of “host” and “remote” technologies](#examples) — you don’t need to use a particular JavaScript framework or backend technology to use Remote DOM. If you don’t know how to get started, we recommend starting a [Vite project](https://vitejs.dev) using whatever JavaScript library you prefer, as Vite lets you create `<iframe>` and Web Worker sandboxes with no extra configuration.

Once you have a project, install [`@remote-dom/core`](./packages/core/), which you’ll need to create the connection between host and remote environments:

```bash
# npm
npm install @remote-dom/core --save
# pnpm
pnpm install @remote-dom/core --save
# yarn
yarn add @remote-dom/core
```

Next, on the “host” HTML page, you will need to create a “receiver”. This object will be responsible for receiving the updates from the remote environment, and mapping them to actual DOM elements.

`@remote-dom/core` provides a few different types of receivers, but for now we will use the [`DOMRemoteReceiver`](/packages/core/README.md#domremotereceiver), which directly mirrors the DOM elements created remotely in the host HTML page. That is, if the remote environment renders a `ui-button` custom element, a matching `ui-button` custom element will be created on the host page.

Create a `DOMRemoteReceiver` and call its `connect()` method on the element that should contain any children rendered by the remote environment:

```html
<!doctype html>
<html>
  <body>
    <div id="root"></div>

    <script type="module">
      import {DOMRemoteReceiver} from '@remote-dom/core/receivers';

      const root = document.querySelector('#root');

      const receiver = new DOMRemoteReceiver();
      receiver.connect(root);
    </script>
  </body>
</html>
```

Our host is ready to receive elements to render, but we don’t have a remote environment yet. For this example, we will use a hidden iframe, but the [examples section](#examples) shows alternative sandboxes, like Web Workers. We’ll add the iframe to the host HTML page we started above, and we’ll also listen for `postMessage` events from the iframe, in order to pass changes in the remote tree to our receiver:

```html
<!doctype html>
<html>
  <body>
    <div id="root"></div>

    <iframe id="remote-iframe" src="/remote" hidden></iframe>

    <script type="module">
      import {DOMRemoteReceiver} from '@remote-dom/core/receivers';

      const root = document.querySelector('#root');
      const iframe = document.querySelector('#remote-iframe');

      const receiver = new DOMRemoteReceiver();
      receiver.connect(root);

      // We will send this message in the next step.
      window.addEventListener('message', ({source, data}) => {
        if (source !== iframe.contentWindow) return;
        receiver.connection.mutate(data);
      });
    </script>
  </body>
</html>
```

Next, let’s create the document that will be loaded into the iframe. It will use another utility provided by `@remote-dom/core`, [`RemoteMutationObserver`](/packages/core/README.md#remotemutationobserver), which extends the browser’s [`MutationObserver` interface](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) in order to communicate changes to the host. Create a `RemoteMutationObserver`, and call its `observe()` method on the element that contains the elements you want to synchronize with the host:

```html
<!doctype html>
<html>
  <body>
    <div id="root"></div>

    <script type="module">
      import {RemoteMutationObserver} from '@remote-dom/core/elements';

      // We will synchronize everything inside this element to the host.
      const root = document.querySelector('#root');

      // Send the mutations to the host via `postMessage`, which we just finished
      // adding a listener for in the previous step.
      const observer = new RemoteMutationObserver({
        mutate(mutations) {
          window.parent.postMessage(mutations, '*');
        },
      });

      observer.observe(root);
    </script>
  </body>
</html>
```

In our example, we’re not currently rendering any content in our “root” element. Let’s fix that by adding some text that will be updated over time:

```html
<!doctype html>
<html>
  <body>
    <div id="root"></div>

    <script type="module">
      // Previous script’s contents, excluded for brevity.
      // ...
    </script>

    <script type="module">
      const root = document.querySelector('#root');

      let count = 0;

      setInterval(() => {
        count += 1;
        render();
      }, 1_000);

      function render() {
        root.textContent = `Rendered ${count} ${
          count === 1 ? 'second' : 'seconds'
        } ago`;
      }
    </script>
  </body>
</html>
```

And just like that, the text we render in the `iframe` is now rendered in the host HTML page! You can see a full version of this example in the [“getting started” example](./examples/getting-started/).

### Adding custom elements

Now, just mirroring HTML strings isn’t very useful. Remote DOM works best when you define custom elements for the remote environment to render, which map to more complex, application-specific components on the host page. In fact, most of Remote DOM’s receiver APIs are geared towards you providing an allowlist of custom elements that the remote environment can render, which allows you to keep tight control over the visual appearance of the resulting output.

Remote DOM adopts the browser’s [native API for defining custom elements](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements) to represent these “remote custom elements”. To make it easy to define custom elements that can communicate their changes to the host, `@remote-dom/core` provides the [`RemoteElement` class](/packages/core/README.md#remoteelement). This class, which is a subclass of the browser’s [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement), lets you define how properties, attributes, methods, and event listeners on the element should be transferred.

To demonstrate, let’s imagine that we want to allow our remote environment to render a `ui-button` element. This element will have a `primary` attribute, which sets it to a more prominent visual style. It will also trigger a `click` event when clicked.

First, we’ll create the remote environment’s version of `ui-button`. The remote version doesn’t have to worry about rendering any HTML — it’s only a signal to the host environment to render the “real” version. However, we do need to teach this element to communicate its `primary` attribute and `click` event to the host version of that element. We’ll do this using the [`RemoteElement` class provided by `@remote-dom/core`](/packages/core#remoteelement):

```html
<!doctype html>
<html>
  <body>
    <div id="root">
      <ui-button primary="">Clicked 0 times</ui-button>
    </div>

    <script type="module">
      import {RemoteElement} from '@remote-dom/core/elements';

      // For full details on defining remote elements, see the documentation
      // for `@remote-dom/core/elements`:
      // https://github.com/Shopify/remote-dom/tree/main/packages/core#elements
      class UIButton extends RemoteElement {
        static get remoteAttributes() {
          return ['primary'];
        }

        static get remoteEvents() {
          return ['click'];
        }
      }

      customElements.define('ui-button', UIButton);
    </script>

    <script type="module">
      // Now, we’ll render an instance of this button in the remote environment,
      // with its updates synchronized to the host based on the properties
      // we defined above.

      let count = 0;
      const button = document.querySelector('ui-button');

      button.addEventListener('click', () => {
        count += 1;

        button.textContent = `Clicked ${count} ${
          count === 1 ? 'time' : 'times'
        }`;
      });
    </script>

    <script type="module">
      // In order to proxy function properties and methods between environments,
      // we need a library that can serialize functions over `postMessage`. You can
      // use any library you wish, but this example will use [`@quilted/threads`](https://github.com/lemonmade/quilt/tree/main/packages/threads),
      // which is a small library that was designed to work well with Remote DOM.

      import {RemoteMutationObserver} from '@remote-dom/core/elements';
      import {ThreadNestedWindow} from '@quilted/threads';

      const root = document.querySelector('#root');

      new ThreadNestedWindow({
        exports: {
          // This `render()` method will kick off the process of synchronizing
          // changes between environments. It will be called on the host with a
          // `RemoteConnection` object, which you’ll generally get from one of
          // Remote DOM’s `Receiver` classes.
          async render(connection) {
            const observer = new RemoteMutationObserver(connection);
            observer.observe(root);
          },
        },
      });
    </script>
  </body>
</html>
```

Finally, we need to provide a “real” implementation of our `ui-button` element, which will be rendered on the host page. The `DOMRemoteReceiver` we’ve used to receive elements in previous examples will automatically create an element matching the name provided in the remote environment, so we need to have a `ui-button` element defined in the host page. You can implement this element however you like, but for this example we’ll use the custom element APIs directly:

```html
<!doctype html>
<html>
  <body>
    <div id="root"></div>

    <iframe id="remote-iframe" src="/remote" hidden></iframe>

    <script type="module">
      class UIButton extends HTMLElement {
        // By default, `DOMRemoteReceiver` will assign remote properties as properties,
        // but only if the element has a matching property defined. Otherwise, the remote
        // properties will be set as attributes. We’ll observe the `primary` attribute
        // in order to update our rendered content when that attribute changes. We’ll
        // define an `onClick` method, though, which will be set to the value of the `onClick`
        // remote property.
        static get observedAttributes() {
          return ['primary'];
        }

        connectedCallback() {
          const primary = this.hasAttribute('primary') ?? false;

          const root = this.attachShadow({mode: 'open'});

          // We render a <slot> where we want the element’s children to go.
          root.innerHTML = `<button class="Button"><slot></slot></button>`;

          if (primary) {
            root.querySelector('.Button').classList.add('Button--primary');
          }
        }

        attributeChangedCallback(name, oldValue, newValue) {
          if (name === 'primary') {
            const button = this.shadowRoot?.querySelector('.Button');

            if (button == null) return;

            if (newValue == null) {
              button.classList.remove('Button--primary');
            } else {
              button.classList.add('Button--primary');
            }
          }
        }
      }

      customElements.define('ui-button', UIButton);
    </script>

    <script type="module">
      import {DOMRemoteReceiver} from '@remote-dom/core/receivers';
      import {ThreadIframe} from '@quilted/threads';

      const root = document.querySelector('#root');
      const iframe = document.querySelector('#remote-iframe');

      // In earlier examples, we did not pass any arguments, which allows the DOM
      // receiver to mirror any element it receives. By passing the `elements` option,
      // we are restricting the allowed elements to only the ones we list, which in this
      // case means only our `ui-button` element can be rendered.
      const receiver = new DOMRemoteReceiver({
        retain,
        release,
        elements: ['ui-button'],
      });
      receiver.connect(root);

      // Like our previous example, we need to use a library that can serialize
      // function properties over `postMessage`.
      const thread = new ThreadIframe(iframe);
      thread.imports.render(receiver.connection);
    </script>
  </body>
</html>
```

With those changes, you should now see your button rendering on the page, and responding to click events by updating its contents. You can see an extended version of this example in the [custom element example](./examples/custom-element/).

## Learn more

You’ve now seen the key elements of parts of Remote DOM, but it can help you with a few more related tasks, like allowing event handlers on custom elements and rendering remote elements using front-end JavaScript frameworks. For full details on the core APIs Remote DOM provides for rendering remote elements, please refer to the [documentation for `@remote-dom/core`](./packages/core/). You can also see the flexibility of Remote DOM in the [examples section](#examples), where the library is combined with different tools and frameworks.

This repository also contains a few companion packages to `@remote-dom/core` that are used in some of the examples above:

- [`@remote-dom/preact`](./packages/preact/), which provides [Preact](https://preactjs.com) wrapper components for the remote environment, and the ability to map remote elements directly to Preact components on the host.
- [`@remote-dom/react`](./packages/react/), which provides [React](https://react.dev) wrapper components for the remote environment, and the ability to map remote elements directly to React components on the host.
- [`@remote-dom/polyfill`](./packages/polyfill/), which provides a minimal polyfill of the DOM APIs needed to run Remote DOM inside a non-DOM environment, like a Web Worker.
- [`@remote-dom/signals`](./packages/signals/), which lets you receive remote updates into a tree of [signals](https://preactjs.com/guide/v10/signals/).

## Want to contribute?

Check out our [contributing guide](CONTRIBUTING.md).

## License

MIT &copy; [Shopify](https://shopify.com/), see [LICENSE.md](LICENSE.md) for details.



================================================
FILE: CODE_OF_CONDUCT.md
================================================
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

- Demonstrating empathy and kindness toward other people
- Being respectful of differing opinions, viewpoints, and experiences
- Giving and gracefully accepting constructive feedback
- Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
- Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

- The use of sexualized language or imagery, and sexual attention or
  advances of any kind
- Trolling, insulting or derogatory comments, and personal or political attacks
- Public or private harassment
- Publishing others' private information, such as a physical or email
  address, without their explicit permission
- Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
[INSERT CONTACT METHOD].
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior, harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.



================================================
FILE: CONTRIBUTING.md
================================================
# Contributing

## [Code of conduct](./CODE_OF_CONDUCT.md).

All contributors **must** adhere to the code of conduct. Read the [full text](./CODE_OF_CONDUCT.md) so that you can understand what actions will and will not be tolerated.

## Ways to contribute

There are many ways to contribute to Remote DOM:

- Filing bug reports or requesting new features by [opening an issue](https://github.com/Shopify/remote-dom/issues/new)
- Hacking on an issue from our [backlog](https://github.com/Shopify/remote-dom/issues)
- Improving tests, documentation, or examples

## Development

### Getting started

Clone this repo, then run `pnpm install`. This repo uses [pnpm](https://pnpm.io) for package management. The codebase is entirely written in [TypeScript](https://www.typescriptlang.org).

#### Type check

Run `pnpm type-check`, which will run TypeScript’s `tsc` command on the repo.

This repo uses [project references](https://www.typescriptlang.org/docs/handbook/project-references.html), with each package represented as a project, as well as one project for all the non-source code files (tests, config, etc). Make sure you understand how to configure the `tsconfig.json` of projects, like setting the `references` key to include the path to any other packages whose types a given project depends on.

#### Lint

Run `pnpm lint`, which will run the entire codebase through [Prettier](https://prettier.io).

#### Test

Run `pnpm test`, which will run all tests in the repo in [Vitest’s](https://vitest.dev/guide/workspace) watch mode.

Tests are currently a little sparse, focused mostly on ensuring good end-to-end behavior when using all the libraries together. Additional tests can be added for public APIs in each package by including files with a `.test.ts` or `.test.tsx` extension. Make sure you adhere to the structure of the other tests in the repo, and it would be extra appreciated if you understand a little about [Shopify’s approach to front-end testing (sorry to external contributors, this is an internal Shopify link)](https://github.com/Shopify/web-foundations/blob/main/handbook/Best%20Practices/Testing.md).

#### Build

To build all the package outputs for the repo, run `pnpm build`. This command uses [Rollup](https://rollupjs.org/), with a good set of configuration options provided by [Quilt](https://github.com/lemonmade/quilt/blob/main/documentation/projects/packages/builds.md). Some of these versions, like the `.esnext` version of the project you will see, preserve most of the original source code, so that build tools can be configured to parse, process, polyfill, and minify this code in the same way the rest of an application’s codebase. This helps to significantly reduce the bundle size of these packages.

`pnpm build` is automatically run before the project is published. You only need to run it manually when you want to verify the outputs it produces (all of which are ignored in `git`).

### Contributing a change

If this is your first contribution to a project on GitHub, you may find this [free video series on contributing to open source useful](https://egghead.io/series/how-to-contribute-to-an-open-source-project-on-github).

If you are fixing a minor issue, feel free to send a pull request directly. If you are working on a non-trivial bug or feature, though, we’d appreciate if you could first [open an issue](https://github.com/Shopify/remote-dom/issues) so we can make sure the process goes smoothly. If you are taking on an issue, please leave a comment stating that you intend to work on it.

**Before submitting a pull request**, please:

1. Fork the repository and create your branch from `main`
1. Run `pnpm install` from the repository root
1. Make sure your changes do not cause errors to be thrown when running `pnpm test`, `pnpm lint`, or `pnpm type-check` (these will also be checked automatically when you open your pull request, as they run as part of Remote DOM’s [GitHub Action-based CI](./.github/workflows/ci.yml))
1. Add a description of your changes to package’s `CHANGELOG.md`
1. Add a [changeset using `pnpm changeset add`](#releasing-changes)
1. If you haven’t already, [sign a Contributor License Agreement](https://cla.shopify.com/)

#### Contributor License Agreement (CLA)

Each contributor is required to [sign a CLA](https://cla.shopify.com/). This process is automated as part of your first pull request and is only required once. If any contributor has not signed or does not have an associated GitHub account, the CLA check will fail and the pull request is unable to be merged.

### Releasing changes

This repo uses [Changesets](https://github.com/changesets/changesets) to manage releases. As you contribute changes to the repo, you can include changeset files that describe the packages being changed, the significance of the change, and a detailed description.

Before you create a PR for your change, run `pnpm changeset`. This command will prompt you to select the packages and type (patch, minor, or major) of change you are working on. You will also be asked for an initial description.

This command creates a file in the `.changeset` directory at the root of the repo. The contents of these files will be included in the changelog entries of each affected package. If you have additional detail or migration instructions related to the change, you can add it as markdown to the generated file.

Once you are satisfied with the content of the file, commit it alongside the rest of your changes, and merge it as part of your normal PR flow. Don’t worry, the new version will not be published immediately! A Shopify developer will take care of actually publishing the new versions.

#### Publishing new versions

> **Note:** currently, only Shopify developers can publish new versions of packages.

Once changeset files are merged into the `main` branch of this repo, a [Github action](./.github/workflows/changesets.yml) will create a new PR to apply all the outstanding changesets to their respective packages, creating a new set of package versions. You just need to merge that PR, and the robots will take care of publishing the changes to NPM!



================================================
FILE: LICENSE.md
================================================
Copyright 2020-present, Shopify Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



================================================
FILE: package.json
================================================
{
  "name": "remote-dom",
  "type": "module",
  "version": "0.0.0",
  "private": true,
  "repository": "https://github.com/Shopify/remote-dom.git",
  "workspaces": [
    "./packages/*",
    "./examples/*"
  ],
  "scripts": {
    "build": "pnpm -r run build",
    "build:snapit": "pnpm type-check || true && pnpm build",
    "format": "prettier --write --cache .",
    "lint": "prettier --check --cache .",
    "test": "vitest",
    "type-check": "tsc --build --pretty",
    "version-bump": "changeset version && pnpm install --no-frozen-lockfile",
    "deploy": "pnpm publish -r",
    "example:getting-started": "pnpm run --filter example-getting-started start",
    "example:custom-element": "pnpm run --filter example-custom-element start",
    "example:kitchen-sink": "pnpm run --filter example-kitchen-sink start"
  },
  "devDependencies": {
    "@changesets/changelog-github": "^0.5.0",
    "@changesets/cli": "^2.27.0",
    "@playwright/test": "^1.49.0",
    "@quilted/rollup": "^0.2.45",
    "@quilted/typescript": "^0.4.2",
    "@quilted/vite": "^0.1.27",
    "@types/node": "~20.11.0",
    "jsdom": "^25.0.0",
    "playwright": "^1.49.0",
    "prettier": "^3.3.3",
    "rollup": "^4.21.0",
    "tsx": "^4.19.0",
    "typescript": "^5.5.0",
    "vite": "^5.4.0",
    "vitest": "^1.6.0"
  },
  "packageManager": "pnpm@9.14.2+sha256.06e65a4965baff6d6097f9c8f75c35f6d420974dbc03d775009056a69edfd271",
  "prettier": {
    "arrowParens": "always",
    "bracketSpacing": false,
    "singleQuote": true,
    "trailingComma": "all"
  },
  "browserslist": [
    "defaults and not dead"
  ]
}



================================================
FILE: playwright.config.ts
================================================
import {defineConfig, devices} from '@playwright/test';

// See https://playwright.dev/docs/test-configuration.
export default defineConfig({
  testDir: './e2e',
  testMatch: '*.e2e.ts',
  // Run tests in files in parallel
  fullyParallel: true,
  // Fail the build on CI if you accidentally left test.only in the source code.
  forbidOnly: !!process.env.CI,
  // Retry on CI only
  retries: process.env.CI ? 2 : 0,
  // Opt out of parallel tests on CI.
  workers: process.env.CI ? 1 : undefined,
  // Reporter to use. See https://playwright.dev/docs/test-reporters
  reporter: 'html',
  // Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions.
  use: {
    // Base URL to use in actions like `await page.goto('/')`.
    baseURL: 'http://localhost:8080',

    // Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer
    trace: 'on-first-retry',
  },

  // Configure projects for major browsers
  projects: [
    {
      name: 'chromium',
      use: {...devices['Desktop Chrome']},
    },
  ],

  // Run your local dev server before starting the tests
  webServer: [
    {
      command: 'pnpm run example:kitchen-sink --port 8080',
      url: 'http://localhost:8080',
      reuseExistingServer: !process.env.CI,
    },
  ],
});



================================================
FILE: pnpm-workspace.yaml
================================================
packages:
  - examples/*
  - packages/*



================================================
FILE: shipit.production.yml
================================================
ci:
  require:
    - lint
    - test
    - type-check
dependencies:
  override:
    - yarn install --frozen-lockfile --no-progress
deploy:
  pre:
    - yarn run build
  override:
    - yarn run deploy



================================================
FILE: tsconfig.json
================================================
{
  "extends": "@quilted/typescript/tsconfig.workspace.json",
  "files": [],
  "include": [],
  "references": [
    {"path": "./examples/kitchen-sink"},
    {"path": "./packages/compat"},
    {"path": "./packages/core"},
    {"path": "./packages/polyfill"},
    {"path": "./packages/preact"},
    {"path": "./packages/react"},
    {"path": "./packages/signals"}
  ]
}



================================================
FILE: vitest.workspace.js
================================================
export default ['packages/*'];



================================================
FILE: .nvmrc
================================================
v20.11.0



================================================
FILE: .prettierignore
================================================
build/
node_modules/
pnpm-lock.yaml



================================================
FILE: documentation/migrations/remote-ui-to-remote-dom.md
================================================
# Migrating from `remote-ui` to Remote DOM

Remote DOM started out with as a project called `remote-ui`. The [original packages](https://www.npmjs.com/package/@remote-ui/core) had a DOM-like API, but because they did not use the DOM directly, it was difficult to use them with any JavaScript library other than React. Remote DOM is a complete rewrite of `remote-ui` that uses the DOM directly, which makes for more seamless use of browser-friendly libraries, and a simpler learning code for developers who already have familiarity with the DOM.

> **Note**: These benefits are shown in code in the [“kitchen sink” example](/examples/kitchen-sink/), where we write the same “remote” rendering code using many different techniques and JavaScript libraries.

This guide will go over how you can migrate from `remote-ui` to Remote DOM.

## Uninstall `@remote-ui` packages and install their `@remote-dom` equivalents

Almost all projects will need to swap out the `@remote-ui/core` package for `@remote-dom/core`:

```diff
{
  "dependencies": {
-    "@remote-ui/core": "^2.2.0",
+    "@remote-dom/core": "^1.0.0",
  }
}
```

If you use [`@remote-ui/react`](https://www.npmjs.com/package/@remote-ui/react), you’ll need to make some additional changes, which we’ll cover [later in this guide](#update-react-integration)

The following `@remote-ui` packages have been removed, and have no `@remote-dom` equivalent:

- [`@remote-ui/rpc`](https://www.npmjs.com/package/@remote-ui/rpc). This package was removed to simplify the repo, but you will likely still need a library that provides similar functionality, since Remote DOM depends on a smart RPC library for synchronizing event listeners and other function calls over `postMessage()`. You can continue using `@remote-ui/rpc` with `@remote-dom/core`, or you can switch to a different library that can communicate functions over `postMessage()`. [`@quilted/threads`](https://www.npmjs.com/package/@quilted/threads) is a more modern alternative that is actively maintained, or you can use another popular community library like [`comlink`](https://www.npmjs.com/package/comlink).
- [`@remote-ui/async-subscriptions`](https://www.npmjs.com/package/@remote-ui/async-subscriptions). Like `@remote-ui/rpc`, you can continue using this package with `@remote-dom/core`, or you can switch to a different library that provides similar functionality. The `@quilted/threads` package contains a more modern alternative, which allows you to [synchronize a Preact Signal over `postMessage()`](https://github.com/lemonmade/quilt/blob/main/packages/threads/README.md#preact-signals).
- [`@remote-ui/web-workers`](https://www.npmjs.com/package/@remote-ui/web-workers). You need to use a different library or build tool to create web worker sandboxes in which to run Remote DOM-powered code.
- [`@remote-ui/dom`](https://www.npmjs.com/package/@remote-ui/dom). The [`@remote-dom/core` package](/packages/core/) now provides all DOM-related utilities.
- [`@remote-ui/htm`](https://www.npmjs.com/package/@remote-ui/htm). The [`@remote-dom/core/html`](/packages/core/README.md#remote-domcorehtml) package exports an [`htm`](https://www.npmjs.com/package/htm) function for building trees of DOM nodes.
- [`@remote-ui/mini-react`](https://www.npmjs.com/package/@remote-ui/react). This library was an adapted version of [Preact](https://preactjs.com/), which is a popular alternative to React. The new DOM-based API works great with Preact, so you can use Preact directly instead. We’ve also introduced a [`@remote-dom/preact`](/packages/preact/) package that provides a few convenience utilities for using Preact with Remote DOM.
- [`@remote-ui/vue`](https://www.npmjs.com/package/@remote-ui/vue). This library was always poorly maintained. The new DOM-based API works well with Vue without any additional configuration, so we’ve removed this dedicated integration.
- [`@remote-ui/traversal`](https://www.npmjs.com/package/@remote-ui/traversal). The tree traversal utilities provided by this library are all supported natively by the DOM.
- [`@remote-ui/testing`](https://www.npmjs.com/package/@remote-ui/testing). There are many other great libraries for testing DOM code.

## Import the DOM polyfill

If you are running your Remote DOM-dependent code in a Web Worker sandbox, you will need a limited subset of the global DOM API available for Remote DOM to work. Add the following import as one of the first lines in your Web Worker code:

```ts
import '@remote-dom/core/polyfill';
```

## Define components as custom elements

In `remote-ui`, “components” were referenced by their name, by passing a string to the `RemoteRoot.createComponent()` function. In Remote DOM, components are instead [defined as custom elements](/packages/core/README.md#remote-domcoreelements). In the remote environment, you’ll need to define a custom element with the set of properties and methods that your component accepts.

```ts
// Define each component that your
class Button extends RemoteElement {
  static get remoteProperties() {
    return {
      tooltip: {type: String},
      primary: {type: Boolean},
      onPress: {event: true},
    };
  }
}

customElements.define('ui-button', Button);
```

## Update your host code to use the new `Receiver` classes

`remote-ui` provided a [`createRemoteReceiver()` utility](https://github.com/Shopify/remote-dom/tree/remote-ui/packages/core#createremotereceiver) for creating the object that will receive updates from the remote environment. In Remote DOM, this utility is replaced with the [`RemoteReceiver`](/packages/core/README.md#remotereceiver), [`DOMRemoteReceiver`](/packages/core/README.md#domremotereceiver), or [`SignalRemoteReceiver`](/packages/signals/README.md#signalremotereceiver) classes.

```ts
// Replace this:

import {createRemoteReceiver} from '@remote-ui/core';

const receiver = createRemoteReceiver();
sendToRemoteEnvironment(receiver.receive);

// With this:

import {RemoteReceiver} from '@remote-dom/core';
import {retain, release} from '@quilted/threads';

// You now need to pass in functions to manage the memory for functions manually,
// where this was previously done automatically in `@remote-ui/rpc`. If you are
// using the automatic memory management provided by `@quilted/threads`, you can
// omit the `retain` and `release` functions.
const receiver = new RemoteReceiver({retain, release});
sendToRemoteEnvironment(receiver.connection);
```

## Update your remote code to use DOM elements instead of the `RemoteRoot` object

`remote-ui` provided a [`createRemoteRoot()` utility](https://github.com/Shopify/remote-dom/tree/remote-ui/packages/core#createremoteroot) for creating the root node for a tree of remote elements. This root node managed the top-level children of the tree, and had methods for creating components to be inserted into the tree. In Remote DOM, this API is removed in favor of native DOM APIs.

```ts
// Replace this:

import {createRemoteRoot} from '@remote-ui/core';

export function receiveChannelFromHostEnvironment(channel) {
  const root = createRemoteRoot(channel);
  const button = root.createComponent(
    'Button',
    {
      primary: true,
      onPress: () => console.log('Pressed!'),
    },
    ['Press me!'],
  );
  root.appendChild(button);
}

// With this:

import {RemoteRootElement} from '@remote-dom/core/elements';

// Define our `Button` custom element, from earlier.
customElements.define('ui-button', Button);

// If you’re using an `<iframe>` sandbox, you should use the `RemoteMutationObserver`
// and an empty `div` element instead.
customElements.define('remote-root', RemoteRootElement);

export function receiveConnectionFromHostEnvironment(connection) {
  const root = document.createElement('remote-root');
  document.body.appendChild(root);

  const button = document.createElement('ui-button');
  button.primary = true;
  button.addEventListener('press', () => console.log('Pressed!'));
  button.textContent = 'Press me!';
  root.appendChild(button);
}
```

The new approach feels right at home in a DOM-focused project, but you should be mindful of the following differences from the `RemoteRoot` object from `remote-ui`:

- You can’t restrict which element types are allowed as children of a DOM element acting as the remote root. We recommend applying this restriction on the host environment instead.
- Because there is no `root.createComponent()` function, you can’t prevent elements from being moved between remote roots.

## Replace `RemoteFragment` objects with `slot` attributes

In `remote-ui`, you could pass a `RemoteFragment` object as a property of a component. This concept has been removed in Remote DOM, because there is no equivalent concept in HTML. Instead, we expect you to use the [`slot` attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/slot) to tag child elements with a name.

```ts
// Replace this:

const root = createRemoteRoot(/* ... */);
const fragment = root.createFragment();
const icon = root.createComponent('Icon', {type: 'archive'});
fragment.append(icon);
const button = root.createComponent('Button', {icon: fragment}, ['Archive']);
root.append(button);

// With this:

const root = document.createElement('remote-root');
const button = document.createElement('ui-button');
button.textContent = 'Archive';
const icon = document.createElement('ui-icon');
icon.setAttribute('type', 'archive');
icon.setAttribute('slot', 'icon');
button.append(icon);
root.append(button);
document.body.append(root);
```

## Update React integration

The [`@remote-ui/react`](https://www.npmjs.com/package/@remote-ui/react) package provided a set of utilities for both the host and remote environments of a `remote-ui` project. On the host, this library provides utilities for rendering a tree of remote nodes into React components. In the remote environment, it provides a custom React reconciler that resolves a tree of React components into the necessary method calls on a `RemoteRoot` object. The [`@remote-dom/react` package](/packages/react/) provides the same set of utilities, but with a few changes to the API.

### Uninstall `@remote-ui/react` and install `@remote-dom/react`

Like with `@remote-ui/core`, you’ll need to swap out the `@remote-ui/react` package for its `@remote-dom` equivalent:

```diff
{
  "dependencies": {
-    "@remote-ui/react": "^5.0.0",
+    "@remote-dom/react": "^1.0.0",
  }
}
```

`@remote-dom/react` no longer provides a custom reconciler for React, because you can now use `react-dom` directly. So, make sure you have `react-dom` installed. If you had `react-reconciler` installed for `@remote-ui/react`, you can also remove this dependency.

```diff
{
  "dependencies": {
    "@remote-dom/react": "^1.0.0",
    "react": "^18.2.0",
+    "react-dom": "^18.2.0",
-    "react-reconciler": "*",
  }
}
```

Note that, with the new focus on DOM compatibility, we’ve added a new [`@remote-dom/preact` library](/packages/preact/). This library provides all the same APIs and developer conveniences as the React package, but for Preact, a lightweight alternative to React. Particularly in the remote environment, you should consider offering a Preact option, as it produces smaller bundles that are well-suited to being run in a sandboxed JavaScript environment.

### Update the React render call in the remote environment

The custom reconciler provided by `@remote-ui/react` had custom `render()` and `createRoot()` functions that you’d use to kick off a React render to a `RemoteRoot`. You can change this to instead use the `react-dom` package to render directly to a DOM element.

```tsx
// Replace this:

import {createRemoteRoot} from '@remote-ui/core';
import {createRoot} from '@remote-ui/react';

const root = createRemoteRoot(/* ... */);
createRoot(remoteRoot).render(<App />);

// With this:

import {createRoot} from 'react-dom/client';

const root = document.createElement('remote-root');
document.body.append(root);
createRoot(root).render(<App />);
```

### Update the React wrapper components in the remote environment

The `@remote-ui/react` package also provided a `createRemoteReactComponent()`, which creates strongly-typed React components that render a remote component of your choosing. This function is replaced by the [`createRemoteComponent()` function](/packages/react/README.md#createremotecomponent) in `@remote-dom/react`, which gets strong typing from the `HTMLElement` subclass you define to represent your component:

```tsx
// Replace this:

import {createRemoteReactComponent} from '@remote-ui/react';

const Button = createRemoteReactComponent<'Button', {onPress(): void}>(
  'Button',
);

// With this:

import {createRemoteComponent} from '@remote-dom/react';

// Define our custom `Button` element, as shown above.
customElements.define('ui-button', Button);

const ReactButton = createRemoteComponent('ui-button', Button);
```

### Update the host environment that renders remote elements to React components

The `@remote-ui/react/host` package provided some components and utility functions for rendering a remote root to React components. `@remote-dom/react/host` provides similar utilities, but with a few tweaks. In particular, you will now need to wrap all elements in a [`createRemoteComponentRenderer()` call](/packages/react/README.md#createremotecomponentrenderer), which subscribes your host React components to render in response to remote element changes.

```tsx
// Replace this:

import {useMemo, useEffect} from 'react';
import {
  createController,
  createRemoteReceiver,
  RemoteRenderer,
} from '@remote-ui/react/host';

import {Button} from './Button';

function MyRemoteRenderer() {
  const controller = useMemo(() => createController({Button}), []);
  const receiver = useMemo(() => createRemoteReceiver(), []);

  useEffect(() => {
    sendReceiverToRemoteContext(receiver.receive);
  }, [receiver]);

  return <RemoteRenderer receiver={receiver} controller={controller} />;
}

// With this:

import {useMemo, useEffect} from 'react';
import {
  createRemoteComponentRenderer,
  RemoteRootRenderer,
  RemoteFragmentRenderer,
  RemoteReceiver,
} from '@remote-dom/react/host';

import {Button} from './Button';

function MyRemoteRenderer() {
  const components = useMemo(
    () =>
      new Map([
        ['ui-button', createRemoteComponentRenderer(Button)],
        // If you want to allow React elements to be passed as props in the remote
        // environment, `@remote-dom/react` will render a `remote-fragment` element
        // in some cases. You need to provide a renderer for this element.
        ['remote-fragment', RemoteFragmentRenderer],
      ]),
    [],
  );
  const receiver = useMemo(() => new RemoteReceiver(), []);

  useEffect(() => {
    sendReceiverToRemoteContext(receiver.connection);
  }, [receiver]);

  return <RemoteRootRenderer receiver={receiver} components={components} />;
}
```



================================================
FILE: e2e/basic.e2e.ts
================================================
import {test, expect} from '@playwright/test';

[
  ['iframe', 'vanilla'],
  ['iframe', 'preact'],
  ['iframe', 'svelte'],
  ['iframe', 'vue'],
  ['iframe', 'htm'],
  ['iframe', 'react'],
  ['iframe', 'react-remote-ui'],
  ['worker', 'vanilla'],
  ['worker', 'preact'],
  ['worker', 'svelte'],
  // ['worker', 'vue'],
  ['worker', 'htm'],
  ['worker', 'react'],
  ['worker', 'react-remote-ui'],
].forEach(([sandbox, example]) => {
  test(`basic modal interaction with ${sandbox} sandbox and ${example} example`, async ({
    page,
  }) => {
    await page.goto(`/?sandbox=${sandbox}&example=${example}`);

    await page.getByRole('button', {name: 'Open modal'}).click();
    await page.getByRole('button', {name: 'Click me!'}).click();
    await page.getByRole('button', {name: 'Click me!'}).click();

    await expect(page.getByText('Click Count: 2')).toBeVisible();

    page.once('dialog', (dialog) => {
      expect(dialog.message()).toBe('You clicked 2 times!');
      dialog.dismiss().catch(() => {});
    });

    const dialogPromise = page.waitForEvent('dialog');
    await page.getByRole('button', {name: 'Close'}).click();
    await dialogPromise;
  });
});



================================================
FILE: examples/custom-element/README.md
================================================
# Custom element example

This example shows the simplest setup using Remote DOM. It creates an `iframe` element to serve as the “remote” sandbox. In that sandbox, it defines a `ui-button` custom element, which allows the remote environment to render a styled button.

This example also shows how you can define event handlers that are called between environments, by showing a `click` event on the `ui-button` element. In order to support function calls over a `postMessage` sandbox, this example uses [`@quilted/threads`](https://github.com/lemonmade/quilt/tree/main/packages/threads), which was designed to work well with Remote DOM. However, you can use any other library that allows you to pass functions between JavaScript environments, like [comlink](https://github.com/GoogleChromeLabs/comlink).

## Running this example

From the root of the repository, run the following command:

```bash
pnpm --filter example-custom-element start
```



================================================
FILE: examples/custom-element/CHANGELOG.md
================================================
# example-custom-element

## 0.0.24

### Patch Changes

- Updated dependencies [[`d9b4dab`](https://github.com/Shopify/remote-dom/commit/d9b4dab1ce2f76751fafab04e7a6ede8a3aa8045)]:
  - @remote-dom/core@1.10.1

## 0.0.23

### Patch Changes

- Updated dependencies [[`2be51e8`](https://github.com/Shopify/remote-dom/commit/2be51e87718929482a598ba3bb3972f539fa9d8d)]:
  - @remote-dom/core@1.10.0

## 0.0.22

### Patch Changes

- Updated dependencies [[`a7be991`](https://github.com/Shopify/remote-dom/commit/a7be991202a16cec1866c7eccea86012a5a91263), [`a7be991`](https://github.com/Shopify/remote-dom/commit/a7be991202a16cec1866c7eccea86012a5a91263)]:
  - @remote-dom/core@1.9.0

## 0.0.21

### Patch Changes

- Updated dependencies [[`d4fd36d`](https://github.com/Shopify/remote-dom/commit/d4fd36df90a7813b5003c5a88386335958d11d65)]:
  - @remote-dom/core@1.8.1

## 0.0.20

### Patch Changes

- Updated dependencies [[`ed2d24c`](https://github.com/Shopify/remote-dom/commit/ed2d24cb0d4a4b4146a1507796a40b4fdc3aaf8d)]:
  - @remote-dom/core@1.8.0

## 0.0.19

### Patch Changes

- Updated dependencies [[`33baaba`](https://github.com/Shopify/remote-dom/commit/33baaba512ca461068f57dcba707ef1cc640bfca)]:
  - @remote-dom/core@1.7.1

## 0.0.18

### Patch Changes

- Updated dependencies [[`a9a88ab`](https://github.com/Shopify/remote-dom/commit/a9a88abe4ba81b253f0cc6cdd5e82a25bbe908c1)]:
  - @remote-dom/core@1.7.0

## 0.0.17

### Patch Changes

- Updated dependencies [[`df294ab`](https://github.com/Shopify/remote-dom/commit/df294abad5522110e031e5b3e2a978871aa703fb)]:
  - @remote-dom/core@1.6.1

## 0.0.16

### Patch Changes

- Updated dependencies [[`8cbf2c2`](https://github.com/Shopify/remote-dom/commit/8cbf2c2a6130dd0a19088a2adf18b506f468be8b)]:
  - @remote-dom/core@1.6.0

## 0.0.15

### Patch Changes

- Updated dependencies [[`99a8e1a`](https://github.com/Shopify/remote-dom/commit/99a8e1ad8d441619a33a5a4c3f2424fe1ccbe8df)]:
  - @remote-dom/core@1.5.2

## 0.0.14

### Patch Changes

- Updated dependencies [[`994e2ea`](https://github.com/Shopify/remote-dom/commit/994e2ea2f7ab0e67a2c37e5295ce86618b004518), [`017ca02`](https://github.com/Shopify/remote-dom/commit/017ca029fb148a51115edb12b7c8ccd49d2c52eb)]:
  - @remote-dom/core@1.5.1

## 0.0.13

### Patch Changes

- Updated dependencies [[`2479b21`](https://github.com/Shopify/remote-dom/commit/2479b21406f6149063bfc095dbb6c3a019386403)]:
  - @remote-dom/core@1.5.0

## 0.0.12

### Patch Changes

- Updated dependencies [[`3c6bd29`](https://github.com/Shopify/remote-dom/commit/3c6bd291121b9fa02cac4ba57274601e97b2a2d2)]:
  - @remote-dom/core@1.4.1

## 0.0.11

### Patch Changes

- Updated dependencies [[`3bec698`](https://github.com/Shopify/remote-dom/commit/3bec6983756c4b8a6834a037ac520438ef59d28f)]:
  - @remote-dom/core@1.4.0

## 0.0.10

### Patch Changes

- Updated dependencies [[`218ba3b`](https://github.com/Shopify/remote-dom/commit/218ba3bf1ff2e7518a7dcec11ffd352de70b16f8)]:
  - @remote-dom/core@1.3.0

## 0.0.9

### Patch Changes

- Updated dependencies [[`6b38a37`](https://github.com/Shopify/remote-dom/commit/6b38a379ef2f0644bff18390708a48b4f6d3fa5d)]:
  - @remote-dom/core@1.2.1

## 0.0.8

### Patch Changes

- Updated dependencies [[`040e7c5`](https://github.com/Shopify/remote-dom/commit/040e7c5dde658596ccbf883e2d3810955790eff0), [`894d6f3`](https://github.com/Shopify/remote-dom/commit/894d6f3396ebb2e1de7e91b1a445aa0a39195bb9)]:
  - @remote-dom/core@1.2.0

## 0.0.7

### Patch Changes

- Updated dependencies [[`22e6512`](https://github.com/Shopify/remote-dom/commit/22e6512f797d97d2106f181d730d995f37c6edaf)]:
  - @remote-dom/core@1.1.0

## 0.0.6

### Patch Changes

- Updated dependencies [[`ee5e843`](https://github.com/Shopify/remote-dom/commit/ee5e843a85c1d213420ae25cb2fc248484ca04f3)]:
  - @remote-dom/core@1.0.1

## 0.0.5

### Patch Changes

- Updated dependencies [[`37be652`](https://github.com/Shopify/remote-dom/commit/37be652f288d1eec170c0be13b2da516f8db5dcf)]:
  - @remote-dom/core@1.0.0

## 0.0.4

### Patch Changes

- Updated dependencies [[`9576a72`](https://github.com/Shopify/remote-dom/commit/9576a72fa354481621c53efde4169829fe9bfabf)]:
  - @remote-dom/core@0.1.1

## 0.0.3

### Patch Changes

- Updated dependencies [[`7061ded`](https://github.com/Shopify/remote-dom/commit/7061ded1da4699c6dd6a820eeb940a8af7c66d82)]:
  - @remote-dom/core@0.1.0

## 0.0.2

### Patch Changes

- Updated dependencies [[`5939cca`](https://github.com/Shopify/remote-dom/commit/5939cca8112417124327bd26f9e2c21f4bf9b20a), [`8e1fad4`](https://github.com/Shopify/remote-dom/commit/8e1fad4a00cfe68ff1594fbabeec10c29958685f)]:
  - @remote-dom/core@0.0.2



================================================
FILE: examples/custom-element/package.json
================================================
{
  "name": "example-custom-element",
  "version": "0.0.24",
  "type": "module",
  "private": true,
  "scripts": {
    "start": "vite"
  },
  "dependencies": {
    "@quilted/threads": "^3.0.0",
    "@remote-dom/core": "workspace:*"
  }
}



================================================
FILE: examples/custom-element/vite.config.js
================================================
import {defineConfig} from 'vite';

export default defineConfig({
  root: './app',
  resolve: {
    // Alias the `@remote-dom` packages to their source files
    conditions: ['quilt:source'],
  },
});



================================================
FILE: examples/custom-element/app/index.html
================================================
<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="https://fav.farm/🛰️" />
    <title>Custom element • Remote DOM</title>
  </head>

  <body>
    <div id="root"></div>

    <!-- The “remote” environment, which we will render in the element above -->
    <iframe id="remote-iframe" src="/remote.html" hidden></iframe>

    <script type="module">
      class UIButton extends HTMLElement {
        // By default, `DOMRemoteReceiver` will assign remote properties as properties,
        // but only if the element has a matching property defined. Otherwise, the remote
        // properties will be set as attributes. We’ll observe the `primary` attribute
        // in order to update our rendered content when that attribute changes. We’ll
        // define a `onClick` method, though, which will be set to the value of the `onClick`
        // remote property.
        static get observedAttributes() {
          return ['primary'];
        }

        connectedCallback() {
          const primary = this.hasAttribute('primary') ?? false;

          const root = this.attachShadow({mode: 'open'});

          // We render a <slot> where we want the element’s children to go.
          root.innerHTML = `
            <style>
              .Button {
                appearance: none;
                font-size: 1rem;
                padding: 0.5rem 1rem;
                background: transparent;
                border: 1px solid gray;
                border-radius: 0.5rem;
              }

              .Button--primary {
                background: blue;
                color: white;
              }
            </style>
            <button class="Button"><slot></slot></button>
          `;

          if (primary) {
            root.querySelector('.Button').classList.add('Button--primary');
          }
        }

        attributeChangedCallback(name, oldValue, newValue) {
          if (name === 'primary') {
            const button = this.shadowRoot?.querySelector('.Button');

            if (button == null) return;

            if (newValue == null) {
              button.classList.remove('Button--primary');
            } else {
              button.classList.add('Button--primary');
            }
          }
        }

        // Remote DOM will automatically call methods on a custom element to satisfy
        // remote method calls.
        focus() {
          this.shadowRoot.querySelector('button').focus();
        }
      }

      customElements.define('ui-button', UIButton);
    </script>

    <script type="module">
      import {DOMRemoteReceiver} from '@remote-dom/core/receivers';
      import {ThreadIframe} from '@quilted/threads';

      const root = document.querySelector('#root');
      const iframe = document.querySelector('#remote-iframe');

      // In earlier examples, we did not pass any arguments, which allows the DOM
      // receiver to mirror any element it receives. By passing the `elements` option,
      // we are restricting the allowed elements to only the ones we list, which in this
      // case means only our `ui-button` element can be rendered.
      const receiver = new DOMRemoteReceiver({
        elements: ['ui-button'],
      });
      receiver.connect(root);

      // We use the `@quilted/threads` library to create a “thread” for our iframe,
      // which lets us communicate over `postMessage` without having to worry about
      // most of its complexities. This includes the ability to send functions between
      // environments, which we rely on for the `click` event listener.
      const thread = new ThreadIframe(iframe);

      // We will call the `render` method on the thread, which will send the iframe
      // the `receiver.connection` object. This object, called a `RemoteConnection`,
      // allows the remote environment to synchronize its tree of UI elements into
      // the `root` element we connected our `receiver` to above.
      thread.imports.render(receiver.connection);
    </script>
  </body>
</html>



================================================
FILE: examples/custom-element/app/remote.html
================================================
<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="https://fav.farm/🛰️" />
    <title>Custom element (remote) • Remote DOM</title>
  </head>

  <body>
    <div id="root">
      <ui-button primary>Clicked 0 times</ui-button>
    </div>

    <script type="module">
      import {RemoteElement} from '@remote-dom/core/elements';

      // We need to define our `ui-button` element so it can be synchronized
      // with the host environment.
      //
      // For full details on defining remote elements, see the documentation
      // for `@remote-dom/core/elements`:
      // https://github.com/Shopify/remote-dom/tree/main/packages/core#elements
      class UIButton extends RemoteElement {
        static get remoteAttributes() {
          return ['primary'];
        }

        static get remoteEvents() {
          return {
            click: {
              dispatchEvent(detail) {
                console.log(`Event detail: `, detail);
              },
            },
          };
        }
      }

      customElements.define('ui-button', UIButton);
    </script>

    <script type="module">
      // To make this example dynamic, we’ll add an event listener to the button
      // that updates the button’s text content and removes the `primary` attribute
      let count = 0;
      const button = document.querySelector('ui-button');

      button.addEventListener('click', () => {
        count += 1;

        button.textContent = `Clicked ${count} ${
          count === 1 ? 'time' : 'times'
        }`;

        if (count === 5) {
          button.removeAttribute('primary');
        }
      });
    </script>

    <script type="module">
      import {RemoteMutationObserver} from '@remote-dom/core/elements';
      import {ThreadNestedIframe} from '@quilted/threads';

      const root = document.querySelector('#root');

      // We use the `@quilted/threads` library to create a “thread” for our iframe,
      // which lets us communicate over `postMessage` without having to worry about
      // most of its complexities.
      //
      // This block exposes the `render` method that was used by the host application,
      // in `index.html`. We receive the `RemoteConnection` object, and start synchronizing
      // changes to the `<div id="root">` element that contains our UI.
      new ThreadNestedIframe({
        exports: {
          async render(connection) {
            // We use the `RemoteMutationObserver` class, which extends the native DOM
            // `MutationObserver`, to send any changes to a tree of DOM elements over
            // a `RemoteConnection`.
            const observer = new RemoteMutationObserver(connection);
            observer.observe(root);
          },
        },
      });
    </script>
  </body>
</html>



================================================
FILE: examples/getting-started/README.md
================================================
# Getting started example

This example shows the simplest setup using Remote DOM. It creates an `iframe` element to serve as the “remote” sandbox. In that sandbox, it only renders text, which it communicates manually to the parent document through `postMessage()`.

For a more complete example that shows more of Remote DOM’s capabilities, check out the [custom element example](/examples/custom-element/) next.

## Running this example

From the root of the repository, run the following command:

```bash
pnpm --filter example-getting-started start
```



================================================
FILE: examples/getting-started/CHANGELOG.md
================================================
# example-getting-started

## 0.0.24

### Patch Changes

- Updated dependencies [[`d9b4dab`](https://github.com/Shopify/remote-dom/commit/d9b4dab1ce2f76751fafab04e7a6ede8a3aa8045)]:
  - @remote-dom/core@1.10.1

## 0.0.23

### Patch Changes

- Updated dependencies [[`2be51e8`](https://github.com/Shopify/remote-dom/commit/2be51e87718929482a598ba3bb3972f539fa9d8d)]:
  - @remote-dom/core@1.10.0

## 0.0.22

### Patch Changes

- Updated dependencies [[`a7be991`](https://github.com/Shopify/remote-dom/commit/a7be991202a16cec1866c7eccea86012a5a91263), [`a7be991`](https://github.com/Shopify/remote-dom/commit/a7be991202a16cec1866c7eccea86012a5a91263)]:
  - @remote-dom/core@1.9.0

## 0.0.21

### Patch Changes

- Updated dependencies [[`d4fd36d`](https://github.com/Shopify/remote-dom/commit/d4fd36df90a7813b5003c5a88386335958d11d65)]:
  - @remote-dom/core@1.8.1

## 0.0.20

### Patch Changes

- Updated dependencies [[`ed2d24c`](https://github.com/Shopify/remote-dom/commit/ed2d24cb0d4a4b4146a1507796a40b4fdc3aaf8d)]:
  - @remote-dom/core@1.8.0

## 0.0.19

### Patch Changes

- Updated dependencies [[`33baaba`](https://github.com/Shopify/remote-dom/commit/33baaba512ca461068f57dcba707ef1cc640bfca)]:
  - @remote-dom/core@1.7.1

## 0.0.18

### Patch Changes

- Updated dependencies [[`a9a88ab`](https://github.com/Shopify/remote-dom/commit/a9a88abe4ba81b253f0cc6cdd5e82a25bbe908c1)]:
  - @remote-dom/core@1.7.0

## 0.0.17

### Patch Changes

- Updated dependencies [[`df294ab`](https://github.com/Shopify/remote-dom/commit/df294abad5522110e031e5b3e2a978871aa703fb)]:
  - @remote-dom/core@1.6.1

## 0.0.16

### Patch Changes

- Updated dependencies [[`8cbf2c2`](https://github.com/Shopify/remote-dom/commit/8cbf2c2a6130dd0a19088a2adf18b506f468be8b)]:
  - @remote-dom/core@1.6.0

## 0.0.15

### Patch Changes

- Updated dependencies [[`99a8e1a`](https://github.com/Shopify/remote-dom/commit/99a8e1ad8d441619a33a5a4c3f2424fe1ccbe8df)]:
  - @remote-dom/core@1.5.2

## 0.0.14

### Patch Changes

- Updated dependencies [[`994e2ea`](https://github.com/Shopify/remote-dom/commit/994e2ea2f7ab0e67a2c37e5295ce86618b004518), [`017ca02`](https://github.com/Shopify/remote-dom/commit/017ca029fb148a51115edb12b7c8ccd49d2c52eb)]:
  - @remote-dom/core@1.5.1

## 0.0.13

### Patch Changes

- Updated dependencies [[`2479b21`](https://github.com/Shopify/remote-dom/commit/2479b21406f6149063bfc095dbb6c3a019386403)]:
  - @remote-dom/core@1.5.0

## 0.0.12

### Patch Changes

- Updated dependencies [[`3c6bd29`](https://github.com/Shopify/remote-dom/commit/3c6bd291121b9fa02cac4ba57274601e97b2a2d2)]:
  - @remote-dom/core@1.4.1

## 0.0.11

### Patch Changes

- Updated dependencies [[`3bec698`](https://github.com/Shopify/remote-dom/commit/3bec6983756c4b8a6834a037ac520438ef59d28f)]:
  - @remote-dom/core@1.4.0

## 0.0.10

### Patch Changes

- Updated dependencies [[`218ba3b`](https://github.com/Shopify/remote-dom/commit/218ba3bf1ff2e7518a7dcec11ffd352de70b16f8)]:
  - @remote-dom/core@1.3.0

## 0.0.9

### Patch Changes

- Updated dependencies [[`6b38a37`](https://github.com/Shopify/remote-dom/commit/6b38a379ef2f0644bff18390708a48b4f6d3fa5d)]:
  - @remote-dom/core@1.2.1

## 0.0.8

### Patch Changes

- Updated dependencies [[`040e7c5`](https://github.com/Shopify/remote-dom/commit/040e7c5dde658596ccbf883e2d3810955790eff0), [`894d6f3`](https://github.com/Shopify/remote-dom/commit/894d6f3396ebb2e1de7e91b1a445aa0a39195bb9)]:
  - @remote-dom/core@1.2.0

## 0.0.7

### Patch Changes

- Updated dependencies [[`22e6512`](https://github.com/Shopify/remote-dom/commit/22e6512f797d97d2106f181d730d995f37c6edaf)]:
  - @remote-dom/core@1.1.0

## 0.0.6

### Patch Changes

- Updated dependencies [[`ee5e843`](https://github.com/Shopify/remote-dom/commit/ee5e843a85c1d213420ae25cb2fc248484ca04f3)]:
  - @remote-dom/core@1.0.1

## 0.0.5

### Patch Changes

- Updated dependencies [[`37be652`](https://github.com/Shopify/remote-dom/commit/37be652f288d1eec170c0be13b2da516f8db5dcf)]:
  - @remote-dom/core@1.0.0

## 0.0.4

### Patch Changes

- Updated dependencies [[`9576a72`](https://github.com/Shopify/remote-dom/commit/9576a72fa354481621c53efde4169829fe9bfabf)]:
  - @remote-dom/core@0.1.1

## 0.0.3

### Patch Changes

- Updated dependencies [[`7061ded`](https://github.com/Shopify/remote-dom/commit/7061ded1da4699c6dd6a820eeb940a8af7c66d82)]:
  - @remote-dom/core@0.1.0

## 0.0.2

### Patch Changes

- Updated dependencies [[`5939cca`](https://github.com/Shopify/remote-dom/commit/5939cca8112417124327bd26f9e2c21f4bf9b20a), [`8e1fad4`](https://github.com/Shopify/remote-dom/commit/8e1fad4a00cfe68ff1594fbabeec10c29958685f)]:
  - @remote-dom/core@0.0.2



================================================
FILE: examples/getting-started/package.json
================================================
{
  "name": "example-getting-started",
  "version": "0.0.24",
  "type": "module",
  "private": true,
  "scripts": {
    "start": "vite"
  },
  "dependencies": {
    "@remote-dom/core": "workspace:*"
  }
}



================================================
FILE: examples/getting-started/vite.config.js
================================================
import {defineConfig} from 'vite';

export default defineConfig({
  root: './app',
  resolve: {
    // Alias the `@remote-dom` packages to their source files
    conditions: ['quilt:source'],
  },
});



================================================
FILE: examples/getting-started/app/index.html
================================================
<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="https://fav.farm/🛰️" />
    <title>Getting started • Remote DOM</title>
  </head>

  <body>
    <div id="root"></div>

    <!-- The “remote” environment, which we will render in the element above -->
    <iframe id="remote-iframe" src="/remote.html" hidden></iframe>

    <script type="module">
      import {DOMRemoteReceiver} from '@remote-dom/core/receivers';

      const root = document.querySelector('#root');
      const iframe = document.querySelector('#remote-iframe');

      // A `DOMRemoteReceiver` will automatically synchronize changes
      // from the remote environment to the host environment as native
      // HTML elements. We connect it to the `root` element so that it
      // will insert any content from the remote environment there.
      const receiver = new DOMRemoteReceiver();
      receiver.connect(root);

      window.addEventListener('message', ({source, data}) => {
        // Ensure the message is coming from our iframe
        if (source !== iframe.contentWindow) return;

        // Communicate the mutation to the `DOMRemoteReceiver`
        receiver.connection.mutate(data);
      });
    </script>
  </body>
</html>



================================================
FILE: examples/getting-started/app/remote.html
================================================
<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="https://fav.farm/🛰️" />
    <title>Getting started (remote) • Remote DOM</title>
  </head>

  <body>
    <div id="root"></div>

    <script type="module">
      // We will synchronize changes in this element to the host environment.
      const root = document.querySelector('#root');

      let count = 0;

      // Update text every second, to demonstrate that Remote DOM can handle
      // both initial HTML and updates that happen later.
      setInterval(() => {
        count += 1;
        render();
      }, 1_000);

      render();

      function render() {
        root.textContent = `Rendered ${count} ${
          count === 1 ? 'second' : 'seconds'
        } ago`;
      }
    </script>

    <script type="module">
      import {RemoteMutationObserver} from '@remote-dom/core/elements';

      // We will synchronize changes in this element to the host environment.
      const root = document.querySelector('#root');

      // Create a special `MutationObserver` that will map changes
      // in the HTML to Remote DOM-compatible mutations.
      const observer = new RemoteMutationObserver({
        mutate(mutations) {
          window.parent.postMessage(mutations, '*');
        },
      });

      observer.observe(root);
    </script>
  </body>
</html>



================================================
FILE: examples/kitchen-sink/README.md
================================================
# “Kitchen sink” example

This example shows most of Remote DOM’s features in action. It includes multiple custom elements with properties, event listeners, and methods. It also shows how you can choose between using an `<iframe>` to sandbox remote code, or use Remote DOM’s polyfill to run DOM libraries in a [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/).

To show how thin a layer Remote DOM is on top of the basic DOM APIs you may already know, this example implements the “remote” code using a variety of techniques and libraries. In the [`app/remote/examples` directory](/examples/kitchen-sink/app/remote/examples/) You can see the same UI built using:

- “Vanilla” JavaScript, where we use standard DOM APIs to create our tree of elements
- [htm](https://github.com/developit/htm)
- [Preact](https://preactjs.com)
- [React](https://react.dev)
- [Svelte](https://svelte.dev)
- [Vue](https://vuejs.org)

## Running this example

From the root of the repository, run the following command:

```bash
pnpm --filter example-kitchen-sink start
```



================================================
FILE: examples/kitchen-sink/CHANGELOG.md
================================================
# example-kitchen-sink

## 0.0.31

### Patch Changes

- Updated dependencies [[`d9b4dab`](https://github.com/Shopify/remote-dom/commit/d9b4dab1ce2f76751fafab04e7a6ede8a3aa8045)]:
  - @remote-dom/core@1.10.1

## 0.0.30

### Patch Changes

- Updated dependencies [[`2be51e8`](https://github.com/Shopify/remote-dom/commit/2be51e87718929482a598ba3bb3972f539fa9d8d)]:
  - @remote-dom/core@1.10.0

## 0.0.29

### Patch Changes

- Updated dependencies [[`a7be991`](https://github.com/Shopify/remote-dom/commit/a7be991202a16cec1866c7eccea86012a5a91263), [`a7be991`](https://github.com/Shopify/remote-dom/commit/a7be991202a16cec1866c7eccea86012a5a91263)]:
  - @remote-dom/core@1.9.0

## 0.0.28

### Patch Changes

- Updated dependencies [[`d4fd36d`](https://github.com/Shopify/remote-dom/commit/d4fd36df90a7813b5003c5a88386335958d11d65)]:
  - @remote-dom/core@1.8.1

## 0.0.27

### Patch Changes

- Updated dependencies [[`ed2d24c`](https://github.com/Shopify/remote-dom/commit/ed2d24cb0d4a4b4146a1507796a40b4fdc3aaf8d)]:
  - @remote-dom/core@1.8.0

## 0.0.26

### Patch Changes

- Updated dependencies [[`33baaba`](https://github.com/Shopify/remote-dom/commit/33baaba512ca461068f57dcba707ef1cc640bfca)]:
  - @remote-dom/core@1.7.1

## 0.0.25

### Patch Changes

- Updated dependencies [[`ca6a668`](https://github.com/Shopify/remote-dom/commit/ca6a66893f02eb4e7881a7117de5a461c7ae3708), [`fe94f9b`](https://github.com/Shopify/remote-dom/commit/fe94f9b6e7087e1146fa2301b3d339c760c9d9a9)]:
  - @remote-dom/compat@1.0.2

## 0.0.24

### Patch Changes

- Updated dependencies [[`88d4956`](https://github.com/Shopify/remote-dom/commit/88d495608de6913a084b46384aaa19a6d9e599fb)]:
  - @remote-dom/preact@1.3.0

## 0.0.23

### Patch Changes

- Updated dependencies [[`9abf5be`](https://github.com/Shopify/remote-dom/commit/9abf5bee323dfa522f9061ba61ce2f433a36cb4e)]:
  - @remote-dom/compat@1.0.1
  - @remote-dom/preact@1.2.3
  - @remote-dom/react@1.2.2

## 0.0.22

### Patch Changes

- Updated dependencies [[`79419d9`](https://github.com/Shopify/remote-dom/commit/79419d9377013a979ebc4ece53f59d9a9a893094), [`a9a88ab`](https://github.com/Shopify/remote-dom/commit/a9a88abe4ba81b253f0cc6cdd5e82a25bbe908c1)]:
  - @remote-dom/signals@2.1.0
  - @remote-dom/core@1.7.0

## 0.0.21

### Patch Changes

- Updated dependencies [[`df294ab`](https://github.com/Shopify/remote-dom/commit/df294abad5522110e031e5b3e2a978871aa703fb)]:
  - @remote-dom/core@1.6.1
  - @remote-dom/signals@2.0.0

## 0.0.20

### Patch Changes

- Updated dependencies [[`1a42bf6`](https://github.com/Shopify/remote-dom/commit/1a42bf6d72a1dcfe5403c097dfd406b116a3455b), [`8cbf2c2`](https://github.com/Shopify/remote-dom/commit/8cbf2c2a6130dd0a19088a2adf18b506f468be8b)]:
  - @remote-dom/compat@1.0.0
  - @remote-dom/core@1.6.0
  - @remote-dom/signals@2.0.0
  - @remote-dom/preact@1.2.2

## 0.0.19

### Patch Changes

- Updated dependencies [[`99a8e1a`](https://github.com/Shopify/remote-dom/commit/99a8e1ad8d441619a33a5a4c3f2424fe1ccbe8df)]:
  - @remote-dom/signals@1.1.2
  - @remote-dom/core@1.5.2

## 0.0.18

### Patch Changes

- Updated dependencies [[`59f417b`](https://github.com/Shopify/remote-dom/commit/59f417b4abe5aa5d59999200430a18f5fe1aa810)]:
  - @remote-dom/react@1.2.1

## 0.0.17

### Patch Changes

- Updated dependencies [[`994e2ea`](https://github.com/Shopify/remote-dom/commit/994e2ea2f7ab0e67a2c37e5295ce86618b004518), [`017ca02`](https://github.com/Shopify/remote-dom/commit/017ca029fb148a51115edb12b7c8ccd49d2c52eb)]:
  - @remote-dom/core@1.5.1
  - @remote-dom/preact@1.2.1
  - @remote-dom/signals@1.1.1

## 0.0.16

### Patch Changes

- Updated dependencies [[`2479b21`](https://github.com/Shopify/remote-dom/commit/2479b21406f6149063bfc095dbb6c3a019386403)]:
  - @remote-dom/signals@2.0.0
  - @remote-dom/preact@1.2.0
  - @remote-dom/react@1.2.0
  - @remote-dom/core@1.5.0

## 0.0.15

### Patch Changes

- Updated dependencies [[`3c6bd29`](https://github.com/Shopify/remote-dom/commit/3c6bd291121b9fa02cac4ba57274601e97b2a2d2)]:
  - @remote-dom/core@1.4.1

## 0.0.14

### Patch Changes

- Updated dependencies [[`3bec698`](https://github.com/Shopify/remote-dom/commit/3bec6983756c4b8a6834a037ac520438ef59d28f)]:
  - @remote-dom/signals@2.0.0
  - @remote-dom/preact@1.1.0
  - @remote-dom/react@1.1.0
  - @remote-dom/core@1.4.0

## 0.0.13

### Patch Changes

- Updated dependencies [[`6e1f6b6`](https://github.com/Shopify/remote-dom/commit/6e1f6b69aec1958e9e5f125bd9d16847f905efa7)]:
  - @remote-dom/react@1.0.2

## 0.0.12

### Patch Changes

- Updated dependencies [[`218ba3b`](https://github.com/Shopify/remote-dom/commit/218ba3bf1ff2e7518a7dcec11ffd352de70b16f8)]:
  - @remote-dom/core@1.3.0
  - @remote-dom/signals@2.0.0
  - @remote-dom/preact@1.0.2

## 0.0.11

### Patch Changes

- Updated dependencies [[`6b38a37`](https://github.com/Shopify/remote-dom/commit/6b38a379ef2f0644bff18390708a48b4f6d3fa5d)]:
  - @remote-dom/core@1.2.1

## 0.0.10

### Patch Changes

- Updated dependencies [[`040e7c5`](https://github.com/Shopify/remote-dom/commit/040e7c5dde658596ccbf883e2d3810955790eff0), [`894d6f3`](https://github.com/Shopify/remote-dom/commit/894d6f3396ebb2e1de7e91b1a445aa0a39195bb9)]:
  - @remote-dom/core@1.2.0
  - @remote-dom/signals@2.0.0

## 0.0.9

### Patch Changes

- Updated dependencies [[`22e6512`](https://github.com/Shopify/remote-dom/commit/22e6512f797d97d2106f181d730d995f37c6edaf)]:
  - @remote-dom/core@1.1.0
  - @remote-dom/signals@2.0.0
  - @remote-dom/preact@1.0.1

## 0.0.8

### Patch Changes

- Updated dependencies [[`ee5e843`](https://github.com/Shopify/remote-dom/commit/ee5e843a85c1d213420ae25cb2fc248484ca04f3)]:
  - @remote-dom/core@1.0.1

## 0.0.7

### Patch Changes

- Updated dependencies [[`2b09e04`](https://github.com/Shopify/remote-dom/commit/2b09e042ff87f047fbe98481a73d31b785c9987f)]:
  - @remote-dom/react@1.0.1

## 0.0.6

### Patch Changes

- Updated dependencies [[`37be652`](https://github.com/Shopify/remote-dom/commit/37be652f288d1eec170c0be13b2da516f8db5dcf)]:
  - @remote-dom/core@1.0.0
  - @remote-dom/preact@1.0.0
  - @remote-dom/react@1.0.0
  - @remote-dom/signals@2.0.0

## 0.0.5

### Patch Changes

- Updated dependencies [[`7398741`](https://github.com/Shopify/remote-dom/commit/7398741dc42f474d344ed98ea634bc6a255d6650)]:
  - @remote-dom/react@0.1.3

## 0.0.4

### Patch Changes

- Updated dependencies [[`e4629a7`](https://github.com/Shopify/remote-dom/commit/e4629a7e50057eb57f8a2f90b393fba6688d0d19)]:
  - @remote-dom/react@0.1.2

## 0.0.3

### Patch Changes

- Updated dependencies [[`9576a72`](https://github.com/Shopify/remote-dom/commit/9576a72fa354481621c53efde4169829fe9bfabf)]:
  - @remote-dom/core@0.1.1
  - @remote-dom/preact@0.1.1
  - @remote-dom/react@0.1.1
  - @remote-dom/signals@1.0.1

## 0.0.2

### Patch Changes

- Updated dependencies [[`7061ded`](https://github.com/Shopify/remote-dom/commit/7061ded1da4699c6dd6a820eeb940a8af7c66d82)]:
  - @remote-dom/core@0.1.0
  - @remote-dom/preact@0.1.0
  - @remote-dom/react@0.1.0
  - @remote-dom/signals@1.0.0

## 0.0.1

### Patch Changes

- Updated dependencies [[`5939cca`](https://github.com/Shopify/remote-dom/commit/5939cca8112417124327bd26f9e2c21f4bf9b20a), [`8e1fad4`](https://github.com/Shopify/remote-dom/commit/8e1fad4a00cfe68ff1594fbabeec10c29958685f)]:
  - @remote-dom/signals@0.0.2
  - @remote-dom/preact@0.0.2
  - @remote-dom/react@0.0.2
  - @remote-dom/core@0.0.2



================================================
FILE: examples/kitchen-sink/package.json
================================================
{
  "name": "example-kitchen-sink",
  "type": "module",
  "private": true,
  "version": "0.0.31",
  "scripts": {
    "start": "vite"
  },
  "dependencies": {
    "@preact/signals": "^1.3.0",
    "@quilted/threads": "^3.0.0",
    "@remote-dom/compat": "workspace:*",
    "@remote-dom/core": "workspace:*",
    "@remote-dom/preact": "workspace:*",
    "@remote-dom/react": "workspace:*",
    "@remote-dom/signals": "workspace:*",
    "@remote-ui/core": "^2.2.4",
    "@remote-ui/react": "^5.0.4",
    "preact": "^10.22.0",
    "react": "^18.3.0",
    "react-dom": "^18.3.0",
    "svelte": "^4.2.19",
    "vue": "^3.4.38"
  },
  "devDependencies": {
    "@preact/preset-vite": "^2.9.0",
    "@types/react": "^18.3.5",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "@vitejs/plugin-vue": "^5.1.3",
    "@sveltejs/vite-plugin-svelte": "^3.1.2",
    "vite": "^5.4.0"
  },
  "sideEffects": [
    "./app/remote/elements.ts"
  ]
}



================================================
FILE: examples/kitchen-sink/tsconfig.json
================================================
{
  "extends": "@quilted/typescript/tsconfig.project.json",
  "compilerOptions": {
    "outDir": "build/typescript",
    "jsx": "react-jsx",
    "jsxImportSource": "preact"
  },
  "include": ["app"],
  "references": [
    {"path": "../../packages/compat"},
    {"path": "../../packages/core"},
    {"path": "../../packages/preact"},
    {"path": "../../packages/react"},
    {"path": "../../packages/signals"}
  ]
}



================================================
FILE: examples/kitchen-sink/vite.config.js
================================================
import {defineConfig} from 'vite';
import preact from '@preact/preset-vite';
import vue from '@vitejs/plugin-vue';
import {svelte, vitePreprocess} from '@sveltejs/vite-plugin-svelte';

export default defineConfig({
  root: 'app',
  resolve: {
    // Alias the `@remote-dom` packages to their source files
    conditions: ['quilt:source'],
  },
  plugins: [
    preact({
      reactAliasesEnabled: false,
      // We manually set the JSX transformation to apply to examples per-file
      exclude: ['remote/examples/*.tsx'],
    }),
    svelte({
      preprocess: vitePreprocess(),
    }),
    vue({
      template: {
        compilerOptions: {
          isCustomElement: (tag) => tag.startsWith('ui-'),
        },
      },
    }),
  ],
});



================================================
FILE: examples/kitchen-sink/app/host.tsx
================================================
import {render} from 'preact';
import {
  RemoteRootRenderer,
  RemoteFragmentRenderer,
  createRemoteComponentRenderer,
} from '@remote-dom/preact/host';
import {ThreadIframe, ThreadWebWorker} from '@quilted/threads';

import type {SandboxAPI} from './types.ts';
import {Button, Modal, Stack, Text, ControlPanel} from './host/components.tsx';
import {createState} from './host/state.ts';
import {adaptToLegacyRemoteChannel} from '@remote-dom/compat';

// We will put any remote elements we want to render in this root element.
const uiRoot = document.querySelector('main')!;

// We use the `@quilted/threads` library to create a “thread” for our iframe,
// which lets us communicate over `postMessage` without having to worry about
// most of its complexities.
const iframe = document.querySelector('iframe')!;
const iframeSandbox = new ThreadIframe<SandboxAPI>(iframe);

// We also use the `@quilted/threads` library to create a “thread” around a Web
// Worker. We’ll run the same example code in both, depending on the `sandbox`
// state chosen by the user.
const worker = new Worker(
  new URL('./remote/worker/sandbox.ts', import.meta.url),
  {
    type: 'module',
  },
);
const workerSandbox = new ThreadWebWorker<SandboxAPI>(worker);

// We will use Preact to render remote elements in this example. The Preact
// helper library lets you do this by mapping the name of a remote element to
// a local Preact component. We’ve implemented the actual UI of our components in
// the `./host/components.tsx` file, but we need to wrap each one in the `createRemoteComponentRenderer()`
// helper function in order to get some Preact niceties, like automatic conversion
// of slots to element props, and using the instance of a Preact component as the
// target for methods called on matching remote elements.
const components = new Map([
  ['ui-text', createRemoteComponentRenderer(Text)],
  ['ui-button', createRemoteComponentRenderer(Button)],
  ['ui-stack', createRemoteComponentRenderer(Stack)],
  ['ui-modal', createRemoteComponentRenderer(Modal)],
  // The `remote-fragment` element is a special element created by Remote DOM when
  // it needs an unstyled container for a list of elements. This is primarily used
  // to convert elements passed as a prop to React or Preact components into a slotted
  // element. The `RemoteFragmentRenderer` component is provided to render this element
  // on the host.
  ['remote-fragment', RemoteFragmentRenderer],
]);

// We offload most of the complex state logic to this `createState()` function. We’re
// just leaving the key bit in this file: when the example or sandbox changes, we render
// the example in the chosen sandbox. The `createState()` passes us a fresh `receiver`
// each time. This object, a `SignalRemoteReceiver`, keeps track of the tree of elements
// rendered by the remote environment. We use this object later to render these trees
// to Preact components using the `RemoteRootRenderer` component.

const {receiver, example, sandbox} = createState(
  async ({receiver, example, sandbox}) => {
    const api = {
      sandbox,
      example,
      async alert(content: string) {
        console.log(
          `Alert API used by example ${example} in the iframe sandbox`,
        );
        window.alert(content);
      },
      async closeModal() {
        document.querySelector('dialog')?.close();
      },
    };

    const sandboxToUse = sandbox === 'iframe' ? iframeSandbox : workerSandbox;

    if (example === 'react-remote-ui') {
      const remoteUiChannel = adaptToLegacyRemoteChannel(receiver.connection, {
        elements: {
          Text: 'ui-text',
          Button: 'ui-button',
          Stack: 'ui-stack',
          Modal: 'ui-modal',
        },
      });
      await sandboxToUse.imports.renderLegacy(remoteUiChannel, {
        ...api,
      });
    } else {
      await sandboxToUse.imports.render(receiver.connection, {
        ...api,
      });
    }
  },
);

// We render our Preact application, including the part that renders any remote
// elements for the current example, and the control panel that lets us change
// the framework or JavaScript sandbox being used.
render(
  <>
    <ExampleRenderer />
    <ControlPanel sandbox={sandbox} example={example} />
  </>,
  uiRoot,
);

function ExampleRenderer() {
  const value = receiver.value;

  if (value == null) return <div>Loading...</div>;

  if ('then' in value) {
    return <div>Rendering example...</div>;
  }

  if (value instanceof Error) {
    return <div>Error while rendering example: {value.message}</div>;
  }

  return (
    <div>
      <RemoteRootRenderer receiver={value} components={components} />
    </div>
  );
}



================================================
FILE: examples/kitchen-sink/app/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="https://fav.farm/🛰️" />
    <link rel="stylesheet" href="./style.css" />
    <title>Kitchen sink • Remote DOM</title>
  </head>
  <body>
    <main></main>

    <!--
      We use an iframe as the remote environment here, because it supports
      modules in most modern browsers. Aside from support for ES modules, there
      is nothing that prevents us from instead using a web worker as the remote
      environment. Note that, without using a separate domain, or manually
      hiding globals within the iframe, we are not actually creating a “safe”
      sandbox here, as the remote code can reach up into the parent.
    -->
    <iframe
      src="./remote/iframe/"
      style="visibility: hidden; position: absolute"
    ></iframe>

    <!--
      This JavaScript will connect to the iframe, and begin propagating UI updates
      into the UI element above.
    -->
    <script type="module" src="./host.tsx" crossorigin="anonymous"></script>
  </body>
</html>



================================================
FILE: examples/kitchen-sink/app/style.css
================================================
* {
  box-sizing: border-box;
}

html {
  font-size: 1.25em;
  height: -webkit-fill-available;
}

html:has(dialog[open]) {
  overflow: hidden;
}

body {
  background: rgb(23, 19, 31);
  color: rgb(239, 231, 243);
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica,
    Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';

  display: grid;
  justify-content: center;
  align-content: stretch;

  min-height: 100vh;
  min-height: -webkit-fill-available;
  margin: 0;
  padding: 0;
}

main {
  width: 35rem;
  max-width: 100vw;
  padding: 1.5em;
  container-type: inline-size;

  display: grid;
  gap: 1.5rem;
  align-content: space-between;
}

p {
  margin: 0;
}

a {
  color: rgb(7, 204, 204);
}

a:focus {
  outline: 1px solid transparent;
}

a:focus-visible {
  outline-color: rgb(7, 204, 204);
}

code {
  color: rgb(224, 129, 209);
}

ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

li {
  padding-bottom: 1.5em;
}

.Button {
  display: inline-flex;
  justify-content: center;
  max-inline-size: max-content;
  position: relative;
  appearance: none;
  border: 1px solid rgba(255, 255, 255, 0.1);
  background: rgb(91, 79, 115);
  color: inherit;
  border-radius: 8px;
  font-size: 1em;
  padding: 0.5rem 1rem;
  transition: background 0.15s ease;
}

.Button:focus {
  outline: 2px solid rgb(171, 135, 237);
  outline-offset: 2px;
}

.Button:hover,
.Button:focus-visible {
  background: rgb(110, 96, 139);
}

.Button:active {
  background: rgb(125, 109, 157);
}

.Stack {
  display: flex;
  flex-direction: column;
}

.Stack--spacing {
  gap: 1rem;
}

.Label {
  display: block;
  color: rgb(212, 169, 205);
  font-size: 0.85em;
  margin-bottom: 0.25em;
}

.Label--visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  margin: -1px;
  padding: 0;
  border: 0;
  clip: rect(0 0 0 0);
  overflow: hidden;
}

.Select-Input {
  display: block;
  width: 100%;
  background: rgba(255, 255, 255, 0.1);
  border: none;
  border-radius: 8px;
  color: rgb(239, 231, 243);
  font-size: 1em;
  padding: 0.5em;
  transition: background 0.15s ease;
}

.Modal {
  position: fixed;
  top: 50%;
  left: 50%;
  inset: 50% auto auto 50%;
  transform: translate(-50%, -50%);
  block-size: auto;
  inline-size: 30rem;
  max-inline-size: 90%;
  margin: 0;
  padding: 0;
  display: grid;
  grid-template-rows: 1fr auto;
  background: rgb(30, 25, 41);
  color: rgb(239, 231, 243);
  border: none;
  border-radius: 10px;
  box-shadow:
    rgb(255, 255, 255) 0px 0px 0px 0px,
    rgba(255, 255, 255, 0.1) 0px 0px 0px 1px,
    rgba(0, 0, 0, 0.3) 0px 10px 15px -3px,
    rgba(0, 0, 0, 0.5) 0px 4px 6px -4px;
}

.Modal::backdrop {
  background: rgba(9, 9, 11, 0.65);
}

.Modal[open] {
  animation: OpenModal 0.2s ease normal;
}

.Modal:not([open]) {
  display: none;
}

@keyframes OpenModal {
  from {
    opacity: 0;
    transform: translate(-50%, calc(3rem - 50%));
  }
  to {
    opacity: 1;
  }
}

.Modal-Content {
  display: grid;
  gap: 1rem;
  padding: 1rem;
  justify-content: start;
}

.Modal-Actions {
  padding: 1rem;
  border-block-start: 1px solid rgba(255, 255, 255, 0.1);
  display: flex;
  justify-content: end;
}

.Text--emphasis {
  font-weight: bold;
}

.ControlPanel {
  display: grid;
  grid-template-columns: minmax(0, 1fr);
  grid-gap: 1rem;
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 10px;
  padding: 1rem;
  font-size: 0.85em;
  color: rgb(166, 154, 172);
}

@container (min-width: 30em) {
  .ControlPanel {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
}

.ControlPanel-SectionHeading {
  margin: 0;
  font-size: 1.25em;
  color: rgb(239, 231, 243);
}

.ControlPanel-Section {
  display: grid;
  grid-template-columns: minmax(0, 1fr);
  grid-gap: 0.5rem;
}



================================================
FILE: examples/kitchen-sink/app/types.ts
================================================
import type {RemoteConnection} from '@remote-dom/core';
import {RemoteChannel} from '@remote-ui/core';

/**
 * Describes the technology used to sandbox the “remote” code, so that it does
 * not have access to the DOM of the “host” page.
 */
export type RenderSandbox =
  /**
   * The remote code is executed in an `<iframe>`.
   */
  | 'iframe'
  /**
   * The remote code is executed in a web worker.
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API
   */
  | 'worker';

/**
 * Describes the example used to render the UI in the sandboxed environment.
 * Each item in this list should have a corresponding example in the `app/examples`
 */
export type RenderExample =
  | 'vanilla'
  | 'htm'
  | 'preact'
  | 'react'
  | 'svelte'
  | 'vue'
  | 'react-remote-ui';

/**
 * The object that the “host” page will pass to the “remote” environment. This
 * object could contain any information you like; the library we’re using
 * to create a sandboxed “remote” environment, `@quilted/threads`, supports
 * passing functions, objects, and other JavaScript types between environments.
 */
export interface RenderAPI {
  /**
   * Which sandboxing technology was used to execute our code?
   */
  sandbox: RenderSandbox;

  /**
   * Which example is being used to render the sandboxed UI?
   */
  example: RenderExample;

  /**
   * Shows a modal alert to the user. Resolves when the user has dismissed the
   * alert.
   */
  alert(content: string): Promise<void>;

  /**
   * Closes the modal.
   */
  closeModal(): void;
}

/**
 *
 */
export interface SandboxAPI {
  render(connection: RemoteConnection, api: RenderAPI): Promise<unknown>;
  renderLegacy(channel: RemoteChannel, api: RenderAPI): Promise<unknown>;
}

// These property and method types will be used by both the host and remote environments.
// They will be used to describe the properties that are available on the elements that can
// be synchronized between the two environments.

/**
 * A `Text` element renders a styled string of text.
 */
export interface TextProperties {
  /**
   * Whether the text should be emphasized.
   */
  emphasis?: boolean;
}

/**
 * A `Button` element renders a styled button that can be pressed by the user.
 */
export interface ButtonProperties {
  /**
   * A callback to run when the button is pressed. In the DOM environment created by
   * Remote DOM, this property can be set using `addEventListener('press')`.
   */
  onPress?(): void;
}

/**
 * A `Modal` element renders a dialog that interrupts the user’s workflow, and
 * must be dismissed.
 */
export interface ModalProperties {
  /**
   * A callback to run when the modal is closed. In the DOM environment created by
   * Remote DOM, this property can be set using `addEventListener('press')`.
   */
  onClose?(): void;
}

export interface ModalMethods {
  /**
   * Opens the modal.
   */
  open(): void;

  /**
   * Closes the modal.
   */
  close(): void;
}

/**
 * A `Stack` element renders children along the block axis, with optional spacing.
 */
export interface StackProperties {
  /**
   * Whether children should have space between them.
   */
  spacing?: boolean;
}



================================================
FILE: examples/kitchen-sink/app/vite-env.d.ts
================================================
/// <reference types="vite/client" />



================================================
FILE: examples/kitchen-sink/app/host/components.tsx
================================================
import {type ComponentChildren} from 'preact';
import {forwardRef} from 'preact/compat';
import {useRef, useImperativeHandle} from 'preact/hooks';
import type {Signal} from '@preact/signals';

import type {
  ButtonProperties,
  StackProperties,
  TextProperties,
  ModalMethods,
  ModalProperties,
  RenderSandbox,
  RenderExample,
} from '../types.ts';

export function Text({
  emphasis,
  children,
}: {children?: ComponentChildren} & TextProperties) {
  return (
    <span
      class={['Text', emphasis && 'Text--emphasis'].filter(Boolean).join(' ')}
    >
      {children}
    </span>
  );
}

export function Button({
  onPress,
  modal,
  children,
}: {
  children?: ComponentChildren;
  modal?: ComponentChildren;
} & ButtonProperties) {
  return (
    <>
      <button
        class="Button"
        type="button"
        onClick={() =>
          onPress?.() ?? document.querySelector('dialog')?.showModal()
        }
      >
        {children}
      </button>
      {modal}
    </>
  );
}

export function Stack({
  spacing,
  children,
}: {children?: ComponentChildren} & StackProperties) {
  return (
    <div
      class={['Stack', spacing && 'Stack--spacing'].filter(Boolean).join(' ')}
    >
      {children}
    </div>
  );
}

export const Modal = forwardRef<
  ModalMethods,
  {
    children?: ComponentChildren;
    primaryAction?: ComponentChildren;
  } & ModalProperties
>(function Modal({children, primaryAction, onClose}, ref) {
  const dialogRef = useRef<HTMLDialogElement>(null);

  useImperativeHandle(ref, () => ({
    open() {
      dialogRef.current?.showModal();
    },
    close() {
      dialogRef.current?.close();
    },
  }));

  return (
    <dialog ref={dialogRef} class="Modal" onClose={() => onClose?.()}>
      <div class="Modal-Content">{children}</div>
      {primaryAction && <div class="Modal-Actions">{primaryAction}</div>}
    </dialog>
  );
});

function Select({
  id: explicitID,
  label,
  labelVisibility,
  value,
  children,
}: {
  id?: string;
  label: string;
  labelVisibility?: 'visible' | 'hidden';
  value: Signal<string>;
} & {
  children: ComponentChildren;
}) {
  const id = useID(explicitID);

  return (
    <div class="Select">
      <label
        class={[
          'Label',
          labelVisibility === 'hidden' && 'Label--visually-hidden',
        ]
          .filter(Boolean)
          .join(' ')}
        for={id}
      >
        {label}
      </label>
      <select
        id={id}
        class="Select-Input"
        value={value.value}
        onChange={({currentTarget}) => {
          value.value = currentTarget.value;
        }}
      >
        {children}
      </select>
    </div>
  );
}

export function ControlPanel({
  sandbox,
  example,
}: {
  sandbox: Signal<RenderSandbox>;
  example: Signal<RenderExample>;
}) {
  return (
    <div class="ControlPanel">
      <section class="ControlPanel-Section">
        <h2 class="ControlPanel-SectionHeading">Example</h2>
        <p class="ControlPanel-SectionDescription">
          Which example should we render in the sandbox? You can read the source
          code for the example in <ExampleCodeReference example={example} />
        </p>
        <Select
          id="ControlPanelExample"
          value={example}
          label="Example"
          labelVisibility="hidden"
        >
          <option value="vanilla">“Vanilla” DOM</option>
          <option value="preact">Preact</option>
          <option value="react">React</option>
          <option value="svelte">Svelte</option>
          <option value="vue">Vue</option>
          <option value="htm">htm</option>
          <option value="react-remote-ui">React Remote UI</option>
        </Select>
      </section>

      <section class="ControlPanel-Section">
        <h2 class="ControlPanel-SectionHeading">Sandbox</h2>
        <p class="ControlPanel-SectionDescription">
          What browser technology should we use to sandbox the example? Remote
          DOM supports being sandboxed in <code>&lt;iframe&gt;</code>s and{' '}
          <a
            class="Link"
            href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API"
          >
            Web Workers
          </a>
        </p>
        <Select
          id="ControlPanelSandbox"
          value={sandbox}
          label="Sandbox"
          labelVisibility="hidden"
        >
          <option value="worker">Web Worker</option>
          <option value="iframe">iFrame</option>
        </Select>
      </section>
    </div>
  );
}

const EXAMPLE_FILE_NAMES = new Map<RenderExample, string>([
  ['vanilla', 'vanilla.ts'],
  ['htm', 'htm.ts'],
  ['preact', 'preact.tsx'],
  ['react', 'react.tsx'],
  ['svelte', 'App.svelte'],
  ['vue', 'App.vue'],
]);

function ExampleCodeReference({example}: {example: Signal<RenderExample>}) {
  const value = example.value;

  return <code>app/remote/examples/{EXAMPLE_FILE_NAMES.get(value)}</code>;
}

// Helpers

function useID(id?: string) {
  const ref = useRef<string>();

  if (id) {
    ref.current = id;
    return id;
  }

  return (ref.current ??= nanoId());
}

// @see https://github.com/ai/nanoid/blob/main/non-secure/index.js

function nanoId(size = 21) {
  // This alphabet uses `A-Za-z0-9_-` symbols. The genetic algorithm helped
  // optimize the gzip compression for this alphabet.
  const urlAlphabet =
    'ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW';

  let id = '';
  // A compact alternative for `for (var i = 0; i < step; i++)`.
  let i = size;
  while (i--) {
    // `| 0` is more compact and faster than `Math.floor()`.
    id += urlAlphabet[(Math.random() * 64) | 0];
  }
  return id;
}



================================================
FILE: examples/kitchen-sink/app/host/state.ts
================================================
import {signal, effect} from '@preact/signals';
import {SignalRemoteReceiver} from '@remote-dom/preact/host';

import type {RenderExample, RenderSandbox} from '../types.ts';

const DEFAULT_SANDBOX = 'worker';
const ALLOWED_SANDBOX_VALUES = new Set<RenderSandbox>(['iframe', 'worker']);

const DEFAULT_EXAMPLE = 'vanilla';
const ALLOWED_EXAMPLE_VALUES = new Set<RenderExample>([
  'vanilla',
  'htm',
  'preact',
  'react',
  'svelte',
  'vue',
]);

export function createState(
  render: (details: {
    example: RenderExample;
    sandbox: RenderSandbox;
    receiver: SignalRemoteReceiver;
  }) => void | Promise<void>,
) {
  const initialURL = new URL(window.location.href);

  const sandboxQueryParam = initialURL.searchParams
    .get('sandbox')
    ?.toLowerCase() as RenderSandbox | undefined;

  const sandbox = signal<RenderSandbox>(
    ALLOWED_SANDBOX_VALUES.has(sandboxQueryParam!)
      ? sandboxQueryParam!
      : DEFAULT_SANDBOX,
  );

  const exampleQueryParam = initialURL.searchParams
    .get('example')
    ?.toLowerCase() as RenderExample | undefined;

  const example = signal<RenderExample>(
    ALLOWED_EXAMPLE_VALUES.has(exampleQueryParam!)
      ? exampleQueryParam!
      : DEFAULT_EXAMPLE,
  );

  const receiver = signal<
    SignalRemoteReceiver | Error | Promise<SignalRemoteReceiver> | undefined
  >(undefined);

  const exampleCache = new Map<
    string,
    SignalRemoteReceiver | Error | Promise<SignalRemoteReceiver>
  >();

  effect(() => {
    const sandboxValue = sandbox.value;
    const exampleValue = example.value;

    const key = `${sandboxValue}:${exampleValue}`;
    let cached = exampleCache.get(key);

    const newURL = new URL(window.location.href);

    if (sandboxValue === DEFAULT_SANDBOX && exampleValue === DEFAULT_EXAMPLE) {
      newURL.searchParams.delete('sandbox');
      newURL.searchParams.delete('example');
    } else {
      newURL.searchParams.set('sandbox', sandboxValue);
      newURL.searchParams.set('example', exampleValue);
    }

    window.history.replaceState({}, '', newURL.toString());

    if (cached == null) {
      const receiver = new SignalRemoteReceiver();
      cached = Promise.resolve(
        render({
          receiver,
          sandbox: sandboxValue,
          example: exampleValue,
        }),
      )
        .then(() => {
          updateValueAfterRender(receiver);
          return receiver;
        })
        .catch((error) => {
          updateValueAfterRender(error);
          return Promise.reject(error);
        });

      exampleCache.set(key, cached);
    }

    receiver.value = cached;

    function updateValueAfterRender(value: SignalRemoteReceiver | Error) {
      exampleCache.set(key, value);

      if (sandboxValue !== sandbox.peek() || exampleValue !== example.peek()) {
        return value;
      }

      receiver.value = value;

      return value;
    }
  });

  return {receiver, sandbox, example};
}



================================================
FILE: examples/kitchen-sink/app/remote/elements.ts
================================================
import {
  createRemoteElement,
  RemoteRootElement,
  RemoteFragmentElement,
  type RemoteEvent,
} from '@remote-dom/core/elements';

import type {
  TextProperties,
  ButtonProperties,
  ModalProperties,
  ModalMethods,
  StackProperties,
} from '../types.ts';

// In this file we will define the custom elements that can be rendered in the
// remote environment. Note that none of these elements have any real implementation —
// they just act as placeholders that will be communicated to the host environment.
// The host environment contains the actual implementation of these elements (in this case,
// they have been implemented using Preact, in the `host/components.tsx` file).

export const Text = createRemoteElement<TextProperties>({
  properties: {
    emphasis: {type: Boolean},
  },
});

export const Button = createRemoteElement<
  ButtonProperties,
  {},
  {modal?: true},
  {press(event: RemoteEvent): void}
>({
  events: ['press'],
  slots: ['modal'],
});

export const Modal = createRemoteElement<
  ModalProperties,
  ModalMethods,
  {primaryAction?: true},
  {open(event: RemoteEvent): void; close(event: RemoteEvent): void}
>({
  events: ['close'],
  slots: ['primaryAction'],
  methods: ['open', 'close'],
});

export const Stack = createRemoteElement<StackProperties>({
  properties: {
    spacing: {type: Boolean},
  },
});

customElements.define('ui-text', Text);
customElements.define('ui-button', Button);
customElements.define('ui-modal', Modal);
customElements.define('ui-stack', Stack);

declare global {
  interface HTMLElementTagNameMap {
    'ui-text': InstanceType<typeof Text>;
    'ui-button': InstanceType<typeof Button>;
    'ui-stack': InstanceType<typeof Stack>;
    'ui-modal': InstanceType<typeof Modal>;
  }
}

// We use the Remote DOM `RemoteRootElement` class as the `<remote-root>` element.
// This element provides a convenient `connect()` method that starts synchronizing
// its children over a `RemoteConnection`, which we will use in the worker sandbox.
customElements.define('remote-root', RemoteRootElement);

// We use the Remote DOM `RemoteFragmentElement` class as the `<remote-fragment>` element.
// This element is used by the Preact and React helper libraries, in order to allow
// React elements passed as props to be automatically converted into the `slot`-ted elements
// that the Remote DOM library expects.
customElements.define('remote-fragment', RemoteFragmentElement);

declare global {
  interface HTMLElementTagNameMap {
    'remote-root': InstanceType<typeof RemoteRootElement>;
    'remote-fragment': InstanceType<typeof RemoteFragmentElement>;
  }
}



================================================
FILE: examples/kitchen-sink/app/remote/render.ts
================================================
import {RemoteChannel} from '@remote-ui/core';
import type {RenderAPI} from '../types.ts';

// Defines the custom elements available to render in the remote environment.
import './elements.ts';

export async function render(root: Element, api: RenderAPI) {
  switch (api.example) {
    case 'vanilla': {
      const {renderUsingVanillaDOM} = await import('./examples/vanilla.ts');
      return renderUsingVanillaDOM(root, api);
    }
    case 'htm': {
      const {renderUsingHTM} = await import('./examples/htm.ts');
      return renderUsingHTM(root, api);
    }
    case 'preact': {
      const {renderUsingPreact} = await import('./examples/preact.tsx');
      return renderUsingPreact(root, api);
    }
    case 'react': {
      const {renderUsingReact} = await import('./examples/react.tsx');
      return renderUsingReact(root, api);
    }
    case 'svelte': {
      const {renderUsingSvelte} = await import('./examples/svelte.ts');
      return renderUsingSvelte(root, api);
    }
    case 'vue': {
      const {renderUsingVue} = await import('./examples/vue.ts');
      return renderUsingVue(root, api);
    }
  }
}

export async function renderLegacy(channel: RemoteChannel, api: RenderAPI) {
  const {renderUsingReactRemoteUI} = await import(
    './examples/react-remote-ui.tsx'
  );
  return renderUsingReactRemoteUI(channel, api);
}



================================================
FILE: examples/kitchen-sink/app/remote/examples/App.svelte
================================================
<script lang="ts">
  import type {Modal} from '../elements.ts';
  import type {RenderAPI} from '../../types.ts';

  export let api: RenderAPI;

  let count = 0;
  let modal: InstanceType<typeof Modal>;

  function handlePress() {
    count += 1;
  }

  function handleClose() {
    if (count > 0) {
      api.alert(`You clicked ${count} times!`);
    }

    count = 0;
  }

  function handlePrimaryAction() {
    modal.close();
  }
</script>

<ui-stack spacing>
  <ui-text>
    Rendering example: <ui-text emphasis>{api.example}</ui-text>
  </ui-text>
  <ui-text>
    Rendering in sandbox: <ui-text emphasis>{api.sandbox}</ui-text>
  </ui-text>

  <ui-button>
    Open modal

    <ui-modal slot="modal" bind:this={modal} on:close={handleClose}>
      <ui-text>Click count: <ui-text emphasis>{count}</ui-text></ui-text>
      <ui-button on:press={handlePress}>Click me!</ui-button>
      <ui-button slot="primaryAction" on:press={handlePrimaryAction}>
        Close
      </ui-button>
    </ui-modal>
  </ui-button>
</ui-stack>



================================================
FILE: examples/kitchen-sink/app/remote/examples/App.vue
================================================
<script lang="ts" setup>
import {ref} from 'vue';
import type {Modal} from '../elements.ts';
import type {RenderAPI} from '../../types.ts';

const {api} = defineProps<{api: RenderAPI}>();

const count = ref(0);
const modal = ref<InstanceType<typeof Modal>>();

function handlePress() {
  count.value += 1;
}

function handleClose() {
  if (count.value > 0) {
    api.alert(`You clicked ${count.value} times!`);
  }

  count.value = 0;
}

function handlePrimaryAction() {
  modal.value.close();
}
</script>

<template>
  <ui-stack spacing>
    <ui-text>
      Rendering example: <ui-text emphasis>{{ api.example }}</ui-text>
    </ui-text>
    <ui-text>
      Rendering in sandbox: <ui-text emphasis>{{ api.sandbox }}</ui-text>
    </ui-text>

    <ui-button>
      Open modal

      <ui-modal ref="modal" slot="modal" @close="handleClose">
        <ui-text>
          Click count: <ui-text emphasis>{{ count }}</ui-text>
        </ui-text>
        <ui-button @press="handlePress">Click me!</ui-button>
        <ui-button slot="primaryAction" @press="handlePrimaryAction">
          Close
        </ui-button>
      </ui-modal>
    </ui-button>
  </ui-stack>
</template>



================================================
FILE: examples/kitchen-sink/app/remote/examples/htm.ts
================================================
import {html} from '@remote-dom/core/html';

import type {RenderAPI} from '../../types.ts';
import type {Modal, Text} from '../elements.ts';

export function renderUsingHTM(root: Element, api: RenderAPI) {
  let count = 0;

  function handlePress() {
    updateCount(count + 1);
  }

  function handleClose() {
    if (count > 0) {
      api.alert(`You clicked ${count} times!`);
    }

    updateCount(0);
  }

  function updateCount(newCount: number) {
    count = newCount;
    countText.textContent = String(count);
  }

  function handlePrimaryAction() {
    modal.close();
  }

  const countText = html`
    <ui-text emphasis>${count}</ui-text>
  ` satisfies InstanceType<typeof Text>;

  const modal = html`
    <ui-modal slot="modal" onClose=${handleClose}>
      <ui-text>Click count: <ui-text emphasis>${countText}</ui-text></ui-text>
      <ui-button onPress=${handlePress}>Click me!</ui-button>
      <ui-button slot="primaryAction" onPress=${handlePrimaryAction}>
        Close
      </ui-button>
    </ui-modal>
  ` satisfies InstanceType<typeof Modal>;

  const stack = html`
    <ui-stack spacing>
      <ui-text>
        Rendering example: <ui-text emphasis>${api.example}</ui-text>
      </ui-text>
      <ui-text>
        Rendering in sandbox: <ui-text emphasis>${api.sandbox}</ui-text>
      </ui-text>

      <ui-button> Open modal ${modal} </ui-button>
    </ui-stack>
  ` satisfies HTMLElement;

  root.append(stack);
}



================================================
FILE: examples/kitchen-sink/app/remote/examples/preact.tsx
================================================
/** @jsxRuntime automatic */
/** @jsxImportSource preact */

import {render} from 'preact';
import {useRef} from 'preact/hooks';
import {useSignal} from '@preact/signals';
import {createRemoteComponent} from '@remote-dom/preact';

import type {RenderAPI} from '../../types.ts';
import {
  Text as TextElement,
  Button as ButtonElement,
  Stack as StackElement,
  Modal as ModalElement,
} from '../elements.ts';

const Text = createRemoteComponent('ui-text', TextElement);
const Button = createRemoteComponent('ui-button', ButtonElement, {
  eventProps: {
    onPress: {event: 'press'},
  },
});
const Stack = createRemoteComponent('ui-stack', StackElement);
const Modal = createRemoteComponent('ui-modal', ModalElement, {
  eventProps: {
    onOpen: {event: 'open'},
    onClose: {event: 'close'},
  },
});

export function renderUsingPreact(root: Element, api: RenderAPI) {
  render(<App api={api} />, root);
}

function App({api}: {api: RenderAPI}) {
  return (
    <Stack spacing>
      <Text>
        Rendering example: <Text emphasis>{api.example}</Text>
      </Text>
      <Text>
        Rendering in sandbox: <Text emphasis>{api.sandbox}</Text>
      </Text>
      <Button modal={<CountModal alert={api.alert} />}>Open modal</Button>
    </Stack>
  );
}

function CountModal({alert}: Pick<RenderAPI, 'alert'>) {
  const count = useSignal(0);
  const modalRef = useRef<InstanceType<typeof ModalElement>>(null);

  const primaryAction = (
    <Button onPress={() => modalRef.current?.close()}>Close</Button>
  );

  return (
    <Modal
      ref={modalRef}
      primaryAction={primaryAction}
      onClose={() => {
        if (count.peek() > 0) {
          alert(`You clicked ${count} times!`);
        }

        count.value = 0;
      }}
    >
      <Stack spacing>
        <Text>
          Click count: <Text emphasis>{count}</Text>
        </Text>
        <Button
          onPress={() => {
            count.value += 1;
          }}
        >
          Click me!
        </Button>
      </Stack>
    </Modal>
  );
}



================================================
FILE: examples/kitchen-sink/app/remote/examples/react-remote-ui.tsx
================================================
/** @jsxRuntime automatic */
/** @jsxImportSource react */
import {retain} from '@quilted/threads';

import {createRemoteReactComponent} from '@remote-ui/react';
import {
  ButtonProperties,
  ModalProperties,
  RenderAPI,
  StackProperties,
  TextProperties,
} from '../../types';
import {useState} from 'react';
import {createRoot, createRemoteRoot} from '@remote-ui/react';
import {RemoteChannel} from '@remote-ui/core';

const Button = createRemoteReactComponent<
  'Button',
  ButtonProperties & {modal?: React.ReactNode}
>('Button', {fragmentProps: ['modal']});

const Text = createRemoteReactComponent<'Text', TextProperties>('Text');
const Stack = createRemoteReactComponent<'Stack', StackProperties>('Stack');
const Modal = createRemoteReactComponent<
  'Modal',
  ModalProperties & {primaryAction?: React.ReactNode}
>('Modal', {fragmentProps: ['primaryAction']});

export function renderUsingReactRemoteUI(
  channel: RemoteChannel,
  api: RenderAPI,
) {
  retain(api);
  retain(channel);

  const remoteRoot = createRemoteRoot(channel, {
    components: ['Button', 'Text', 'Stack', 'Modal'],
  });

  createRoot(remoteRoot).render(<App api={api} />);
  remoteRoot.mount();
}

function App({api}: {api: RenderAPI}) {
  return (
    <Stack spacing>
      <Text>
        Rendering example: <Text emphasis>{api.example}</Text>
      </Text>
      <Text>
        Rendering in sandbox: <Text emphasis>{api.sandbox}</Text>
      </Text>
      <Button modal={<CountModal {...api} />}>Open modal</Button>
    </Stack>
  );
}

function CountModal({alert, closeModal}: RenderAPI) {
  const [count, setCount] = useState(0);

  const primaryAction = (
    <Button
      onPress={() => {
        closeModal();
      }}
    >
      Close
    </Button>
  );

  return (
    <Modal
      primaryAction={primaryAction}
      onClose={() => {
        if (count > 0) {
          alert(`You clicked ${count} times!`);
        }

        setCount(0);
      }}
    >
      <Stack spacing>
        <Text>
          Click count: <Text emphasis>{count}</Text>
        </Text>
        <Button
          onPress={() => {
            setCount((count) => count + 1);
          }}
        >
          Click me!
        </Button>
      </Stack>
    </Modal>
  );
}



================================================
FILE: examples/kitchen-sink/app/remote/examples/react.tsx
================================================
/** @jsxRuntime automatic */
/** @jsxImportSource react */

import {useState, useRef} from 'react';
import {createRoot} from 'react-dom/client';
import {createRemoteComponent} from '@remote-dom/react';

import type {RenderAPI} from '../../types.ts';
import {
  Text as TextElement,
  Button as ButtonElement,
  Stack as StackElement,
  Modal as ModalElement,
} from '../elements.ts';

const Text = createRemoteComponent('ui-text', TextElement);
const Button = createRemoteComponent('ui-button', ButtonElement, {
  eventProps: {
    onPress: {event: 'press'},
  },
});

const Stack = createRemoteComponent('ui-stack', StackElement);
const Modal = createRemoteComponent('ui-modal', ModalElement, {
  eventProps: {
    onOpen: {event: 'open'},
    onClose: {event: 'close'},
  },
});

export function renderUsingReact(root: Element, api: RenderAPI) {
  createRoot(root).render(<App api={api} />);
}

function App({api}: {api: RenderAPI}) {
  return (
    <Stack spacing>
      <Text>
        Rendering example: <Text emphasis>{api.example}</Text>
      </Text>
      <Text>
        Rendering in sandbox: <Text emphasis>{api.sandbox}</Text>
      </Text>
      <Button modal={<CountModal alert={api.alert} />}>Open modal</Button>
    </Stack>
  );
}

function CountModal({alert}: Pick<RenderAPI, 'alert'>) {
  const [count, setCount] = useState(0);
  const modalRef = useRef<InstanceType<typeof ModalElement>>(null);

  const primaryAction = (
    <Button onPress={() => modalRef.current?.close()}>Close</Button>
  );

  return (
    <Modal
      ref={modalRef}
      primaryAction={primaryAction}
      onClose={() => {
        if (count > 0) {
          alert(`You clicked ${count} times!`);
        }

        setCount(0);
      }}
    >
      <Stack spacing>
        <Text>
          Click count: <Text emphasis>{count}</Text>
        </Text>
        <Button
          onPress={() => {
            setCount((count) => count + 1);
          }}
        >
          Click me!
        </Button>
      </Stack>
    </Modal>
  );
}



================================================
FILE: examples/kitchen-sink/app/remote/examples/svelte.ts
================================================
import type {RenderAPI} from '../../types.ts';

// @ts-ignore Not bothering to set up proper Svelte type-checking
import App from './App.svelte';

export function renderUsingSvelte(root: Element, api: RenderAPI) {
  new App({target: root, props: {api}});
}



================================================
FILE: examples/kitchen-sink/app/remote/examples/vanilla.ts
================================================
import type {RenderAPI} from '../../types.ts';
import {Modal} from '../elements.ts';

export function renderUsingVanillaDOM(root: Element, api: RenderAPI) {
  let count = 0;

  function handlePress() {
    updateCount(count + 1);
  }

  function handleClose() {
    if (count > 0) {
      api.alert(`You clicked ${count} times!`);
    }

    updateCount(0);
  }

  function updateCount(newCount: number) {
    count = newCount;
    countText.textContent = String(count);
  }

  function handlePrimaryAction() {
    modal.close();
  }

  const countText = document.createElement('ui-text');
  countText.textContent = String(count);
  countText.setAttribute('emphasis', '');

  const template = document.createElement('div');

  template.innerHTML = `
    <ui-modal slot="modal">
      <ui-text>Click count: </ui-text>
      <ui-button>Click me!</ui-button>
      <ui-button slot="primaryAction">
        Close
      </ui-button>
    </ui-modal>
  `.trim();

  const modal = template.querySelector('ui-modal')! as InstanceType<
    typeof Modal
  >;

  modal.addEventListener('close', handleClose);

  modal.querySelector('ui-text')!.append(countText);

  const [countButton, primaryActionButton] = [
    ...modal.querySelectorAll('ui-button'),
  ];

  countButton!.addEventListener('press', handlePress);
  primaryActionButton!.addEventListener('press', handlePrimaryAction);

  template.innerHTML = `
    <ui-stack spacing>
      <ui-text>
        Rendering example: <ui-text emphasis></ui-text>
      </ui-text>
      <ui-text>
        Rendering in sandbox: <ui-text emphasis></ui-text>
      </ui-text>

      <ui-button>Open modal</ui-button>
    </ui-stack>
  `.trim();

  const stack = template.firstElementChild!;

  const [exampleText, sandboxText] = [
    ...stack.querySelectorAll('ui-text[emphasis]')!,
  ];
  exampleText!.textContent = api.example;
  sandboxText!.textContent = api.sandbox;

  stack.querySelector('ui-button')!.append(modal);

  root.append(stack);
}



================================================
FILE: examples/kitchen-sink/app/remote/examples/vue.ts
================================================
import {createApp} from 'vue';
import type {RenderAPI} from '../../types.ts';

// @ts-ignore Not bothering to set up proper Vue type-checking
import App from './App.vue';

export function renderUsingVue(root: Element, api: RenderAPI) {
  createApp(App, {api}).mount(root);
}



================================================
FILE: examples/kitchen-sink/app/remote/iframe/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Kitchen sink (remote) • Remote DOM</title>
  </head>
  <body>
    <!--
      This JavaScript will generate UI and communicate it to the host,
      which in this case is the parent window.
    -->
    <script type="module" src="./sandbox.ts" crossorigin="anonymous"></script>
  </body>
</html>



================================================
FILE: examples/kitchen-sink/app/remote/iframe/sandbox.ts
================================================
import {RemoteMutationObserver} from '@remote-dom/core/elements';
import {ThreadNestedIframe} from '@quilted/threads';

import '../elements.ts';
import {render, renderLegacy} from '../render.ts';
import type {SandboxAPI} from '../../types.ts';

// We use the `@quilted/threads` library to create a “thread” for our iframe,
// which lets us communicate over `postMessage` without having to worry about
// most of its complexities.
//
// This block exposes the `render` method that was used by the host application,
// in `index.html`. We receive the `RemoteConnection` object, and start synchronizing
// changes to the `<div id="root">` element that contains our UI.
new ThreadNestedIframe<never, SandboxAPI>({
  exports: {
    async render(connection, api) {
      // We will observe this DOM node, and send any elements within it to be
      // reflected on this "host" page.
      const root = document.createElement('div');
      root.id = `Example${api.example[0]!.toUpperCase()}${api.example.slice(
        1,
      )}${api.sandbox[0]!.toUpperCase()}${api.sandbox.slice(1)}`;

      document.body.append(root);

      // We use the `RemoteMutationObserver` class, which extends the native DOM
      // `MutationObserver`, to send any changes to a tree of DOM elements over
      // a `RemoteConnection`.
      const observer = new RemoteMutationObserver(connection);
      observer.observe(root);

      await render(root, api);
    },
    async renderLegacy(channel, api) {
      await renderLegacy(channel, api);
    },
  },
});



================================================
FILE: examples/kitchen-sink/app/remote/worker/sandbox.ts
================================================
import '@remote-dom/core/polyfill';
import '@remote-dom/react/polyfill';

import {ThreadWebWorker} from '@quilted/threads';

import '../elements.ts';
import {render, renderLegacy} from '../render.ts';
import type {SandboxAPI} from '../../types.ts';

// We use the `@quilted/threads` library to create a “thread” for our iframe,
// which lets us communicate over `postMessage` without having to worry about
// most of its complexities.
//
// This block exposes the `render` method that was used by the host application,
// in `index.html`. We receive the `RemoteConnection` object, and start synchronizing
// changes to a `<remote-root>` element that contains our UI.
new ThreadWebWorker<never, SandboxAPI>(self as any as Worker, {
  exports: {
    async render(connection, api) {
      // We will observe this DOM node, and send any elements within it to be
      // reflected on this "host" page. This element is defined by the Remote DOM
      // library, and provides a convenient `connect()` method that starts
      // synchronizing its children over a `RemoteConnection`.
      const root = document.createElement('remote-root');
      root.connect(connection);
      document.body.append(root);

      await render(root, api);
    },
    async renderLegacy(channel, api) {
      await renderLegacy(channel, api);
    },
  },
});



================================================
FILE: packages/compat/README.md
================================================
# `@remote-dom/compat`

The `@remote-dom/compat` package provides helpers for adapting between Remote DOM and [`remote-ui`, the previous version of this project](https://github.com/Shopify/remote-dom/discussions/267). These utilities are offered to help you transition to Remote DOM, while continuing to support existing code that expects `remote-ui`-style APIs.

## Progressive migration from `remote-ui`’s `RemoteChannel` to Remote DOM’s `RemoteConnection`

The `RemoteChannel` and `RemoteConnection` types from `remote-ui` and Remote DOM serve the same purpose: they describe the minimal interface that a remote environment needs to communicate with a host. In Remote DOM, the `RemoteConnection` type has been enhanced in backwards-incompatible ways, in order to support [method calling](#remote-methods), batched updates, and more.

In `remote-ui`, you typically get a `RemoteChannel` function by accessing the `receiver` property on a `RemoteReceiver`, like this:

```ts
import {createRemoteReceiver} from '@remote-ui/core';

const receiver = createRemoteReceiver();
const channel = receiver.receive;

// Do something with the channel, typically by sending it to a remote environment:
sendChannelToRemoteEnvironment(channel);
```

You can migrate to use a Remote DOM [`RemoteReceiver`](#remotereceiver), [`DOMRemoteReceiver`](#domremotereceiver), or [`SignalRemoteReceiver`](/packages/signals/README.md#signalremotereceiver) class, while still supporting the `RemoteChannel` API, by using the `adaptToLegacyRemoteChannel()` function:

You can adapt a `RemoteConnection` to a `RemoteChannel` using this library’s `adaptToLegacyRemoteChannel()` function. This function takes a `RemoteConnection` and returns a `RemoteChannel`, which allows you to use a Remote DOM receiver class on the host, even if the remote environment is using `remote-ui`. This same technique works regardless of whether you are using the [`RemoteReceiver`](#remotereceiver), [`DOMRemoteReceiver`](#domremotereceiver), or [`SignalRemoteReceiver`](/packages/signals/README.md#signalremotereceiver) class.

```ts
import {DOMRemoteReceiver} from '@remote-dom/core/receivers';
import {adaptToLegacyRemoteChannel} from '@remote-dom/compat';

const receiver = new DOMRemoteReceiver();
const channel = adaptToLegacyRemoteChannel(receiver.connection);

// Same as before: do something with the channel
sendChannelToRemoteEnvironment(channel);
```

If you use `remote-ui`’s React bindings to render your UI on the host, you will also need to update that code to make use of the new Remote DOM versions of those bindings (available for [Preact](/packages/preact/README.md#host) and [React](/packages/react/README.md#host)). With this change made, though, you can now seamlessly support code written with `remote-ui` or Remote DOM, by using the more powerful Remote DOM receiver classes on the host and adapting them for legacy code.



================================================
FILE: packages/compat/CHANGELOG.md
================================================
# @remote-dom/compat

## 1.0.2

### Patch Changes

- [#547](https://github.com/Shopify/remote-dom/pull/547) [`ca6a668`](https://github.com/Shopify/remote-dom/commit/ca6a66893f02eb4e7881a7117de5a461c7ae3708) Thanks [@igor10k](https://github.com/igor10k)! - Handle reordering in adapter

- [#545](https://github.com/Shopify/remote-dom/pull/545) [`fe94f9b`](https://github.com/Shopify/remote-dom/commit/fe94f9b6e7087e1146fa2301b3d339c760c9d9a9) Thanks [@igor10k](https://github.com/igor10k)! - Handle fragments in adapter

## 1.0.1

### Patch Changes

- [#536](https://github.com/Shopify/remote-dom/pull/536) [`9abf5be`](https://github.com/Shopify/remote-dom/commit/9abf5bee323dfa522f9061ba61ce2f433a36cb4e) Thanks [@igor10k](https://github.com/igor10k)! - Use the same core dependency version for all packages

## 1.0.0

### Major Changes

- [#511](https://github.com/Shopify/remote-dom/pull/511) [`1a42bf6`](https://github.com/Shopify/remote-dom/commit/1a42bf6d72a1dcfe5403c097dfd406b116a3455b) Thanks [@robin-drexler](https://github.com/robin-drexler)! - Add a `adaptToLegacyRemoteChannel` helper that adapts a Remote DOM `RemoteConnection` object into a `remote-ui` `RemoteChannel`.

  It allows to use a Remote DOM receiver class on the host, even if the remote environment is using `remote-ui`.

### Patch Changes

- Updated dependencies [[`8cbf2c2`](https://github.com/Shopify/remote-dom/commit/8cbf2c2a6130dd0a19088a2adf18b506f468be8b)]:
  - @remote-dom/core@1.6.0



================================================
FILE: packages/compat/package.json
================================================
{
  "name": "@remote-dom/compat",
  "type": "module",
  "license": "MIT",
  "publishConfig": {
    "access": "public",
    "@remote-dom/registry": "https://registry.npmjs.org"
  },
  "version": "1.0.2",
  "engines": {
    "node": ">=14.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/Shopify/remote-dom",
    "directory": "packages/compat"
  },
  "exports": {
    ".": {
      "types": "./build/typescript/index.d.ts",
      "quilt:source": "./source/index.ts",
      "quilt:esnext": "./build/esnext/index.esnext",
      "import": "./build/esm/index.mjs",
      "require": "./build/cjs/index.cjs"
    }
  },
  "types": "./build/typescript/index.d.ts",
  "scripts": {
    "build": "rollup --config ./rollup.config.js"
  },
  "dependencies": {
    "@remote-dom/core": "workspace:^1.7.0",
    "@remote-ui/core": "^2.0.0"
  },
  "browserslist": [
    "defaults and not dead"
  ]
}



================================================
FILE: packages/compat/rollup.config.js
================================================
import {quiltPackage} from '@quilted/rollup/package';

export default quiltPackage({commonjs: true});



================================================
FILE: packages/compat/tsconfig.json
================================================
{
  "extends": "@quilted/typescript/tsconfig.package.json",
  "references": [{"path": "../core"}]
}



================================================
FILE: packages/compat/vite.config.js
================================================
import {defineConfig} from 'vite';
import {quiltPackage} from '@quilted/vite';

export default defineConfig({
  plugins: [quiltPackage()],

  resolve: {
    // Alias the `@remote-dom` packages to their source files
    conditions: ['quilt:source'],
  },
});



================================================
FILE: packages/compat/source/index.ts
================================================
export {adaptToLegacyRemoteChannel} from './adapter/host';



================================================
FILE: packages/compat/source/adapter/host.ts
================================================
import {
  KIND_TEXT as LEGACY_KIND_TEXT,
  KIND_COMPONENT as LEGACY_KIND_COMPONENT,
  KIND_FRAGMENT as LEGACY_KIND_FRAGMENT,
  ACTION_MOUNT as LEGACY_ACTION_MOUNT,
  ACTION_INSERT_CHILD as LEGACY_ACTION_INSERT_CHILD,
  ACTION_REMOVE_CHILD as LEGACY_ACTION_REMOVE_CHILD,
  ACTION_UPDATE_PROPS as LEGACY_ACTION_UPDATE_PROPS,
  ACTION_UPDATE_TEXT as LEGACY_ACTION_UPDATE_TEXT,
  type RemoteChannel as LegacyRemoteChannel,
  type ActionArgumentMap as LegacyActionArgumentMap,
  type RemoteComponentSerialization as LegacyRemoteComponentSerialization,
  type RemoteTextSerialization as LegacyRemoteTextSerialization,
  type RemoteFragmentSerialization as LegacyRemoteFragmentSerialization,
} from '@remote-ui/core';

import {
  ROOT_ID,
  NODE_TYPE_TEXT,
  NODE_TYPE_COMMENT,
  NODE_TYPE_ELEMENT,
  MUTATION_TYPE_INSERT_CHILD,
  MUTATION_TYPE_REMOVE_CHILD,
  MUTATION_TYPE_UPDATE_PROPERTY,
  MUTATION_TYPE_UPDATE_TEXT,
  type RemoteMutationRecord,
  type RemoteTextSerialization,
  type RemoteElementSerialization,
  type RemoteConnection,
  type RemoteNodeSerialization,
  type RemoteCommentSerialization,
} from '@remote-dom/core';

export interface LegacyRemoteChannelElementMap {
  [key: string]: string;
}

export interface LegacyRemoteChannelOptions {
  /**
   * A map of element types to their corresponding remote-ui element types.
   */
  elements?: LegacyRemoteChannelElementMap;

  slotProps?: {
    /**
     * The element type to use for slots.
     */
    wrapper?: string;
  };
}

/**
 * Adapts a Remote DOM `RemoteConnection` object into a `remote-ui` `RemoteChannel`.
 * This allows you to use a Remote DOM receiver class on the host, even if the remote
 * environment is using `remote-ui`.
 *
 * @example
 * ```tsx
 * import {DOMRemoteReceiver} from '@remote-dom/core/receivers';
 * import {adaptToLegacyRemoteChannel} from '@remote-dom/compat';
 *
 * const receiver = new DOMRemoteReceiver();
 * const channel = adaptToLegacyRemoteChannel(receiver.connection);
 *
 * // Do something with the channel
 * sendChannelToRemoteEnvironment(channel);
 * ```
 */
export function adaptToLegacyRemoteChannel(
  connection: RemoteConnection,
  options?: LegacyRemoteChannelOptions,
): LegacyRemoteChannel {
  const tree = new Map<string, {id: string; slot?: string}[]>();

  function mutate(records: RemoteMutationRecord[]) {
    for (const record of records) {
      const [mutationType, parentId] = record;

      switch (mutationType) {
        case MUTATION_TYPE_INSERT_CHILD: {
          const node = record[2];
          const index = record[3];
          persistNode(parentId, node, index);
          break;
        }
        case MUTATION_TYPE_REMOVE_CHILD: {
          const index = record[2];
          removeNode(parentId, index);
          break;
        }
      }
    }

    connection.mutate(records);
  }

  function persistNode(
    parentId: string,
    node: RemoteNodeSerialization,
    index: number,
  ) {
    if (!tree.has(parentId)) {
      tree.set(parentId, []);
    }
    const parentNode = tree.get(parentId)!;
    parentNode.splice(index, 0, {
      id: node.id,
      slot: 'attributes' in node ? node.attributes?.slot : undefined,
    });

    if ('children' in node && node.children) {
      for (const [childIndex, child] of node.children.entries()) {
        persistNode(node.id, child, childIndex);
      }
    }
  }

  function removeNode(parentId: string, index: number) {
    const parentNode = tree.get(parentId);
    if (!parentNode?.[index]) return;

    const id = parentNode[index].id;
    parentNode.splice(index, 1);
    cleanupNode(id);
  }

  function cleanupNode(id: string) {
    const nodeChildren = tree.get(id);

    if (nodeChildren) {
      for (const child of nodeChildren) {
        cleanupNode(child.id);
      }

      tree.delete(id);
    }
  }

  return function remoteChannel<T extends keyof LegacyActionArgumentMap>(
    type: T,
    ...payload: LegacyActionArgumentMap[T]
  ) {
    switch (type) {
      case LEGACY_ACTION_MOUNT: {
        const [nodes] =
          payload as LegacyActionArgumentMap[typeof LEGACY_ACTION_MOUNT];

        const records = nodes.map(
          (node, index) =>
            [
              MUTATION_TYPE_INSERT_CHILD,
              ROOT_ID,
              adaptLegacyNodeSerialization(node, options),
              index,
            ] satisfies RemoteMutationRecord,
        );

        mutate(records);

        break;
      }

      case LEGACY_ACTION_INSERT_CHILD: {
        const [parentId = ROOT_ID, index, child] =
          payload as LegacyActionArgumentMap[typeof LEGACY_ACTION_INSERT_CHILD];

        const records = [];

        const parentNode = tree.get(parentId);

        if (parentNode) {
          const existingChildIndex = parentNode.findIndex(
            ({id}) => id === child.id,
          );

          if (existingChildIndex >= 0) {
            records.push([
              MUTATION_TYPE_REMOVE_CHILD,
              parentId,
              existingChildIndex,
            ] satisfies RemoteMutationRecord);
          }
        }

        records.push([
          MUTATION_TYPE_INSERT_CHILD,
          parentId,
          adaptLegacyNodeSerialization(child, options),
          index,
        ] satisfies RemoteMutationRecord);

        mutate(records);

        break;
      }

      case LEGACY_ACTION_REMOVE_CHILD: {
        const [parentID, removeIndex] =
          payload as LegacyActionArgumentMap[typeof LEGACY_ACTION_REMOVE_CHILD];

        mutate([
          [MUTATION_TYPE_REMOVE_CHILD, parentID ?? ROOT_ID, removeIndex],
        ]);

        break;
      }

      case LEGACY_ACTION_UPDATE_TEXT: {
        const [textId, text] =
          payload as LegacyActionArgumentMap[typeof LEGACY_ACTION_UPDATE_TEXT];

        mutate([[MUTATION_TYPE_UPDATE_TEXT, textId, text]]);

        break;
      }

      case LEGACY_ACTION_UPDATE_PROPS: {
        const [id, props] =
          payload as LegacyActionArgumentMap[typeof LEGACY_ACTION_UPDATE_PROPS];
        const parentNode = tree.get(id);

        const records = [];

        for (const [key, value] of Object.entries(props)) {
          const index = parentNode?.findIndex(({slot}) => slot === key) ?? -1;

          if (isFragment(value)) {
            if (index >= 0) {
              records.push([
                MUTATION_TYPE_REMOVE_CHILD,
                id,
                index,
              ] satisfies RemoteMutationRecord);
            }

            records.push([
              MUTATION_TYPE_INSERT_CHILD,
              id,
              adaptLegacyPropFragmentSerialization(key, value, options),
              tree.get(id)?.length ?? 0,
            ] satisfies RemoteMutationRecord);
          } else {
            if (index >= 0) {
              records.push([
                MUTATION_TYPE_REMOVE_CHILD,
                id,
                index,
              ] satisfies RemoteMutationRecord);
            } else {
              records.push([
                MUTATION_TYPE_UPDATE_PROPERTY,
                id,
                key,
                value,
              ] satisfies RemoteMutationRecord);
            }
          }
        }

        mutate(records);

        break;
      }

      default:
        throw new Error(`Unsupported action type: ${type}`);
    }
  };
}

function adaptLegacyNodeSerialization(
  child:
    | LegacyRemoteComponentSerialization
    | LegacyRemoteTextSerialization
    | LegacyRemoteFragmentSerialization,
  options?: LegacyRemoteChannelOptions,
):
  | RemoteElementSerialization
  | RemoteTextSerialization
  | RemoteCommentSerialization {
  switch (child.kind) {
    case LEGACY_KIND_TEXT:
      return adaptLegacyTextSerialization(child);
    case LEGACY_KIND_COMPONENT:
      return adaptLegacyComponentSerialization(child, options);
    default:
      return {
        id: child.id,
        type: NODE_TYPE_COMMENT,
        data: 'added by remote-ui legacy adaptor to replace a fragment rendered as a child',
      };
  }
}

function adaptLegacyTextSerialization({
  id,
  text,
}: LegacyRemoteTextSerialization): RemoteTextSerialization {
  return {
    id,
    type: NODE_TYPE_TEXT,
    data: text,
  };
}

function adaptLegacyComponentSerialization(
  {id, type, props, children}: LegacyRemoteComponentSerialization,
  options?: LegacyRemoteChannelOptions,
): RemoteElementSerialization {
  const element = options?.elements?.[type] ?? type;

  const [fragments, properties] = adaptFragmentsInProps(props);

  return {
    id,
    type: NODE_TYPE_ELEMENT,
    element,
    properties,
    children: [
      ...children.map((child) => {
        return adaptLegacyNodeSerialization(child, options);
      }),
      ...adaptLegacyFragmentsSerialization(fragments, options),
    ],
  };
}

function adaptFragmentsInProps(
  props: Record<string, unknown>,
): [
  fragments: Record<string, LegacyRemoteFragmentSerialization>,
  properties: Record<string, unknown>,
] {
  const fragments: Record<string, LegacyRemoteFragmentSerialization> = {};
  const properties: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(props)) {
    if (isFragment(value)) {
      fragments[key] = value;
    } else {
      properties[key] = value;
    }
  }

  return [fragments, properties];
}

function isFragment(prop: unknown): prop is LegacyRemoteFragmentSerialization {
  return (
    prop != null &&
    typeof prop === 'object' &&
    'kind' in prop &&
    prop.kind === LEGACY_KIND_FRAGMENT
  );
}

function adaptLegacyFragmentsSerialization(
  fragments: Record<string, LegacyRemoteFragmentSerialization>,
  options?: LegacyRemoteChannelOptions,
): RemoteElementSerialization[] {
  return Object.entries(fragments).map(([slot, fragment]) => {
    return adaptLegacyPropFragmentSerialization(slot, fragment, options);
  });
}

function adaptLegacyPropFragmentSerialization(
  slot: string,
  fragment: LegacyRemoteFragmentSerialization,
  options?: LegacyRemoteChannelOptions,
): RemoteElementSerialization {
  return {
    id: fragment.id,
    element: options?.slotProps?.wrapper ?? 'remote-fragment',
    attributes: {
      slot,
    },
    type: NODE_TYPE_ELEMENT,
    children: fragment.children.map((child) => {
      return adaptLegacyNodeSerialization(child, options);
    }),
  };
}



================================================
FILE: packages/compat/source/tests/adapter.test.ts
================================================
import '@remote-dom/core/polyfill';

import {describe, expect, it, vi, type Mocked} from 'vitest';

import {adaptToLegacyRemoteChannel} from '../adapter/host.ts';

import {
  ACTION_INSERT_CHILD,
  ACTION_MOUNT,
  ACTION_REMOVE_CHILD,
  ACTION_UPDATE_PROPS,
  ACTION_UPDATE_TEXT,
  KIND_COMPONENT,
  KIND_FRAGMENT,
  KIND_TEXT,
} from '@remote-ui/core';

import {
  MUTATION_TYPE_INSERT_CHILD,
  MUTATION_TYPE_REMOVE_CHILD,
  MUTATION_TYPE_UPDATE_PROPERTY,
  MUTATION_TYPE_UPDATE_TEXT,
  NODE_TYPE_ELEMENT,
  NODE_TYPE_TEXT,
  NODE_TYPE_COMMENT,
  ROOT_ID,
} from '@remote-dom/core';

import {RemoteReceiver} from '@remote-dom/core/receivers';

describe('adaptToLegacyRemoteChannel()', () => {
  describe('ACTION_MOUNT', () => {
    it('mounts text nodes', () => {
      const receiver = new TestRemoteReceiver();

      const channel = adaptToLegacyRemoteChannel(receiver.connection);

      channel(ACTION_MOUNT, [
        {
          id: '0',
          kind: KIND_TEXT,
          text: 'I am a text',
        },
      ]);

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [
          MUTATION_TYPE_INSERT_CHILD,
          ROOT_ID,
          {
            id: '0',
            type: NODE_TYPE_TEXT,
            data: 'I am a text',
          },
          0,
        ],
      ]);

      expect(receiver.root.children).toStrictEqual([
        {
          id: '0',
          type: NODE_TYPE_TEXT,
          data: 'I am a text',
          version: 0,
        },
      ]);
    });

    it('mounts component nodes', () => {
      const receiver = new TestRemoteReceiver();

      const channel = adaptToLegacyRemoteChannel(receiver.connection);

      channel(ACTION_MOUNT, [
        {
          id: '1',
          kind: KIND_COMPONENT,
          type: 'Banner',
          props: {title: 'Title'},
          children: [{id: '0', kind: KIND_TEXT, text: 'I am a banner'}],
        },
      ]);

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [
          MUTATION_TYPE_INSERT_CHILD,
          ROOT_ID,
          {
            id: '1',
            type: NODE_TYPE_ELEMENT,
            element: 'Banner',
            properties: {title: 'Title'},
            children: [
              {
                id: '0',
                type: NODE_TYPE_TEXT,
                data: 'I am a banner',
              },
            ],
          },
          0,
        ],
      ]);

      expect(receiver.root.children).toStrictEqual([
        {
          id: '1',
          type: NODE_TYPE_ELEMENT,
          element: 'Banner',
          children: [
            {id: '0', type: NODE_TYPE_TEXT, data: 'I am a banner', version: 0},
          ],
          properties: {title: 'Title'},
          attributes: {},
          eventListeners: {},
          version: 0,
        },
      ]);
    });

    it('replaces fragments with comment nodes', () => {
      const receiver = new TestRemoteReceiver();

      const channel = adaptToLegacyRemoteChannel(receiver.connection);

      channel(ACTION_MOUNT, [
        {
          id: '2',
          kind: KIND_FRAGMENT,
          children: [
            {
              id: '1',
              kind: KIND_TEXT,
              text: 'First text',
            },
            {
              id: '0',
              kind: KIND_TEXT,
              text: 'Second text',
            },
          ],
        } as any,
      ]);

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [
          MUTATION_TYPE_INSERT_CHILD,
          ROOT_ID,
          {
            id: '2',
            type: NODE_TYPE_COMMENT,
            data: 'added by remote-ui legacy adaptor to replace a fragment rendered as a child',
          },
          0,
        ],
      ]);

      expect(receiver.root.children).toStrictEqual([
        {
          id: '2',
          type: NODE_TYPE_COMMENT,
          data: 'added by remote-ui legacy adaptor to replace a fragment rendered as a child',
          version: 0,
        },
      ]);
    });

    it('mounts components replacing fragment children with comment nodes', () => {
      const receiver = new TestRemoteReceiver();

      const channel = adaptToLegacyRemoteChannel(receiver.connection);

      channel(ACTION_MOUNT, [
        {
          id: '4',
          kind: KIND_COMPONENT,
          type: 'Banner',
          props: {title: 'Title'},
          children: [
            {
              id: '3',
              kind: KIND_TEXT,
              text: 'Direct text child',
            },
            {
              id: '2',
              kind: KIND_FRAGMENT,
              children: [
                {
                  id: '1',
                  kind: KIND_TEXT,
                  text: 'Text in fragment',
                },
                {
                  id: '0',
                  kind: KIND_COMPONENT,
                  type: 'Button',
                  props: {},
                  children: [],
                },
              ],
            } as any,
          ],
        },
      ]);

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [
          MUTATION_TYPE_INSERT_CHILD,
          ROOT_ID,
          {
            id: '4',
            type: NODE_TYPE_ELEMENT,
            element: 'Banner',
            properties: {title: 'Title'},
            children: [
              {
                id: '3',
                type: NODE_TYPE_TEXT,
                data: 'Direct text child',
              },
              {
                id: '2',
                type: NODE_TYPE_COMMENT,
                data: 'added by remote-ui legacy adaptor to replace a fragment rendered as a child',
              },
            ],
          },
          0,
        ],
      ]);

      expect(receiver.root.children).toStrictEqual([
        {
          id: '4',
          type: NODE_TYPE_ELEMENT,
          element: 'Banner',
          children: [
            {
              id: '3',
              type: NODE_TYPE_TEXT,
              data: 'Direct text child',
              version: 0,
            },
            {
              id: '2',
              type: NODE_TYPE_COMMENT,
              data: 'added by remote-ui legacy adaptor to replace a fragment rendered as a child',
              version: 0,
            },
          ],
          properties: {title: 'Title'},
          attributes: {},
          eventListeners: {},
          version: 0,
        },
      ]);
    });

    it('mounts component nodes with fragment props', () => {
      const receiver = new TestRemoteReceiver();

      const channel = adaptToLegacyRemoteChannel(receiver.connection);

      channel(ACTION_MOUNT, [
        {
          id: '3',
          kind: KIND_COMPONENT,
          type: 'Banner',
          props: {
            title: {
              id: '2',
              kind: KIND_FRAGMENT,
              children: [
                {
                  id: '1',
                  kind: KIND_TEXT,
                  text: 'Title in a fragment',
                },
              ],
            },
          },
          children: [{id: '0', kind: KIND_TEXT, text: 'I am a banner'}],
        },
      ]);

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [
          MUTATION_TYPE_INSERT_CHILD,
          ROOT_ID,
          {
            id: '3',
            type: NODE_TYPE_ELEMENT,
            element: 'Banner',
            properties: {},
            children: [
              {
                id: '0',
                type: NODE_TYPE_TEXT,
                data: 'I am a banner',
              },
              {
                id: '2',
                type: NODE_TYPE_ELEMENT,
                element: 'remote-fragment',
                attributes: {slot: 'title'},
                children: [
                  {
                    id: '1',
                    type: NODE_TYPE_TEXT,
                    data: 'Title in a fragment',
                  },
                ],
              },
            ],
          },
          0,
        ],
      ]);

      expect(receiver.root.children).toStrictEqual([
        {
          id: '3',
          type: NODE_TYPE_ELEMENT,
          element: 'Banner',
          children: [
            {
              id: '0',
              type: NODE_TYPE_TEXT,
              data: 'I am a banner',
              version: 0,
            },
            {
              id: '2',
              type: NODE_TYPE_ELEMENT,
              element: 'remote-fragment',
              children: [
                {
                  id: '1',
                  type: NODE_TYPE_TEXT,
                  data: 'Title in a fragment',
                  version: 0,
                },
              ],
              properties: {},
              attributes: {
                slot: 'title',
              },
              eventListeners: {},
              version: 0,
            },
          ],
          properties: {},
          attributes: {},
          eventListeners: {},
          version: 0,
        },
      ]);
    });

    it('mounts component nodes with nested fragment props', () => {
      const receiver = new TestRemoteReceiver();

      const channel = adaptToLegacyRemoteChannel(receiver.connection);

      channel(ACTION_MOUNT, [
        {
          id: '5',
          kind: KIND_COMPONENT,
          type: 'Banner',
          props: {
            title: {
              id: '4',
              kind: KIND_FRAGMENT,
              children: [
                {
                  id: '3',
                  kind: KIND_COMPONENT,
                  type: 'Heading',
                  props: {
                    label: {
                      id: '2',
                      kind: KIND_FRAGMENT,
                      children: [
                        {
                          id: '1',
                          kind: KIND_TEXT,
                          text: 'Title in a nested fragment',
                        },
                      ],
                    },
                  },
                  children: [],
                },
              ],
            },
          },
          children: [{id: '0', kind: KIND_TEXT, text: 'I am a banner'}],
        },
      ]);

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [
          MUTATION_TYPE_INSERT_CHILD,
          ROOT_ID,
          {
            id: '5',
            type: NODE_TYPE_ELEMENT,
            element: 'Banner',
            children: [
              {
                id: '0',
                type: NODE_TYPE_TEXT,
                data: 'I am a banner',
              },
              {
                id: '4',
                type: NODE_TYPE_ELEMENT,
                element: 'remote-fragment',
                children: [
                  {
                    id: '3',
                    type: NODE_TYPE_ELEMENT,
                    element: 'Heading',
                    children: [
                      {
                        id: '2',
                        type: NODE_TYPE_ELEMENT,
                        element: 'remote-fragment',
                        children: [
                          {
                            id: '1',
                            type: NODE_TYPE_TEXT,
                            data: 'Title in a nested fragment',
                          },
                        ],
                        attributes: {
                          slot: 'label',
                        },
                      },
                    ],
                    properties: {},
                  },
                ],
                attributes: {
                  slot: 'title',
                },
              },
            ],
            properties: {},
          },
          0,
        ],
      ]);

      expect(receiver.root.children).toStrictEqual([
        {
          id: '5',
          type: NODE_TYPE_ELEMENT,
          element: 'Banner',
          children: [
            {
              id: '0',
              type: NODE_TYPE_TEXT,
              data: 'I am a banner',
              version: 0,
            },
            {
              id: '4',
              type: NODE_TYPE_ELEMENT,
              element: 'remote-fragment',
              children: [
                {
                  id: '3',
                  type: NODE_TYPE_ELEMENT,
                  element: 'Heading',
                  attributes: {},
                  children: [
                    {
                      id: '2',
                      type: NODE_TYPE_ELEMENT,
                      element: 'remote-fragment',
                      children: [
                        {
                          id: '1',
                          type: NODE_TYPE_TEXT,
                          data: 'Title in a nested fragment',
                          version: 0,
                        },
                      ],
                      properties: {},
                      attributes: {
                        slot: 'label',
                      },
                      eventListeners: {},
                      version: 0,
                    },
                  ],
                  eventListeners: {},
                  properties: {},
                  version: 0,
                },
              ],
              properties: {},
              attributes: {
                slot: 'title',
              },
              eventListeners: {},
              version: 0,
            },
          ],
          eventListeners: {},
          properties: {},
          attributes: {},
          version: 0,
        },
      ]);
    });
  });

  describe('ACTION_INSERT_CHILD', () => {
    it('inserts child', () => {
      const receiver = new TestRemoteReceiver();

      const channel = adaptToLegacyRemoteChannel(receiver.connection);

      channel(ACTION_MOUNT, [
        {
          id: '1',
          kind: KIND_COMPONENT,
          type: 'Banner',
          props: {title: 'Title'},
          children: [],
        },
      ]);

      channel(
        ACTION_INSERT_CHILD,
        '1',
        1,
        {
          id: '3',
          kind: KIND_COMPONENT,
          type: 'Button',
          props: {},
          children: [{id: '2', kind: KIND_TEXT, text: 'I am a button'}],
        },
        false,
      );

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [
          MUTATION_TYPE_INSERT_CHILD,
          '1',
          {
            id: '3',
            type: NODE_TYPE_ELEMENT,
            element: 'Button',
            properties: {},
            children: [{id: '2', type: NODE_TYPE_TEXT, data: 'I am a button'}],
          },
          1,
        ],
      ]);

      expect(receiver.root.children).toStrictEqual([
        {
          id: '1',
          type: NODE_TYPE_ELEMENT,
          element: 'Banner',
          children: [
            {
              id: '3',
              type: NODE_TYPE_ELEMENT,
              element: 'Button',
              children: [
                {
                  id: '2',
                  type: NODE_TYPE_TEXT,
                  data: 'I am a button',
                  version: 0,
                },
              ],
              properties: {},
              attributes: {},
              eventListeners: {},
              version: 0,
            },
          ],
          properties: {
            title: 'Title',
          },
          attributes: {},
          eventListeners: {},
          version: 1,
        },
      ]);
    });

    it('inserts a child with an id that already exists', () => {
      const receiver = new TestRemoteReceiver();
      const channel = adaptToLegacyRemoteChannel(receiver.connection);

      channel(ACTION_MOUNT, [
        {
          id: '1',
          kind: KIND_COMPONENT,
          type: 'Banner',
          props: {title: 'Title'},
          children: [
            {
              id: '2',
              kind: KIND_COMPONENT,
              type: 'Button',
              props: {},
              children: [],
            },
            {
              id: '3',
              kind: KIND_TEXT,
              text: 'I am a text',
            },
          ],
        },
      ]);

      channel(
        ACTION_INSERT_CHILD,
        '1',
        1,
        {
          id: '2',
          kind: KIND_COMPONENT,
          type: 'Button',
          props: {},
          children: [],
        },
        false,
      );

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [MUTATION_TYPE_REMOVE_CHILD, '1', 0],
        [
          MUTATION_TYPE_INSERT_CHILD,
          '1',
          {
            id: '2',
            type: NODE_TYPE_ELEMENT,
            element: 'Button',
            properties: {},
            children: [],
          },
          1,
        ],
      ]);

      expect(receiver.root.children).toStrictEqual([
        {
          id: '1',
          type: NODE_TYPE_ELEMENT,
          element: 'Banner',
          children: [
            {
              id: '3',
              type: NODE_TYPE_TEXT,
              data: 'I am a text',
              version: 0,
            },
            {
              id: '2',
              type: NODE_TYPE_ELEMENT,
              element: 'Button',
              children: [],
              properties: {},
              attributes: {},
              eventListeners: {},
              version: 0,
            },
          ],
          properties: {
            title: 'Title',
          },
          attributes: {},
          eventListeners: {},
          version: 2,
        },
      ]);
    });

    it('inserts child with fragment props', () => {
      const receiver = new TestRemoteReceiver();

      const channel = adaptToLegacyRemoteChannel(receiver.connection);

      channel(ACTION_MOUNT, [
        {
          id: '1',
          kind: KIND_COMPONENT,
          type: 'Banner',
          props: {title: 'Title'},
          children: [],
        },
      ]);

      channel(
        ACTION_INSERT_CHILD,
        '1',
        1,
        {
          id: '3',
          kind: KIND_COMPONENT,
          type: 'Banner',
          props: {
            title: {
              id: '2',
              kind: KIND_FRAGMENT,
              children: [
                {
                  id: '1',
                  kind: KIND_TEXT,
                  text: 'Title in a fragment',
                },
              ],
            },
          },
          children: [],
        },
        false,
      );

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [
          MUTATION_TYPE_INSERT_CHILD,
          '1',
          {
            id: '3',
            type: NODE_TYPE_ELEMENT,
            element: 'Banner',
            children: [
              {
                attributes: {
                  slot: 'title',
                },
                children: [
                  {
                    id: '1',
                    type: NODE_TYPE_TEXT,
                    data: 'Title in a fragment',
                  },
                ],
                id: '2',
                type: NODE_TYPE_ELEMENT,
                element: 'remote-fragment',
              },
            ],
            properties: {},
          },
          1,
        ],
      ]);

      expect(receiver.root.children).toStrictEqual([
        {
          id: '1',
          type: NODE_TYPE_ELEMENT,
          element: 'Banner',
          attributes: {},
          children: [
            {
              id: '3',
              type: NODE_TYPE_ELEMENT,
              element: 'Banner',
              children: [
                {
                  id: '2',
                  type: NODE_TYPE_ELEMENT,
                  element: 'remote-fragment',
                  children: [
                    {
                      id: '1',
                      type: NODE_TYPE_TEXT,
                      data: 'Title in a fragment',
                      version: 0,
                    },
                  ],
                  properties: {},
                  attributes: {
                    slot: 'title',
                  },
                  eventListeners: {},
                  version: 0,
                },
              ],
              properties: {},
              attributes: {},
              eventListeners: {},
              version: 0,
            },
          ],
          eventListeners: {},
          properties: {
            title: 'Title',
          },
          version: 1,
        },
      ]);
    });
  });

  describe('ACTION_REMOVE_CHILD', () => {
    it('removes child', () => {
      const receiver = new TestRemoteReceiver();

      const channel = adaptToLegacyRemoteChannel(receiver.connection);

      channel(ACTION_MOUNT, [
        {
          id: '2',
          kind: KIND_COMPONENT,
          type: 'Banner',
          props: {title: 'Title'},
          children: [
            {
              id: '1',
              kind: KIND_COMPONENT,
              type: 'Button',
              props: {},
              children: [{id: '0', kind: KIND_TEXT, text: 'I am a button'}],
            },
          ],
        },
      ]);

      channel(ACTION_REMOVE_CHILD, '2', 0);

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [MUTATION_TYPE_REMOVE_CHILD, '2', 0],
      ]);

      expect(receiver.root.children).toStrictEqual([
        {
          id: '2',
          type: NODE_TYPE_ELEMENT,
          element: 'Banner',
          children: [],
          properties: {title: 'Title'},
          attributes: {},
          eventListeners: {},
          version: 1,
        },
      ]);
    });

    it('removes child with fragment props', () => {
      const receiver = new TestRemoteReceiver();

      const channel = adaptToLegacyRemoteChannel(receiver.connection);

      channel(ACTION_MOUNT, [
        {
          id: '3',
          kind: KIND_COMPONENT,
          type: 'Banner',
          props: {
            title: {
              id: '2',
              kind: KIND_FRAGMENT,
              children: [
                {
                  id: '1',
                  kind: KIND_TEXT,
                  text: 'Title in a fragment',
                },
              ],
            },
          },
          children: [{id: '0', kind: KIND_TEXT, text: 'I am a banner'}],
        },
      ]);

      channel(ACTION_REMOVE_CHILD, '3', 1);

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [MUTATION_TYPE_REMOVE_CHILD, '3', 1],
      ]);

      expect(receiver.root.children).toStrictEqual([
        {
          id: '3',
          type: NODE_TYPE_ELEMENT,
          element: 'Banner',
          attributes: {},
          children: [
            {
              id: '0',
              type: NODE_TYPE_TEXT,
              data: 'I am a banner',
              version: 0,
            },
          ],
          properties: {},
          eventListeners: {},
          version: 1,
        },
      ]);
    });
  });

  describe('ACTION_UPDATE_TEXT', () => {
    it('updates text', () => {
      const receiver = new TestRemoteReceiver();

      const channel = adaptToLegacyRemoteChannel(receiver.connection);

      channel(ACTION_MOUNT, [
        {
          id: '1',
          kind: KIND_COMPONENT,
          type: 'Banner',
          props: {title: 'Title'},
          children: [{id: '0', kind: KIND_TEXT, text: 'I am a banner'}],
        },
      ]);

      channel(ACTION_UPDATE_TEXT, '0', 'I am an updated banner');

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [MUTATION_TYPE_UPDATE_TEXT, '0', 'I am an updated banner'],
      ]);

      expect(receiver.root.children).toStrictEqual([
        {
          id: '1',
          type: NODE_TYPE_ELEMENT,
          element: 'Banner',
          children: [
            {
              id: '0',
              type: NODE_TYPE_TEXT,
              data: 'I am an updated banner',
              version: 1,
            },
          ],
          properties: {title: 'Title'},
          attributes: {},
          eventListeners: {},
          version: 0,
        },
      ]);
    });
  });

  describe('ACTION_UPDATE_PROPS', () => {
    it('update props with regular props', () => {
      const receiver = new TestRemoteReceiver();

      const channel = adaptToLegacyRemoteChannel(receiver.connection);

      channel(ACTION_MOUNT, [
        {
          id: '1',
          kind: KIND_COMPONENT,
          type: 'Banner',
          props: {title: 'Title'},
          children: [],
        },
      ]);

      channel(ACTION_UPDATE_PROPS, '1', {
        title: 'New title',
      });

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [MUTATION_TYPE_UPDATE_PROPERTY, '1', 'title', 'New title'],
      ]);

      expect(receiver.root.children).toStrictEqual([
        {
          id: '1',
          type: NODE_TYPE_ELEMENT,
          element: 'Banner',
          children: [],
          properties: {title: 'New title'},
          attributes: {},
          eventListeners: {},
          version: 1,
        },
      ]);
    });

    it('update props with fragments', () => {
      const receiver = new TestRemoteReceiver();

      const channel = adaptToLegacyRemoteChannel(receiver.connection);

      channel(ACTION_MOUNT, [
        {
          id: '1',
          kind: KIND_COMPONENT,
          type: 'Banner',
          props: {title: 'Title'},
          children: [],
        },
      ]);

      channel(ACTION_UPDATE_PROPS, '1', {
        children: {
          kind: KIND_FRAGMENT,
          id: '2',
          children: [
            {
              kind: KIND_TEXT,
              id: '1',
              text: 'Fragment text',
            },
          ],
        },
      });

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [
          MUTATION_TYPE_INSERT_CHILD,
          '1',
          {
            id: '2',
            type: NODE_TYPE_ELEMENT,
            element: 'remote-fragment',
            attributes: {slot: 'children'},
            children: [
              {
                id: '1',
                type: NODE_TYPE_TEXT,
                data: 'Fragment text',
              },
            ],
          },
          0,
        ],
      ]);

      expect(receiver.root.children).toStrictEqual([
        {
          id: '1',
          type: NODE_TYPE_ELEMENT,
          element: 'Banner',
          children: [
            {
              id: '2',
              type: NODE_TYPE_ELEMENT,
              element: 'remote-fragment',
              children: [
                {
                  id: '1',
                  type: NODE_TYPE_TEXT,
                  data: 'Fragment text',
                  version: 0,
                },
              ],
              properties: {},
              attributes: {slot: 'children'},
              eventListeners: {},
              version: 0,
            },
          ],
          properties: {title: 'Title'},
          attributes: {},
          eventListeners: {},
          version: 1,
        },
      ]);
    });
  });

  describe('options', () => {
    it('uses custom element mappings when provided', () => {
      const receiver = new TestRemoteReceiver();

      const channel = adaptToLegacyRemoteChannel(receiver.connection, {
        elements: {
          Button: 'MappedButton',
        },
      });

      channel(ACTION_MOUNT, [
        {
          kind: KIND_COMPONENT,
          id: '1',
          type: 'Button',
          props: {},
          children: [],
        },
      ]);

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [
          MUTATION_TYPE_INSERT_CHILD,
          ROOT_ID,
          {
            id: '1',
            type: NODE_TYPE_ELEMENT,
            element: 'MappedButton',
            properties: {},
            children: [],
          },
          0,
        ],
      ]);
    });

    it('uses custom slot wrapper when provided', () => {
      const receiver = new TestRemoteReceiver();

      const channel = adaptToLegacyRemoteChannel(receiver.connection, {
        slotProps: {
          wrapper: 'custom-fragment',
        },
      });

      channel(ACTION_MOUNT, [
        {
          id: '1',
          kind: KIND_COMPONENT,
          type: 'Banner',
          props: {title: 'Title'},
          children: [],
        },
      ]);

      channel(ACTION_UPDATE_PROPS, '1', {
        title: {
          kind: KIND_FRAGMENT,
          id: '2',
          children: [
            {
              id: '1',
              kind: KIND_COMPONENT,
              type: 'Button',
              props: {},
              children: [{id: '0', kind: KIND_TEXT, text: 'I am a button'}],
            },
          ],
        },
      });

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [
          MUTATION_TYPE_INSERT_CHILD,
          '1',
          {
            id: '2',
            type: NODE_TYPE_ELEMENT,
            element: 'custom-fragment',
            attributes: {slot: 'title'},
            children: [
              {
                id: '1',
                type: NODE_TYPE_ELEMENT,
                element: 'Button',
                children: [
                  {
                    id: '0',
                    type: NODE_TYPE_TEXT,
                    data: 'I am a button',
                  },
                ],
                properties: {},
              },
            ],
          },
          0,
        ],
      ]);

      expect(receiver.root.children).toStrictEqual([
        {
          id: '1',
          type: NODE_TYPE_ELEMENT,
          element: 'Banner',
          children: [
            {
              id: '2',
              type: NODE_TYPE_ELEMENT,
              element: 'custom-fragment',
              children: [
                {
                  id: '1',
                  type: NODE_TYPE_ELEMENT,
                  element: 'Button',
                  children: [
                    {
                      id: '0',
                      type: NODE_TYPE_TEXT,
                      data: 'I am a button',
                      version: 0,
                    },
                  ],
                  eventListeners: {},
                  properties: {},
                  attributes: {},
                  version: 0,
                },
              ],
              properties: {},
              attributes: {
                slot: 'title',
              },
              eventListeners: {},
              version: 0,
            },
          ],
          eventListeners: {},
          properties: {
            title: 'Title',
          },
          attributes: {},
          version: 1,
        },
      ]);
    });
  });

  describe('persistNode()', () => {
    it('tracks node relationships', () => {
      const receiver = new TestRemoteReceiver();

      const channel = adaptToLegacyRemoteChannel(receiver.connection);

      channel(ACTION_MOUNT, [
        {
          id: '2',
          kind: KIND_COMPONENT,
          type: 'Container',
          props: {},
          children: [
            {
              id: '1',
              kind: KIND_TEXT,
              text: 'I am the first child',
            },
            {
              id: '0',
              kind: KIND_TEXT,
              text: 'I am the second child',
            },
          ],
        },
      ]);

      // Remove the first child
      channel(ACTION_REMOVE_CHILD, '2', 0);

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [MUTATION_TYPE_REMOVE_CHILD, '2', 0],
      ]);

      expect(receiver.root.children).toStrictEqual([
        {
          id: '2',
          type: NODE_TYPE_ELEMENT,
          element: 'Container',
          children: [
            {
              id: '0',
              type: NODE_TYPE_TEXT,
              data: 'I am the second child',
              version: 0,
            },
          ],
          properties: {},
          attributes: {},
          eventListeners: {},
          version: 1,
        },
      ]);

      // Remove the second child (which is now at index 0)
      channel(ACTION_REMOVE_CHILD, '2', 0);

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [MUTATION_TYPE_REMOVE_CHILD, '2', 0],
      ]);

      expect(receiver.root.children).toStrictEqual([
        {
          id: '2',
          type: NODE_TYPE_ELEMENT,
          element: 'Container',
          children: [],
          properties: {},
          attributes: {},
          eventListeners: {},
          version: 2,
        },
      ]);
    });

    it('maintains correct indices when inserting and removing nodes', () => {
      const receiver = new TestRemoteReceiver();

      const channel = adaptToLegacyRemoteChannel(receiver.connection);

      channel(ACTION_MOUNT, [
        {
          id: '2',
          kind: KIND_COMPONENT,
          type: 'Container',
          props: {},
          children: [
            {
              id: '1',
              kind: KIND_TEXT,
              text: 'I am the first child',
            },
            {
              id: '0',
              kind: KIND_TEXT,
              text: 'I am the second child',
            },
          ],
        },
      ]);

      // Insert a new node in the middle
      channel(
        ACTION_INSERT_CHILD,
        '2',
        1,
        {
          id: '3',
          kind: KIND_TEXT,
          text: 'I am the third child',
        },
        false,
      );

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [
          MUTATION_TYPE_INSERT_CHILD,
          '2',
          {
            id: '3',
            type: NODE_TYPE_TEXT,
            data: 'I am the third child',
          },
          1,
        ],
      ]);

      expect(receiver.root.children).toStrictEqual([
        {
          id: '2',
          type: NODE_TYPE_ELEMENT,
          element: 'Container',
          children: [
            {
              id: '1',
              type: NODE_TYPE_TEXT,
              data: 'I am the first child',
              version: 0,
            },
            {
              id: '3',
              type: NODE_TYPE_TEXT,
              data: 'I am the third child',
              version: 0,
            },
            {
              id: '0',
              type: NODE_TYPE_TEXT,
              data: 'I am the second child',
              version: 0,
            },
          ],
          properties: {},
          attributes: {},
          eventListeners: {},
          version: 1,
        },
      ]);

      // Remove the first node
      channel(ACTION_REMOVE_CHILD, '2', 0);

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [MUTATION_TYPE_REMOVE_CHILD, '2', 0],
      ]);

      expect(receiver.root.children).toStrictEqual([
        {
          id: '2',
          type: NODE_TYPE_ELEMENT,
          element: 'Container',
          children: [
            {
              id: '3',
              type: NODE_TYPE_TEXT,
              data: 'I am the third child',
              version: 0,
            },
            {
              id: '0',
              type: NODE_TYPE_TEXT,
              data: 'I am the second child',
              version: 0,
            },
          ],
          properties: {},
          attributes: {},
          eventListeners: {},
          version: 2,
        },
      ]);

      // Remove the new first node
      channel(ACTION_REMOVE_CHILD, '2', 0);

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [MUTATION_TYPE_REMOVE_CHILD, '2', 0],
      ]);

      expect(receiver.root.children).toStrictEqual([
        {
          id: '2',
          type: NODE_TYPE_ELEMENT,
          element: 'Container',
          children: [
            {
              id: '0',
              type: NODE_TYPE_TEXT,
              data: 'I am the second child',
              version: 0,
            },
          ],
          properties: {},
          attributes: {},
          eventListeners: {},
          version: 3,
        },
      ]);
    });
  });

  describe('cleanupNode()', () => {
    it('cleans up all children when removing a parent node', () => {
      const receiver = new TestRemoteReceiver();

      const channel = adaptToLegacyRemoteChannel(receiver.connection);

      channel(ACTION_MOUNT, [
        {
          id: '1',
          kind: KIND_COMPONENT,
          type: 'Banner',
          props: {title: 'Title'},
          children: [
            {
              id: '3',
              kind: KIND_COMPONENT,
              type: 'Button',
              props: {},
              children: [{id: '2', kind: KIND_TEXT, text: 'I am a button'}],
            },
          ],
        },
      ]);

      channel(ACTION_REMOVE_CHILD, ROOT_ID, 0);

      expect(receiver.connection.mutate).toHaveBeenCalledWith([
        [MUTATION_TYPE_REMOVE_CHILD, ROOT_ID, 0],
      ]);

      expect(receiver.root.children).toStrictEqual([]);
    });
  });
});

class TestRemoteReceiver
  implements
    Pick<
      RemoteReceiver,
      'root' | 'connection' | 'get' | 'implement' | 'subscribe'
    >
{
  readonly #receiver = new RemoteReceiver();
  readonly connection: RemoteReceiver['connection'] &
    Mocked<RemoteReceiver['connection']>;

  get root() {
    return this.#receiver.root;
  }

  constructor() {
    const {connection} = this.#receiver;
    this.connection = {
      mutate: vi.fn(connection.mutate),
      call: vi.fn(connection.call),
    };
  }

  get: RemoteReceiver['get'] = this.#receiver.get.bind(this.#receiver);
  implement = this.#receiver.implement.bind(this.#receiver);
  subscribe = this.#receiver.subscribe.bind(this.#receiver);
}



================================================
FILE: packages/core/README.md
================================================
# `@remote-dom/core`

A collection of DOM-based utilities for synchronizing elements between JavaScript environments.

## Installation

```sh
npm install @remote-dom/core --save # npm
pnpm install @remote-dom/core --save # pnpm
yarn add @remote-dom/core # yarn
```

## Usage

### `@remote-dom/core/elements`

The `@remote-dom/core/elements` package provides the classes and utility functions required to define “remote” elements. You’ll use these utilities in the sandboxed JavaScript environment that’s sending elements.

To import this entry, you must be in an environment with browser globals, including `HTMLElement` and `MutationObserver`. If you want to run your remote environment in a web worker, you can use the minimal DOM polyfill provided by [`@remote-dom/core/polyfill`](#remote-domcorepolyfill)

#### `RemoteElement`

The most important of these utilities is `RemoteElement`, which is a base class for defining elements in the remote environment. This class is a subclass of [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement), and adds the ability to declare how properties and methods are synchronized between the remote and host environments.

To define a remote element, the simplest approach is to subclass `RemoteElement`, and to use the `customElements` global to associate this element with a tag name:

```ts
import {RemoteElement} from '@remote-dom/core/elements';

class MyElement extends RemoteElement {}

customElements.define('my-element', MyElement);
```

##### Remote attributes

You can provide Remote DOM with a list of [attributes](https://developer.mozilla.org/en-US/docs/Glossary/Attribute) that will be synchronized between the remote and host environments. This can be done manually by calling the `updateRemoteAttribute()` method in a custom `RemoteElement` subclass:

```ts
import {RemoteElement} from '@remote-dom/core/elements';

class MyElement extends RemoteElement {
  static get observedAttributes() {
    return ['label'];
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (name === 'label') {
      this.updateRemoteAttribute('label', newValue);
    }
  }
}

customElements.define('my-element', MyElement);
```

Or, for convenience, by defining a static `remoteAttributes` getter:

```ts
import {RemoteElement} from '@remote-dom/core/elements';

class MyElement extends RemoteElement {
  static get remoteAttributes() {
    return ['label'];
  }
}

customElements.define('my-element', MyElement);
```

Now, when we create a `my-element` element and set its `label` attribute, the change will be communicated to the host environment.

```ts
const element = document.createElement('my-element');
element.setAttribute('label', 'Hello, world!');
```

##### Remote events

You can also provide Remote DOM with a list of [events](https://developer.mozilla.org/en-US/docs/Web/API/Event) that will be synchronized between the remote and host environments. You can register to listen for these events on the remote element using [`addEventListener`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener), and they will be registered as event listeners in the host representation of the element.

To define remote events, you can use the `remoteEvents` static getter:

```ts
import {RemoteElement} from '@remote-dom/core/elements';

class MyElement extends RemoteElement {
  static get remoteEvents() {
    return ['change'];
  }
}

customElements.define('my-element', MyElement);
```

Now, we can create a `my-element` element and add an event listener for the `change` event dispatched by the host:

```ts
const element = document.createElement('my-element');
element.addEventListener('change', () => console.log('Changed!'));
```

By default, a `RemoteEvent` object is dispatched to your remote event listeners. This object is a subclass of [`CustomEvent`](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent), and sets any argument sent from the host on the `detail` property. If you’d prefer a custom event object, you can instead use the object form of `remoteEvents` to set an event’s `dispatchEvent` option, which receives the argument from the host environment, and allows you to return a custom event that will be dispatched on the element:

```ts
import {RemoteElement} from '@remote-dom/core/elements';

class ChangeEvent extends CustomEvent {
  constructor(value) {
    super('change', {detail: value});
  }
}

class MyElement extends RemoteElement {
  static get remoteEvents() {
    return {
      change: {
        dispatchEvent(value) {
          // Before calling event listeners, update some properties on the element,
          // so they can be read in event listeners.
          Object.assign(this, {value});
          return new ChangeEvent(value);
        },
      },
    };
  }
}

customElements.define('my-element', MyElement);

const element = document.createElement('my-element');
element.addEventListener('change', (event) => {
  console.log('Changed!', element.value, element.value === event.detail);
});
```

Remote events do not bubble by default. As an extension of this behavior, the remote element will not even request that the host inform it of a particular non-bubbling event, unless an event listener for that event is specifically added to the element.

To listen for events in the host regardless of whether the remote element has an event listener, you can use the `bubbles` option when defining your remote event:

```ts
import {RemoteElement} from '@remote-dom/core/elements';

class MyElement extends RemoteElement {
  static get remoteEvents() {
    return {
      change: {
        bubbles: true,
      },
    };
  }
}

customElements.define('my-element', MyElement);

const parent = document.createElement('parent-element');
const element = document.createElement('my-element');
parent.append(element);

parent.addEventListener('change', (event) => {
  console.log('Nested element changed!', event.target, event.bubbles);
});
```

##### Remote properties

Remote DOM converts an allowlist of element instance properties into a dedicated object that can be communicated to the host environment. We refer to this object as an element’s “remote properties”, and it can be used to synchronize additional state that can’t be represented by attributes or event listeners.

You can manually set an element’s remote properties by using the `updateRemoteProperty()` method:

```ts
import {RemoteElement} from '@remote-dom/core/elements';

class MyElement extends RemoteElement {
  #label;

  get label() {
    return this.#label;
  }

  set label(value) {
    this.#label = value;
    this.updateRemoteProperty('label', value);
  }
}

customElements.define('my-element', MyElement);
```

Now, when we construct a `my-element` element and set its `label` property, the change will be communicated to the host environment.

```ts
const element = document.createElement('my-element');
element.label = 'Hello, world!';
```

Manually updating remote properties can get a little tedious. Additionally, it’s generally expected that properties can also be set as attributes, which makes it easier to construct elements using HTML. Remote DOM lets you create these attribute/ property pairs easily by indicating the name of your properties in the `remoteProperties` static getter:

```ts
import {RemoteElement} from '@remote-dom/core/elements';

class MyElement extends RemoteElement {
  static get remoteProperties() {
    return ['label'];
  }
}

customElements.define('my-element', MyElement);
```

Now, we can set the `label` property as an attribute or property, and in either case, the change will be communicated to the host environment:

```ts
const element = document.createElement('my-element');
element.setAttribute('label', 'Hello, world!');

// Or, you can use HTML to create the element and set its attribute
const template = document.createElement('template');
template.innerHTML = '<my-element label="Hello, world!"></my-element>';
```

Remote DOM allows you to define more complex remote properties that do not map to simple string attributes. Instead of setting `remoteProperties` to an array of property names, you can instead set it to an object that provides more details on how to coordinate the attribute, property, and remote property values:

```ts
import {RemoteElement} from '@remote-dom/core/elements';

class MyElement extends RemoteElement {
  static get remoteProperties() {
    return {
      label: {type: String},
      emphasized: {type: Boolean},
      onPress: {event: true},
    };
  }
}

customElements.define('my-element', MyElement);

const element = document.createElement('my-element');
element.setAttribute('label', 'Hello, world!');
element.emphasized = true;
element.addEventListener('press', () => console.log('Pressed!'));
```

Each property definition can have the following options:

**`type`: The type of the property.** This is used to convert the attribute value to the property value, and vice versa. You can pass any of the following values for this option:

- `String`: The default type. The property value is a string, and will be directly mirrored between attribute and property values.
- `Number`: Converts an attribute value to a number before assigning it to the property.
- `Boolean`: Converts an attribute value to a boolean before assigning it to the property. If the attribute is present, the property will be `true`; otherwise, it will be `false`.
- `Array` or `Object`: Processes an attribute with `JSON.parse()` before assigning it to the property.
- `Function`: Prevents the attribute from being assigned.
- An object with optional `parse()` and `serialize()` methods, which are used to convert the attribute value to the property value, and to serialize the property value to a remote property, respectively.

**`attribute`: whether this property maps to an attribute.** If `true`, which is the default, Remote DOM will set this property value from an attribute with the same name. The `type` option is used to determine how the attribute value is converted to the property value. You can choose an attribute name that differs from the property name by setting this option to a string, instead of `true`.

> **Note:** If you want to use the attribute as the “source of truth” for the property value, > you should use a [remote attribute](#remote-attributes) instead of a remote property.

**`event`: whether this property maps to an event listener.** If `true`, Remote DOM will set the property value to a function if any event listeners are set for the matching event name.

> **Note:** This feature is deprecated. You should use [`remoteEvents`](#remote-events) to define
> event listeners that will be synchronized with the host environment.

```ts
import {RemoteElement} from '@remote-dom/core/elements';

class MyElement extends RemoteElement {
  static get remoteProperties() {
    return {
      onPress: {event: true},
    };
  }
}

customElements.define('my-element', MyElement);

const element = document.createElement('my-element');

// Adding an event listener that maps to the `onPress` property:
element.addEventListener('press', () => console.log('Pressed!'));

// Alternatively, directly setting the remote property:
element.onPress = () => console.log('Pressed!');
```

The event name is the name of the property with the `on` prefix removed, and converted to kebab-case. For example, `onPressStart` would be mapped to a `press-start` event. Alternatively, you can set the `event` option to a string to explicitly set the event name:

```ts
import {RemoteElement} from '@remote-dom/core/elements';

class MyElement extends RemoteElement {
  static get remoteProperties() {
    return {
      onPressStart: {event: 'pressstart'},
    };
  }
}

customElements.define('my-element', MyElement);

const element = document.createElement('my-element');

element.addEventListener('pressstart', () => console.log('Pressed!'));
```

When a remote element uses event listeners to define remote properties, those event listeners will be called with a special `RemoteEvent` object. This object is like the normal `Event` object, but it has a few special properties:

- `detail`: set to the first argument passed by the caller of the remote property.
- `response`: set to the last value passed to the `respondWith()` method. After all event listeners have run, this value is returned to the caller of the remote property.
- `respondWith()`: Sets a value to be returned to the caller of the remote property.

```ts
import {RemoteElement} from '@remote-dom/core/elements';

class MyElement extends RemoteElement {
  static get remoteProperties() {
    return {
      onSave: {event: true},
    };
  }
}

customElements.define('my-element', MyElement);

const element = document.createElement('my-element');

element.addEventListener('save', (event) => {
  // Argument passed to the `onSave()` remote property
  console.log(event.detail);

  // Return a promise
  event.respondWith(
    (async () => {
      // Do something asynchronous
      await doSomething();

      // Return a value to the caller of the remote property
      return {success: true};
    })(),
  );
});
```

##### Remote methods

Remote DOM also lets you define methods in the host environment that can be called from the remote environment. You can call these methods using the `callRemoteMethod()` function:

```ts
import {RemoteElement} from '@remote-dom/core/elements';

class MyElement extends RemoteElement {
  focus() {
    return this.callRemoteMethod('focus');
  }
}

customElements.define('my-element', MyElement);

const element = document.createElement('my-element');
element.focus();
```

It’s common that a method in your `RemoteElement` subclass will just call through to a remote method with a matching name, like the `focus()` method above. In those cases, you can instead define a `remoteMethods` static getter to automatically create these methods:

```ts
import {RemoteElement} from '@remote-dom/core/elements';

class MyElement extends RemoteElement {
  static get remoteMethods() {
    return ['focus'];
  }
}

customElements.define('my-element', MyElement);

const element = document.createElement('my-element');
element.focus();
```

#### `createRemoteElement`

`createRemoteElement` lets you define a remote element class without having to subclass `RemoteElement`. Instead, you’ll just provide the remote `properties`, `attributes`, `events`, and `methods` for your element as options to the function:

```ts
import {createRemoteElement} from '@remote-dom/core/elements';

const MyElement = createRemoteElement({
  attributes: ['label'],
  events: ['change']
  properties: {
    emphasized: {type: Boolean},
  },
  methods: ['focus'],
});

customElements.define('my-element', MyElement);
```

When using TypeScript, you can pass the generic type arguments to `createRemoteElement` to define the property and method types for your element. This ensures that, when you create your element instance, the properties and methods are properly typed:

```ts
import {createRemoteElement} from '@remote-dom/core/elements';

interface MyElementAttributes {
  label?: string;
}

interface MyElementProperties {
  emphasized?: boolean;
}

interface MyElementEvents {
  change(event: CustomEvent): void;
}

interface MyElementMethods {
  focus(): void;
}

const MyElement = createRemoteElement<
  MyElementProperties,
  MyElementMethods,
  {},
  MyElementEvents
>({
  attributes: ['label'],
  events: ['change']
  properties: {
    emphasized: {type: Boolean},
  },
  methods: ['focus'],
});

customElements.define('my-element', MyElement);
```

#### `RemoteMutationObserver`

Remote DOM needs some way to detect that changes have happened in a remote element, in order to communicate those changes to the host environment. If you’re polyfilling the DOM with [`@remote-dom/core/polyfill`](#remote-domcorepolyfill), this is handled for you. However, when operating in other environments, like an `iframe` with a native DOM, you’ll need something that can track these changes.

The `RemoteMutationObserver` class builds on the browser’s [`MutationObserver`](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) to detect changes in a remote element, and to communicate those changes in a way that Remote DOM can understand. You create this object from a “remote connection”, which you’ll generally get from the [`@remote-dom/core/receiver`](#remote-domcorereceiver) package. Then, you’ll observe changes in the HTML element that contains your tree of remote elements.

```ts
import {RemoteMutationObserver} from '@remote-dom/core/elements';

const observer = new RemoteMutationObserver(connection);

// Now, any changes to the `body` element will be communicated
// to the host environment.
observer.observe(document.body);
```

#### `RemoteRootElement`

The `RemoteRootElement` is a custom `HTMLElement` subclass that can be used to define the root of a tree of custom elements that will be synchronized with the host environment. Unlike `RemoteMutationObserver`, `RemoteRootElement` **only** works in an environment polyfilled using `@remote-dom/core/polyfill`. Once created, you should pass a “remote connection” to the `connect()` method, which will start the synchronization process:

```ts
import {RemoteRootElement} from '@remote-dom/core/elements';

// Remote DOM does not define this element, so you can give it a
// name of your choice. We recommend using `remote-root`.

customElements.define('remote-root', RemoteRootElement);

const root = document.createElement('remote-root');

// Now, any changes to this elements descendants will be communicated
// to the host environment.
root.connect(connection);
```

#### `BatchingRemoteConnection`

The `RemoteConnection` object you receive from `RemoteReceiver.connection` is a simple object that immediately communicates all updates to the host environment. When using `RemoteMutationObserver`, documented above, this is not a major issue, since the `MutationObserver` API automatically batches DOM mutations. However, it can be more of a problem when using Remote DOM in a web worker (typically, with the `RemoteRootElement` wrapper), where no such batching is performed.

To improve performance in these cases, you can use the `BatchingRemoteConnection` class, which batches updates from the remote environment that happen in the same JavaScript task. This class is a subclass of `RemoteConnection`, and can be used directly in place of the original connection object:

```ts
import {
  BatchingRemoteConnection,
  RemoteRootElement,
} from '@remote-dom/core/elements';

customElements.define('remote-root', RemoteRootElement);

const root = document.createElement('remote-root');

root.connect(new BatchingRemoteConnection(connection));
```

#### `RemoteFragmentElement`

Some APIs in [`@remote-dom/preact`](../preact) and [`@remote-dom/react`](../react) need to create an HTML element as a generic container. This element is not defined by default, so if you use these features, you must define a matching custom element for this container. Remote DOM calls this element `remote-fragment`, and you can define this element using the `RemoteFragmentElement` constructor:

```ts
import {RemoteFragmentElement} from '@remote-dom/core/elements';

customElements.define('remote-fragment', RemoteFragmentElement);
```

### `@remote-dom/core/receivers`

A “remote receiver” collects updates that happened in a remote environment, and reconstructs them in a way that allows them to be rendered in the host environment.

This library provides two kinds of receiver: [`RemoteReceiver`](#remotereceiver), which converts the remote elements into a basic JavaScript representation, and [`DOMRemoteReceiver`](#domremotereceiver), which converts remote elements into matching DOM elements.

#### `RemoteReceiver`

A `RemoteReceiver` stores remote elements into a basic JavaScript representation, and allows subscribing to individual elements in the remote environment. This can be useful for mapping remote elements to components in a JavaScript framework; for example, the [`@remote-dom/react` library](../react#remoterenderer) uses this receiver to map remote elements to React components.

An empty remote receiver can be created using the `RemoteReceiver` constructor:

```ts
import {RemoteReceiver} from '@remote-dom/core/receivers';

const receiver = new RemoteReceiver();
```

To support functions being passed over `postMessage`, you may need a way to manually manage memory for remote properties as they are received. `RemoteReceiver` lets you accomplish this by passing the `retain` and `release` options to the constructor, which are called when new remote properties are received and when they are overwritten, respectively:

```ts
// This library is not included with Remote DOM, but it pairs
// well with it in allowing you to pass functions between
// JavaScript environments without leaking memory, by manually
// managing the memory for those functions.
import {retain, release} from '@quilted/threads';
import {RemoteReceiver} from '@remote-dom/core/receivers';

const receiver = new RemoteReceiver({retain, release});
```

##### `RemoteReceiver.connection`

Each `RemoteReceiver` has a `connection` property, which can be passed to a [`RemoteMutationObserver`](#remotemutationobserver) or [`RemoteRootElement`](#remoterootelement) in the remote environment. This object, which the library refers to as a `RemoteConnection`, is responsible for communicating changes between the remote environment and host environments.

```ts
// In the host environment:
import {RemoteReceiver} from '@remote-dom/core/receivers';

const receiver = new RemoteReceiver();

// In the remote environment:
import {RemoteMutationObserver} from '@remote-dom/core/elements';

const observer = new RemoteMutationObserver(receiver.connection);
```

##### `RemoteReceiver.root`

Each `RemoteReceiver` also has a `root` property, which defines the object that all remote element representations will be attached to. This object has a `children` property, which will contain child text and element nodes, which may themselves have additional children.

```ts
import {RemoteReceiver} from '@remote-dom/core/receivers';

const receiver = new RemoteReceiver();
const root = receiver.root;
// {
//   children: [],
//   version: 0,
//   ...
// }
```

##### `RemoteReceiver.subscribe()`

`RemoteReceiver.subscribe()` allows you to subscribe to changes in a remote element. This includes changes to the remote element’s properties and list of children, but note that you will not receive updates for properties or children of _nested_ elements.

The first argument to this function is the remote element you want to subscribe to, and the second is a function that will be called with the updated description of that element on each change:

```ts
import {RemoteReceiver} from '@remote-dom/core/receivers';

const receiver = new RemoteReceiver();

// Subscribe to all changes in the top-level children, attached
// directly to the remote “root”.
receiver.subscribe(receiver.root, (root) => {
  console.log('Root changed!', root);
});
```

You can pass a third options argument to the `subscribe()` method. Currently, only one option is available: `signal`, which lets you pass an [`AbortSignal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) that will be used to cancel the subscription:

```ts
import {RemoteReceiver} from '@remote-dom/core/receivers';

const abort = new AbortController();
const receiver = new RemoteReceiver();

// Subscribe to all changes in the top-level children, attached
// directly to the remote “root”.
receiver.subscribe(
  receiver.root,
  (root) => {
    console.log('Root changed!', root);
  },
  {signal: abort.signal},
);

// Stop listening in 10 seconds
setTimeout(() => {
  abort.abort();
}, 10_000);
```

##### `RemoteReceiver.implement()`

`RemoteReceiver.implement()` lets you define how [remote methods](#remote-methods) are implemented for a particular element. The first argument to this method is the element you want to implement methods for, and the second is an object that provides the implementation for each supported method.

For example, in the example below, we implement a `alert()` method on the root element, which can then be called from the remote environment:

```ts
// In the host environment:
import {RemoteReceiver} from '@remote-dom/core/receivers';

const receiver = new RemoteReceiver();

receiver.implement(receiver.root, {
  alert(message) {
    window.alert(message);
  },
});

// In the remote environment:
import {RemoteRootElement} from '@remote-dom/core/elements';

customElements.define('remote-root', RemoteRootElement);

const root = document.createElement('remote-root');
root.connect(receiver.connection);

root.callRemoteMethod('alert', 'Hello, world!');
```

##### `RemoteReceiver.get()`

`RemoteReceiver.get()` fetches the latest state of a remote element that has been received from the remote environment.

```ts
import {RemoteReceiver} from '@remote-dom/core/receivers';

const receiver = new RemoteReceiver();

receiver.get(receiver.root) === receiver.root; // true
```

#### `DOMRemoteReceiver`

`DOMRemoteReceiver` takes care of mapping remote elements to matching HTML elements on the host page. If you implement your UI with [custom elements](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements), `DOMRemoteReceiver` is a simple option that avoids much of the manual work required when using the basic `RemoteReceiver`.

An empty remote receiver can be created using the `DOMRemoteReceiver` constructor. You’ll then call the `connect()` method with the HTML element that will serve as your “root” element, to which all the synchronized remote elements will be attached:

```ts
import {DOMRemoteReceiver} from '@remote-dom/core/receivers';

const receiver = new DOMRemoteReceiver();

// Any custom elements created in the remote environment will
// be attached to the `body` element.
receiver.connect(document.body);
```

Like with `RemoteReceiver`, you can pass the `retain` and `release` options to the constructor to manually manage memory for remote properties as they are received:

```ts
// This library is not included with Remote DOM, but it pairs
// well with it in allowing you to pass functions between
// JavaScript environments without leaking memory, by manually
// managing the memory for those functions.
import {retain, release} from '@quilted/threads';
import {DOMRemoteReceiver} from '@remote-dom/core/receivers';

const receiver = new DOMRemoteReceiver({retain, release});
```

##### Caching DOM nodes

By default, `DOMRemoteReceiver` will create a new DOM node each time a remote element is attached to a new parent, which is done to release memory related to the remote environment as quickly as possible. However, this can be inefficient if you’re frequently moving elements between different parents, as this “re-parenting” will create separate elements on the host page each time the parent is changed. If this is a case you need to optimize for, you can pass the `cache.maxAge` option to the `DOMRemoteReceiver` constructor, which will re-use an existing host element representing a remote element when the remote element is re-attached within the specified number of milliseconds:

```ts
import {DOMRemoteReceiver} from '@remote-dom/core/receivers';

const receiver = new DOMRemoteReceiver({
  // Preserve host elements for 1 second after they are
  // detached from the tree
  cache: {maxAge: 1_000},
});
```

##### `DOMRemoteReceiver.connection`

Like `RemoteReceiver`, each `DOMRemoteReceiver` has a `connection` property, which can be passed to a [`RemoteMutationObserver`](#remotemutationobserver) or [`RemoteRootElement`](#remoterootelement) in the remote environment.

```ts
// In the host environment:
import {DOMRemoteReceiver} from '@remote-dom/core/receivers';

const receiver = new DOMRemoteReceiver();

// In the remote environment:
import {RemoteMutationObserver} from '@remote-dom/core/elements';

const observer = new RemoteMutationObserver(receiver.connection);
```

##### `DOMRemoteReceiver.root`

Each `DOMRemoteReceiver` has a `root` property. If you’ve called `connect()` on your receiver, this property will be the HTML element that you passed to that method. Otherwise, it will be a [`DocumentFragment`](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment) that stores remote elements before you’ve selected the host element to attach them to.

### `@remote-dom/core/polyfill`

The `@remote-dom/core/polyfill` package provides a minimal DOM polyfill that can be used to run remote elements in a web worker, and automatically communicates changes in that DOM to a host environment, if it has been connected by a [`RemoteRootElement`](#remoterootelement). This polyfill builds on top of the small, hook-able DOM polyfill provided by [`@remote-dom/polyfill`](../polyfill/).

To use this polyfill, import it before any other code that might depend on DOM globals:

```ts
import '@remote-dom/core/polyfill';
import {RemoteElement} from '@remote-dom/core/elements';

// ...
```

### `@remote-dom/core/html`

The `@remote-dom/core/html` package provides a helper function for creating DOM elements from tagged template literals. This lets you create large quantities of DOM elements, with intelligent handling of element properties, and supports minimal “components” for packaging up reusable DOM structures.

```ts
import {html} from '@remote-dom/core/html';

function MyButton() {
  return html`<ui-button
    onClick=${() => {
      console.log('Pressed!');
    }}
    >Click me!</ui-button
  >`;
}

const html = html`
  <ui-stack spacing>
    <ui-text>Hello, world!</ui-text>
    <${MyButton} />
  </ui-stack>
` satisfies HTMLElement;
```

This helper uses the following logic to determine whether a given property in the template should map to an attribute, property, or event listener:

- If the property is an instance member of the element, it will be set as a property.
- If the property is an HTML element, it will be appended as a child in a slot named the same as the property (e.g., `<ui-button modal=${html`<ui-modal />`}>` becomes a `ui-modal` child with a `slot="modal"` attribute).
- If the property starts with `on`, the value will be set as an event listener, with the event name being the lowercased version of the string following `on` (e.g., `onClick` sets a `click` event).
- Otherwise, the property will be set as an attribute.



================================================
FILE: packages/core/CHANGELOG.md
================================================
# @remote-dom/core

## 1.10.1

### Patch Changes

- [#600](https://github.com/Shopify/remote-dom/pull/600) [`d9b4dab`](https://github.com/Shopify/remote-dom/commit/d9b4dab1ce2f76751fafab04e7a6ede8a3aa8045) Thanks [@henrytao-me](https://github.com/henrytao-me)! - Fix document fragment owner document

- Updated dependencies [[`d9b4dab`](https://github.com/Shopify/remote-dom/commit/d9b4dab1ce2f76751fafab04e7a6ede8a3aa8045)]:
  - @remote-dom/polyfill@1.5.1

## 1.10.0

### Minor Changes

- [#598](https://github.com/Shopify/remote-dom/pull/598) [`2be51e8`](https://github.com/Shopify/remote-dom/commit/2be51e87718929482a598ba3bb3972f539fa9d8d) Thanks [@igor10k](https://github.com/igor10k)! - Add support for multiple arguments in event listners

## 1.9.0

### Minor Changes

- [#583](https://github.com/Shopify/remote-dom/pull/583) [`a7be991`](https://github.com/Shopify/remote-dom/commit/a7be991202a16cec1866c7eccea86012a5a91263) Thanks [@lemonmade](https://github.com/lemonmade)! - Improved `RemoteMutationObserver` to support automatic emptying and observing multiple nodes

  If you are observing a multi-node list — such as a `DocumentFragment` or `<template>` element — you can now provide a custom `id` option when observing each node. This allows you to treat the observer as a kind of "virtual root" for a list of nodes, similar to the role the `DocumentFragment` plays in the DOM. You are responsible for giving each node a unique ID, and this class will take care of correctly attaching that node to the root of the remote tree.

  ```js
  const observer = new RemoteMutationObserver(connection);

  let id = 0;
  for (const child of documentFragment.childNodes) {
    observer.observe(child, {
      id: `DocumentFragment:${id++}`,
    });
  }
  ```

  You can also now provide an `empty` option to `RemoteMutationObserver.disconnect()` in order to clear out children in remote environment:

  ```js
  const observer = new RemoteMutationObserver(connection);

  observer.observe(container);

  observer.disconnect({empty: true});
  ```

- [#583](https://github.com/Shopify/remote-dom/pull/583) [`a7be991`](https://github.com/Shopify/remote-dom/commit/a7be991202a16cec1866c7eccea86012a5a91263) Thanks [@lemonmade](https://github.com/lemonmade)! - Expose `remoteId()` and `setRemoteId()` for getting and setting a Node's remote ID

## 1.8.1

### Patch Changes

- [#581](https://github.com/Shopify/remote-dom/pull/581) [`d4fd36d`](https://github.com/Shopify/remote-dom/commit/d4fd36df90a7813b5003c5a88386335958d11d65) Thanks [@robin-drexler](https://github.com/robin-drexler)! - Fix missing side effect declaration

## 1.8.0

### Minor Changes

- [#576](https://github.com/Shopify/remote-dom/pull/576) [`ed2d24c`](https://github.com/Shopify/remote-dom/commit/ed2d24cb0d4a4b4146a1507796a40b4fdc3aaf8d) Thanks [@robin-drexler](https://github.com/robin-drexler)! - Allow to import hooks without global window override side effect

## 1.7.1

### Patch Changes

- [#570](https://github.com/Shopify/remote-dom/pull/570) [`33baaba`](https://github.com/Shopify/remote-dom/commit/33baaba512ca461068f57dcba707ef1cc640bfca) Thanks [@robin-drexler](https://github.com/robin-drexler)! - fix event listener methods not being bound to correctly

- Updated dependencies [[`33baaba`](https://github.com/Shopify/remote-dom/commit/33baaba512ca461068f57dcba707ef1cc640bfca)]:
  - @remote-dom/polyfill@1.4.4

## 1.7.0

### Minor Changes

- [#533](https://github.com/Shopify/remote-dom/pull/533) [`a9a88ab`](https://github.com/Shopify/remote-dom/commit/a9a88abe4ba81b253f0cc6cdd5e82a25bbe908c1) Thanks [@igor10k](https://github.com/igor10k)! - Make `removeChild` less strict in receivers

## 1.6.1

### Patch Changes

- [#528](https://github.com/Shopify/remote-dom/pull/528) [`df294ab`](https://github.com/Shopify/remote-dom/commit/df294abad5522110e031e5b3e2a978871aa703fb) Thanks [@brianshen1990](https://github.com/brianshen1990)! - return early if falling back to setTimeout for MessageChannel

## 1.6.0

### Minor Changes

- [#526](https://github.com/Shopify/remote-dom/pull/526) [`8cbf2c2`](https://github.com/Shopify/remote-dom/commit/8cbf2c2a6130dd0a19088a2adf18b506f468be8b) Thanks [@robin-drexler](https://github.com/robin-drexler)! - add flush method to BatchingRemoteConnection

## 1.5.2

### Patch Changes

- [#517](https://github.com/Shopify/remote-dom/pull/517) [`99a8e1a`](https://github.com/Shopify/remote-dom/commit/99a8e1ad8d441619a33a5a4c3f2424fe1ccbe8df) Thanks [@lemonmade](https://github.com/lemonmade)! - Fix missing attributes and event listeners on root receiver elements

## 1.5.1

### Patch Changes

- [#499](https://github.com/Shopify/remote-dom/pull/499) [`994e2ea`](https://github.com/Shopify/remote-dom/commit/994e2ea2f7ab0e67a2c37e5295ce86618b004518) Thanks [@lemonmade](https://github.com/lemonmade)! - Roll back mutation of `globalThis` and `globalThis.self` in `Window.setGlobal()`

  This prevents the polyfill from interfering with globals like `globalThis.addEventListener`, which you may need to manage the communication between a sandboxed environment and the main thread.

  In the future, we will likely change the polyfill to require you to explicitly install the polyfill, instead of it being done automatically when you `@remote-dom/core/polyfill`. At that point, we will reintroduce the ability to more faithfully replicate more DOM globals, like having `globalThis`, `globalThis.self`, and `globalThis.window` all refer to the same polyfilled `Window` object. To install this polyfill today and get back to the behavior introduced by [this PR](https://github.com/Shopify/remote-dom/pull/470), you can call the new `Window.setGlobalThis()` method:

  ```js
  import {window, Window} from '@remote-dom/core/polyfill';

  Window.setGlobalThis(window);
  ```

- [#465](https://github.com/Shopify/remote-dom/pull/465) [`017ca02`](https://github.com/Shopify/remote-dom/commit/017ca029fb148a51115edb12b7c8ccd49d2c52eb) Thanks [@lemonmade](https://github.com/lemonmade)! - Fix `slot` to be transmitted as an attribute, not a property

- Updated dependencies [[`994e2ea`](https://github.com/Shopify/remote-dom/commit/994e2ea2f7ab0e67a2c37e5295ce86618b004518)]:
  - @remote-dom/polyfill@1.4.2

## 1.5.0

### Minor Changes

- [#389](https://github.com/Shopify/remote-dom/pull/389) [`2479b21`](https://github.com/Shopify/remote-dom/commit/2479b21406f6149063bfc095dbb6c3a019386403) Thanks [@lemonmade](https://github.com/lemonmade)! - Added native support for synchronizing attributes and event listeners

  Previously, Remote DOM only offered “remote properties” as a way to synchronize element state between the host and remote environments. These remote properties effectively synchronize a subset of a custom element’s instance properties. The `RemoteElement` class offers [a declarative way to define the properties that should be synchronized](/packages/core/README.md#remote-properties).

  ```ts
  import {RemoteElement} from '@remote-dom/core/elements';

  class MyElement extends RemoteElement {
    static get remoteProperties() {
      return ['label'];
    }
  }

  customElements.define('my-element', MyElement);

  const myElement = document.createElement('my-element');
  myElement.label = 'Hello, World!';
  ```

  The same `remoteProperties` configuration can create special handling for attributes and event listeners. By default, a remote property is automatically updated when setting an [attribute](https://developer.mozilla.org/en-US/docs/Glossary/Attribute) of the same name:

  ```ts
  const myElement = document.createElement('my-element');
  myElement.setAttribute('label', 'Hello, World!');

  // myElement.label === 'Hello, World!', and this value is synchronized
  // with the host environment as a “remote property”
  ```

  Similarly, a remote property can be automatically updated when adding an event listener based on a conventional `on` property naming prefix:

  ```ts
  import {RemoteElement} from '@remote-dom/core/elements';

  class MyElement extends RemoteElement {
    static get remoteProperties() {
      return {
        onChange: {
          event: true,
        },
      };
    }
  }

  customElements.define('my-element', MyElement);

  const myElement = document.createElement('my-element');

  // This adds a callback property that is synchronized with the host environment
  myElement.onChange = () => console.log('Changed!');

  // And so does this, but using the `addEventListener` method instead
  myElement.addEventListener('change', () => console.log('Changed!'));
  ```

  These utilities are handy, but they don’t align with patterns in native DOM elements, particularly when it comes to events. Now, both of these can be represented in a fashion that is more conventional in HTML. The `remoteAttributes` configuration allows you to define a set of element attributes that will be synchronized directly the host environment, instead of being treated as instance properties:

  ```ts
  import {RemoteElement} from '@remote-dom/core/elements';

  class MyElement extends RemoteElement {
    static get remoteAttributes() {
      return ['label'];
    }

    // If you want to add instance properties, you can do it with getters and
    // setters that manipulate the attribute value:
    //
    // get label() {
    //   return this.getAttribute('label');
    // }
    //
    // set label(value) {
    //   this.setAttribute('label', value);
    // }
  }

  customElements.define('my-element', MyElement);

  const myElement = document.createElement('my-element');
  myElement.setAttribute('label', 'Hello, World!');
  ```

  Similarly, the `remoteEvents` configuration allows you to define a set of event listeners that will be synchronized directly with the host environment:

  ```ts
  import {RemoteElement} from '@remote-dom/core/elements';

  class MyElement extends RemoteElement {
    static get remoteEvents() {
      return ['change'];
    }
  }

  customElements.define('my-element', MyElement);

  const myElement = document.createElement('my-element');

  // And so does this, but using the `addEventListener` method instead
  myElement.addEventListener('change', () => console.log('Changed!'));

  // No `myElement.onChange` property is created
  ```

  The `remoteProperties` configuration will continue to be supported for cases where you want to synchronize instance properties. Because instance properties can be any JavaScript type, properties are the highest-fidelity field that can be synchronized between the remote and host environments. However, adding event listeners using the `remoteProperties.event` configuration is **deprecated and will be removed in the next major version**. You should use the `remoteEvents` configuration instead. If you were previously defining remote properties which only accepted strings, consider using the `remoteAttributes` configuration, which stores the value entirely in an HTML attribute instead.

  This change is being released in a backwards-compatible way, so you can continue to use the existing `remoteProperties` configuration on host and/or remote environments without any code changes.

  All host utilities have been updated to support the new `attributes` and `eventListeners` property that are synchronized with the remote environment. This includes updates to the [React](/packages/react/README.md#event-listener-props) and [Preact hosts to map events to conventional callback props](/packages/preact/README.md#event-listener-props), and updates to the [`DOMRemoteReceiver` class](/packages/core/README.md#domremotereceiver), which now applies fields to the host element exactly as they were applied in the remote environment:

  ```ts
  // Remote environment:

  class MyElement extends RemoteElement {
    static get remoteEvents() {
      return ['change'];
    }
  }

  customElements.define('my-element', MyElement);

  const myElement = document.createElement('my-element');

  myElement.addEventListener('change', (event) => {
    console.log('Changed! New value: ', event.detail);
  });

  // Host environment:

  class MyElement extends HTMLElement {
    connectedCallback() {
      // Emit a change event on this element, with detail that will be passed
      // to the remote environment
      this.addEventListener('change', (event) => {
        event.stopImmediatePropagation();

        this.dispatchEvent(
          new CustomEvent('change', {
            detail: this.value,
          }),
        );
      });
    }

    // Additional implementation details of the host custom element...
  }

  customElements.define('my-element', MyElement);
  ```

### Patch Changes

- Updated dependencies [[`2479b21`](https://github.com/Shopify/remote-dom/commit/2479b21406f6149063bfc095dbb6c3a019386403), [`2479b21`](https://github.com/Shopify/remote-dom/commit/2479b21406f6149063bfc095dbb6c3a019386403), [`2479b21`](https://github.com/Shopify/remote-dom/commit/2479b21406f6149063bfc095dbb6c3a019386403)]:
  - @remote-dom/polyfill@1.3.0

## 1.4.1

### Patch Changes

- [#419](https://github.com/Shopify/remote-dom/pull/419) [`3c6bd29`](https://github.com/Shopify/remote-dom/commit/3c6bd291121b9fa02cac4ba57274601e97b2a2d2) Thanks [@lemonmade](https://github.com/lemonmade)! - Fix synchronization of `slot` property in some edge cases

## 1.4.0

### Minor Changes

- [#411](https://github.com/Shopify/remote-dom/pull/411) [`3bec698`](https://github.com/Shopify/remote-dom/commit/3bec6983756c4b8a6834a037ac520438ef59d28f) Thanks [@lemonmade](https://github.com/lemonmade)! - Add CommonJS export conditions

### Patch Changes

- Updated dependencies [[`3bec698`](https://github.com/Shopify/remote-dom/commit/3bec6983756c4b8a6834a037ac520438ef59d28f)]:
  - @remote-dom/polyfill@1.2.0

## 1.3.0

### Minor Changes

- [#402](https://github.com/Shopify/remote-dom/pull/402) [`218ba3b`](https://github.com/Shopify/remote-dom/commit/218ba3bf1ff2e7518a7dcec11ffd352de70b16f8) Thanks [@olavoasantos](https://github.com/olavoasantos)! - Refactor hooks into the Window instance

### Patch Changes

- Updated dependencies [[`218ba3b`](https://github.com/Shopify/remote-dom/commit/218ba3bf1ff2e7518a7dcec11ffd352de70b16f8)]:
  - @remote-dom/polyfill@1.1.0

## 1.2.1

### Patch Changes

- [#405](https://github.com/Shopify/remote-dom/pull/405) [`6b38a37`](https://github.com/Shopify/remote-dom/commit/6b38a379ef2f0644bff18390708a48b4f6d3fa5d) Thanks [@vividviolet](https://github.com/vividviolet)! - Export BatchingRemoteConnection so it can be used

## 1.2.0

### Minor Changes

- [`040e7c5`](https://github.com/Shopify/remote-dom/commit/040e7c5dde658596ccbf883e2d3810955790eff0) Thanks [@lemonmade](https://github.com/lemonmade)! - Add `cache` option to `DOMRemoteReceiver` to preserve host elements

- [`894d6f3`](https://github.com/Shopify/remote-dom/commit/894d6f3396ebb2e1de7e91b1a445aa0a39195bb9) Thanks [@lemonmade](https://github.com/lemonmade)! - Return `DocumentFragment` from `DOMRemoteReceiver.disconnect()`

## 1.1.0

### Minor Changes

- [#394](https://github.com/Shopify/remote-dom/pull/394) [`22e6512`](https://github.com/Shopify/remote-dom/commit/22e6512f797d97d2106f181d730d995f37c6edaf) Thanks [@lemonmade](https://github.com/lemonmade)! - Add `BatchingRemoteConnection` helper for batching changes to a polyfilled DOM

## 1.0.1

### Patch Changes

- [`ee5e843`](https://github.com/Shopify/remote-dom/commit/ee5e843a85c1d213420ae25cb2fc248484ca04f3) Thanks [@lemonmade](https://github.com/lemonmade)! - Force upgrade polyfill dependency to fix `createElementNS` errors

## 1.0.0

### Major Changes

- [`37be652`](https://github.com/Shopify/remote-dom/commit/37be652f288d1eec170c0be13b2da516f8db5dcf) Thanks [@lemonmade](https://github.com/lemonmade)! - First release of Remote DOM. Read more about this [refactor of remote-ui on native DOM APIs](https://github.com/Shopify/remote-dom/discussions/267), and take a look at the [updated documentation](/README.md).

### Patch Changes

- Updated dependencies [[`37be652`](https://github.com/Shopify/remote-dom/commit/37be652f288d1eec170c0be13b2da516f8db5dcf)]:
  - @remote-dom/polyfill@1.0.0

## 0.1.1

### Patch Changes

- [#268](https://github.com/Shopify/remote-dom/pull/268) [`9576a72`](https://github.com/Shopify/remote-dom/commit/9576a72fa354481621c53efde4169829fe9bfabf) Thanks [@shopify-github-actions-access](https://github.com/apps/shopify-github-actions-access)! - Send initial tree of UI elements when connecting a `RemoteRootElement`

## 0.1.0

### Minor Changes

- [`7061ded`](https://github.com/Shopify/remote-dom/commit/7061ded1da4699c6dd6a820eeb940a8af7c66d82) Thanks [@lemonmade](https://github.com/lemonmade)! - Test minor bump

### Patch Changes

- Updated dependencies [[`7061ded`](https://github.com/Shopify/remote-dom/commit/7061ded1da4699c6dd6a820eeb940a8af7c66d82)]:
  - @remote-dom/polyfill@0.1.0

## 0.0.2

### Patch Changes

- [#251](https://github.com/Shopify/remote-dom/pull/251) [`5939cca`](https://github.com/Shopify/remote-dom/commit/5939cca8112417124327bd26f9e2c21f4bf9b20a) Thanks [@lemonmade](https://github.com/lemonmade)! - Test version bump

- [#251](https://github.com/Shopify/remote-dom/pull/251) [`8e1fad4`](https://github.com/Shopify/remote-dom/commit/8e1fad4a00cfe68ff1594fbabeec10c29958685f) Thanks [@lemonmade](https://github.com/lemonmade)! - Add `root` option to `DOMRemoteReceiver`

- Updated dependencies [[`5939cca`](https://github.com/Shopify/remote-dom/commit/5939cca8112417124327bd26f9e2c21f4bf9b20a)]:
  - @remote-dom/polyfill@0.0.2



================================================
FILE: packages/core/package.json
================================================
{
  "name": "@remote-dom/core",
  "type": "module",
  "license": "MIT",
  "description": "A collection of DOM-based utilities for synchronizing elements between JavaScript environments",
  "publishConfig": {
    "access": "public",
    "@remote-dom/registry": "https://registry.npmjs.org"
  },
  "version": "1.10.1",
  "engines": {
    "node": ">=14.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/Shopify/remote-dom",
    "directory": "packages/core"
  },
  "exports": {
    ".": {
      "types": "./build/typescript/index.d.ts",
      "quilt:source": "./source/index.ts",
      "quilt:esnext": "./build/esnext/index.esnext",
      "import": "./build/esm/index.mjs",
      "require": "./build/cjs/index.cjs"
    },
    "./elements": {
      "types": "./build/typescript/elements.d.ts",
      "quilt:source": "./source/elements.ts",
      "quilt:esnext": "./build/esnext/elements.esnext",
      "import": "./build/esm/elements.mjs",
      "require": "./build/cjs/elements.cjs"
    },
    "./html": {
      "types": "./build/typescript/html.d.ts",
      "quilt:source": "./source/html.ts",
      "quilt:esnext": "./build/esnext/html.esnext",
      "import": "./build/esm/html.mjs",
      "require": "./build/cjs/html.cjs"
    },
    "./polyfill": {
      "types": "./build/typescript/polyfill/polyfill.d.ts",
      "quilt:source": "./source/polyfill/polyfill.ts",
      "quilt:esnext": "./build/esnext/polyfill/polyfill.esnext",
      "import": "./build/esm/polyfill/polyfill.mjs",
      "require": "./build/cjs/polyfill/polyfill.cjs"
    },
    "./polyfill/hooks": {
      "types": "./build/typescript/polyfill/hooks.d.ts",
      "quilt:source": "./source/polyfill/hooks.ts",
      "quilt:esnext": "./build/esnext/polyfill/hooks.esnext",
      "import": "./build/esm/polyfill/hooks.mjs",
      "require": "./build/cjs/polyfill/hooks.cjs"
    },
    "./receivers": {
      "types": "./build/typescript/receivers.d.ts",
      "quilt:source": "./source/receivers.ts",
      "quilt:esnext": "./build/esnext/receivers.esnext",
      "import": "./build/esm/receivers.mjs",
      "require": "./build/cjs/receivers.cjs"
    }
  },
  "types": "./build/typescript/index.d.ts",
  "typesVersions": {
    "*": {
      "elements": [
        "./build/typescript/elements.d.ts"
      ],
      "html": [
        "./build/typescript/html.d.ts"
      ],
      "polyfill": [
        "./build/typescript/polyfill/polyfill.d.ts"
      ],
      "polyfill/hooks": [
        "./build/typescript/polyfill/hooks.d.ts"
      ],
      "receivers": [
        "./build/typescript/receivers.d.ts"
      ]
    }
  },
  "sideEffects": [
    "./source/polyfill/**/*.ts",
    "./build/cjs/polyfill/**/*.cjs",
    "./build/esm/polyfill/**/*.mjs",
    "./build/esnext/polyfill/**/*.esnext"
  ],
  "scripts": {
    "build": "rollup --config ./rollup.config.js"
  },
  "dependencies": {
    "@remote-dom/polyfill": "workspace:^1.5.1",
    "htm": "^3.1.1"
  },
  "peerDependencies": {
    "@preact/signals-core": "^1.3.0"
  },
  "peerDependenciesMeta": {
    "@preact/signals-core": {
      "optional": true
    },
    "preact": {
      "optional": true
    }
  },
  "devDependencies": {
    "@preact/signals-core": "^1.8.0",
    "@quilted/testing": "^0.1.6"
  },
  "browserslist": [
    "defaults and not dead"
  ]
}



================================================
FILE: packages/core/rollup.config.js
================================================
import {quiltPackage} from '@quilted/rollup/package';

export default quiltPackage({commonjs: true});



================================================
FILE: packages/core/tsconfig.json
================================================
{
  "extends": "@quilted/typescript/tsconfig.package.json",
  "references": [{"path": "../polyfill"}]
}



================================================
FILE: packages/core/vite.config.js
================================================
import {quiltPackage} from '@quilted/vite';
import {defineConfig} from 'vitest/config';

export default defineConfig({
  plugins: [quiltPackage()],
});



================================================
FILE: packages/core/source/connection.ts
================================================
import {
  MUTATION_TYPE_INSERT_CHILD,
  MUTATION_TYPE_REMOVE_CHILD,
  MUTATION_TYPE_UPDATE_TEXT,
  MUTATION_TYPE_UPDATE_PROPERTY,
} from './constants.ts';
import type {
  RemoteConnection,
  RemoteMutationRecordInsertChild,
  RemoteMutationRecordRemoveChild,
  RemoteMutationRecordUpdateText,
  RemoteMutationRecordUpdateProperty,
} from './types.ts';

export type {RemoteConnection};

export interface RemoteConnectionHandler {
  /**
   * Handles the `call()` operation on the `RemoteConnection`.
   */
  call: RemoteConnection['call'];

  /**
   * Handles the `MUTATION_TYPE_INSERT_CHILD` mutation record.
   */
  insertChild(
    id: RemoteMutationRecordInsertChild[1],
    child: RemoteMutationRecordInsertChild[2],
    index: RemoteMutationRecordInsertChild[3],
  ): void;

  /**
   * Handles the `MUTATION_TYPE_REMOVE_CHILD` mutation record.
   */
  removeChild(
    id: RemoteMutationRecordRemoveChild[1],
    index: RemoteMutationRecordRemoveChild[2],
  ): void;

  /**
   * Handles the `MUTATION_TYPE_UPDATE_TEXT` mutation record.
   */
  updateText(
    id: RemoteMutationRecordUpdateText[1],
    text: RemoteMutationRecordUpdateText[2],
  ): void;

  /**
   * Handles the `MUTATION_TYPE_UPDATE_PROPERTY` mutation record.
   */
  updateProperty(
    id: RemoteMutationRecordUpdateProperty[1],
    property: RemoteMutationRecordUpdateProperty[2],
    value: RemoteMutationRecordUpdateProperty[3],
    type?: RemoteMutationRecordUpdateProperty[4],
  ): void;
}

/**
 * A helper for creating a `RemoteConnection` object. The `RemoteConnection`
 * protocol is pretty low-level; this function provides more human-friendly
 * naming on top of the protocol.
 */
export function createRemoteConnection({
  call,
  insertChild,
  removeChild,
  updateText,
  updateProperty,
}: RemoteConnectionHandler): RemoteConnection {
  const handlers = {
    [MUTATION_TYPE_INSERT_CHILD]: insertChild,
    [MUTATION_TYPE_REMOVE_CHILD]: removeChild,
    [MUTATION_TYPE_UPDATE_TEXT]: updateText,
    [MUTATION_TYPE_UPDATE_PROPERTY]: updateProperty,
  };

  return {
    call,
    mutate(records) {
      for (const [type, ...args] of records) {
        (handlers[type] as any)(...args);
      }
    },
  };
}



================================================
FILE: packages/core/source/constants.ts
================================================
export const NODE_TYPE_ELEMENT = 1;
export const NODE_TYPE_TEXT = 3;
export const NODE_TYPE_COMMENT = 8;
export const NODE_TYPE_ROOT = 9;

export const MUTATION_TYPE_INSERT_CHILD = 0;
export const MUTATION_TYPE_REMOVE_CHILD = 1;
export const MUTATION_TYPE_UPDATE_TEXT = 2;
export const MUTATION_TYPE_UPDATE_PROPERTY = 3;

export const UPDATE_PROPERTY_TYPE_PROPERTY = 1;
export const UPDATE_PROPERTY_TYPE_ATTRIBUTE = 2;
export const UPDATE_PROPERTY_TYPE_EVENT_LISTENER = 3;

export const ROOT_ID = '~';



================================================
FILE: packages/core/source/elements.ts
================================================
export {
  RemoteElement,
  createRemoteElement,
  type RemoteElementConstructor,
  type RemotePropertiesFromElementConstructor,
  type RemoteMethodsFromElementConstructor,
  type RemoteSlotsFromElementConstructor,
  type RemoteEventListenersFromElementConstructor,
  type RemoteElementCreatorOptions,
} from './elements/RemoteElement.ts';
export {RemoteFragmentElement} from './elements/RemoteFragmentElement.ts';
export {RemoteRootElement} from './elements/RemoteRootElement.ts';
export {RemoteReceiverElement} from './elements/RemoteReceiverElement.ts';
export type {
  RemoteElementPropertyType,
  RemoteElementPropertyDefinition,
  RemoteElementPropertiesDefinition,
  RemoteElementAttributeDefinition,
  RemoteElementEventListenerDefinition,
  RemoteElementEventListenersDefinition,
  RemoteElementSlotDefinition,
  RemoteElementSlotsDefinition,
} from './elements/types.ts';

export {RemoteEvent} from './elements/RemoteEvent.ts';
export {RemoteMutationObserver} from './elements/RemoteMutationObserver.ts';

export {
  remoteId,
  setRemoteId,
  connectRemoteNode,
  disconnectRemoteNode,
  serializeRemoteNode,
  updateRemoteElementProperty,
  updateRemoteElementAttribute,
  updateRemoteElementEventListener,
  callRemoteElementMethod,
} from './elements/internals.ts';

export {remoteSlots} from './elements/decorators/remote-slots.ts';
export {remoteProperties} from './elements/decorators/remote-properties.ts';
export {remoteProperty} from './elements/decorators/remote-property.ts';
export {customElement} from './elements/decorators/custom-element.ts';

export {BooleanOrString} from './elements/property-types/BooleanOrString.ts';

export type {RemoteConnection} from './types.ts';

export {BatchingRemoteConnection} from './elements/connection.ts';



================================================
FILE: packages/core/source/html.ts
================================================
import htm from 'htm/mini';

const htmlInner = htm.bind(h);

export function html<
  Result extends null | Node | Node[] = null | Node | Node[],
>(strings: TemplateStringsArray, ...values: any[]) {
  return normalizeComponentReturn<Result>(htmlInner(strings, ...values));
}

export type PropertiesWithChildren<
  Properties extends Record<string, any> = {},
  Children extends Node = Node,
> = Properties & {children: Children[]};

export interface Component<
  Properties extends Record<string, any> = {},
  Children extends Node = Node,
> {
  (
    properties: PropertiesWithChildren<Properties, Children>,
  ): Node | string | (Node | string)[];
}

// Inspired by https://github.com/developit/vhtml
export function h<
  Properties extends Record<string, any> = Record<string, never>,
>(
  name: string | Component<Properties, any>,
  properties?: Properties,
  ...children: (Node | string | (Node | string)[])[]
) {
  let childNodes = normalizeComponentReturn<Node[] | null>(children);

  // Pseudo-components, where they get DOM nodes as children.
  if (typeof name === 'function') {
    const resolvedProperties: any = properties ?? {};
    resolvedProperties.children = childNodes;
    return normalizeComponentReturn(name(resolvedProperties));
  }

  const element = document.createElement(name);

  if (properties) {
    for (const property in properties) {
      const value = properties[property] as any;

      if (value instanceof Node) {
        childNodes ??= [];
        const fragment = document.createElement('remote-fragment');
        fragment.slot = property;
        fragment.append(value);
        childNodes.push(fragment);
      } else if (property in element) {
        (element as any)[property] = value;
      } else if (property[0] === 'o' && property[1] === 'n') {
        const eventName = `${property[2]!.toLowerCase()}${property.slice(3)}`;
        element.addEventListener(eventName, value);
      } else if (value === true) {
        element.setAttribute(property, '');
      } else if (value == null || value === false) {
        element.removeAttribute(property);
      } else {
        element.setAttribute(property, String(value));
      }
    }
  }

  if (childNodes) element.append(...childNodes);

  return element;
}

function normalizeComponentReturn<
  Result extends null | Node | Node[] = null | Node | Node[],
>(result: unknown) {
  let normalized: Result;

  if (Array.isArray(result)) {
    normalized = [] as any;

    for (const item of result.flat()) {
      const normalizedItem = normalizedComponentReturnItem(item);
      if (normalizedItem) (normalized as any).push(normalizedItem);
    }
  } else {
    normalized = normalizedComponentReturnItem(result) as any;
  }

  if (Array.isArray(normalized) && normalized.length === 0) {
    return null as Result;
  }

  return normalized;
}

function normalizedComponentReturnItem<T>(
  value: T,
): T extends string ? Exclude<T, string> | Text : T {
  return typeof value === 'string' || typeof value === 'number'
    ? document.createTextNode(String(value))
    : ((value || null) as any);
}



================================================
FILE: packages/core/source/index.ts
================================================
export {
  createRemoteConnection,
  type RemoteConnectionHandler,
} from './connection.ts';

export * from './types.ts';
export {
  ROOT_ID,
  NODE_TYPE_COMMENT,
  NODE_TYPE_ELEMENT,
  NODE_TYPE_ROOT,
  NODE_TYPE_TEXT,
  MUTATION_TYPE_INSERT_CHILD,
  MUTATION_TYPE_REMOVE_CHILD,
  MUTATION_TYPE_UPDATE_TEXT,
  MUTATION_TYPE_UPDATE_PROPERTY,
  UPDATE_PROPERTY_TYPE_PROPERTY,
  UPDATE_PROPERTY_TYPE_EVENT_LISTENER,
  UPDATE_PROPERTY_TYPE_ATTRIBUTE,
} from './constants.ts';



================================================
FILE: packages/core/source/receivers.ts
================================================
export {
  RemoteReceiver,
  type RemoteReceiverElement,
  type RemoteReceiverNode,
  type RemoteReceiverParent,
  type RemoteReceiverRoot,
  type RemoteReceiverText,
  type RemoteReceiverComment,
} from './receivers/RemoteReceiver.ts';
export {DOMRemoteReceiver} from './receivers/DOMRemoteReceiver.ts';
export type {RemoteReceiverOptions} from './receivers/shared.ts';



================================================
FILE: packages/core/source/types.ts
================================================
import type {
  NODE_TYPE_ELEMENT,
  NODE_TYPE_TEXT,
  NODE_TYPE_COMMENT,
  MUTATION_TYPE_INSERT_CHILD,
  MUTATION_TYPE_REMOVE_CHILD,
  MUTATION_TYPE_UPDATE_TEXT,
  MUTATION_TYPE_UPDATE_PROPERTY,
  UPDATE_PROPERTY_TYPE_PROPERTY,
  UPDATE_PROPERTY_TYPE_EVENT_LISTENER,
  UPDATE_PROPERTY_TYPE_ATTRIBUTE,
} from './constants.ts';

/**
 * Describes a remote node being inserted into the tree.
 */
export type RemoteMutationRecordInsertChild = [
  type: typeof MUTATION_TYPE_INSERT_CHILD,

  /**
   * The ID of the parent node.
   */
  id: string,

  /**
   * A description of the child node being inserted.
   */
  child:
    | RemoteTextSerialization
    | RemoteCommentSerialization
    | RemoteElementSerialization,

  /**
   * The index in the parents’ children to insert the new child.
   */
  index: number,
];

/**
 * Describes a remote node being removed from the tree.
 */
export type RemoteMutationRecordRemoveChild = [
  type: typeof MUTATION_TYPE_REMOVE_CHILD,

  /**
   * The ID of the parent node.
   */
  id: string,

  /**
   * The index of the child to remove.
   */
  index: number,
];

/**
 * Describes an update to the content of a remote text node.
 */
export type RemoteMutationRecordUpdateText = [
  type: typeof MUTATION_TYPE_UPDATE_TEXT,

  /**
   * The ID of the text node being updated.
   */
  id: string,

  /**
   * The new text content.
   */
  text: string,
];

/**
 * Describes an update to the property of a remote element. A “remote property”
 * represents either an HTML element property, event listener, or attribute.
 */
export type RemoteMutationRecordUpdateProperty = [
  type: typeof MUTATION_TYPE_UPDATE_PROPERTY,

  /**
   * The ID of the element being updated.
   */
  id: string,

  /**
   * The name of the property being updated.
   */
  name: string,

  /**
   * The new value of the property.
   */
  value: unknown,

  /**
   * The kind of property being updated.
   * @default UPDATE_PROPERTY_TYPE_PROPERTY
   */
  updateType?:
    | typeof UPDATE_PROPERTY_TYPE_PROPERTY
    | typeof UPDATE_PROPERTY_TYPE_EVENT_LISTENER
    | typeof UPDATE_PROPERTY_TYPE_ATTRIBUTE,
];

/**
 * Describes any mutation to the remote tree of nodes.
 */
export type RemoteMutationRecord =
  | RemoteMutationRecordInsertChild
  | RemoteMutationRecordRemoveChild
  | RemoteMutationRecordUpdateText
  | RemoteMutationRecordUpdateProperty;

/**
 * An object that can synchronize a tree of elements between two JavaScript
 * environments. This object acts as a “thin waist”, allowing for efficient
 * communication of changes between a “remote” environment (usually, a JavaScript
 * sandbox, such as an `iframe` or Web Worker) and a “host” environment
 * (usually, a top-level browser page).
 */
export interface RemoteConnection {
  /**
   * Communicates a list of changes to the tree of remote elements.
   */
  mutate(records: readonly RemoteMutationRecord[]): void;

  /**
   * Calls a method on the host version of an element.
   *
   * @param id The ID of the element to call the method on.
   * @param method The name of the method to call on the host version element.
   * @param args The list of arguments to pass to the method.
   * @returns The return value of the method.
   */
  call(id: string, method: string, ...args: readonly unknown[]): unknown;
}

/**
 * Represents an element node of a remote tree in a plain JavaScript format.
 */
export interface RemoteElementSerialization {
  /**
   * A unique identifier for the node.
   */
  readonly id: string;

  /**
   * The type of node. This value is always `1` for element nodes.
   */
  readonly type: typeof NODE_TYPE_ELEMENT;

  /**
   * The name of the element, which will be the name of the custom
   * element representing this node.
   */
  readonly element: string;

  /**
   * The instance properties of this element that should be synchronized
   * between the remote and host environments.
   */
  readonly properties?: Record<string, unknown>;

  /**
   * The attributes of the element that should be synchronized between the
   * remote and host environments.
   */
  readonly attributes?: Record<string, string>;

  /**
   * The event listeners that should be synchronized between the remote and
   * host environments.
   */
  readonly eventListeners?: Record<string, (...args: any) => any>;

  /**
   * The list of child nodes of this element.
   */
  readonly children: readonly RemoteNodeSerialization[];
}

/**
 * Represents a text node of a remote tree in a plain JavaScript format.
 */
export interface RemoteTextSerialization {
  /**
   * A unique identifier for the node.
   */
  readonly id: string;

  /**
   * The type of node. This value is always `3` for text nodes.
   */
  readonly type: typeof NODE_TYPE_TEXT;

  /**
   * The text content of the node.
   */
  readonly data: string;
}

/**
 * Represents a comment node of a remote tree in a plain JavaScript format.
 */
export interface RemoteCommentSerialization {
  /**
   * A unique identifier for the node.
   */
  readonly id: string;

  /**
   * The type of node. This value is always `8` for comment nodes.
   */
  readonly type: typeof NODE_TYPE_COMMENT;

  /**
   * The text content of the comment.
   */
  readonly data: string;
}

/**
 * Represents any node that can be synchronized between the host and
 * remote environments.
 */
export type RemoteNodeSerialization =
  | RemoteTextSerialization
  | RemoteCommentSerialization
  | RemoteElementSerialization;



================================================
FILE: packages/core/source/elements/connection.ts
================================================
import type {RemoteConnection, RemoteMutationRecord} from '../types.ts';

/**
 * A wrapper around a `RemoteConnection` that batches mutations. By default, this
 * all calls are flushed in a queued microtask, but this can be customized by passing
 * a custom `batch` option.
 */
export class BatchingRemoteConnection {
  readonly #connection: RemoteConnection;
  #queued: RemoteMutationRecord[] | undefined;
  #batch: (action: () => void) => void;

  constructor(
    connection: RemoteConnection,
    {
      batch = createDefaultBatchFunction(),
    }: {batch?: (action: () => void) => void} = {},
  ) {
    this.#connection = connection;
    this.#batch = batch;
  }

  call(id: string, method: string, ...args: readonly unknown[]) {
    this.#connection.call(id, method, ...args);
  }

  mutate(records: any[]) {
    const queued = this.#queued;

    this.#queued ??= [];
    this.#queued.push(...records);

    if (queued) {
      return;
    }

    this.#batch(() => {
      this.flush();
    });
  }

  flush() {
    if (!this.#queued) {
      return;
    }

    this.#connection.mutate(this.#queued);
    this.#queued = undefined;
  }
}

function createDefaultBatchFunction() {
  let channel: MessageChannel;

  return (queue: () => void) => {
    // In environments without a `MessageChannel`, use a `setTimeout` fallback.
    if (typeof MessageChannel !== 'function') {
      setTimeout(() => {
        queue();
      }, 0);
      return;
    }

    // `MessageChannel` trick that forces the code to run on the next task.
    channel ??= new MessageChannel();
    channel.port1.onmessage = () => {
      queue();
    };
    channel.port2.postMessage(null);
  };
}



================================================
FILE: packages/core/source/elements/internals.ts
================================================
import {
  MUTATION_TYPE_UPDATE_PROPERTY,
  UPDATE_PROPERTY_TYPE_PROPERTY,
  UPDATE_PROPERTY_TYPE_ATTRIBUTE,
  UPDATE_PROPERTY_TYPE_EVENT_LISTENER,
} from '../constants.ts';
import type {RemoteConnection, RemoteNodeSerialization} from '../types.ts';

export const REMOTE_CONNECTIONS = new WeakMap<Node, RemoteConnection>();

/**
 * Gets the `RemoteConnection` instance that a node is connected to. If the node
 * is not connected to a remote root, this method returns `undefined`.
 */
export function remoteConnection(node: Node) {
  return REMOTE_CONNECTIONS.get(node);
}

export const REMOTE_IDS = new WeakMap<Node, string>();
let id = 0;

/**
 * Gets the unique identifier representing a node. If the node does not have
 * a unique identifier, one is created and assigned when calling this method.
 */
export function remoteId(node: Node) {
  let remoteID = REMOTE_IDS.get(node);
  if (remoteID == null) {
    remoteID = String(id++);
    setRemoteId(node, remoteID);
  }

  return remoteID;
}

export function setRemoteId(node: Node, id: string) {
  REMOTE_IDS.set(node, id);
}

export const REMOTE_PROPERTIES = new WeakMap<Node, Record<string, any>>();

/**
 * Gets the remote properties of an element node. If the node is not an element
 * node, this method returns `undefined`, or if it does not have any remote properties,
 * it will return undefined.
 */
export function remoteProperties(node: Node) {
  return REMOTE_PROPERTIES.get(node);
}

export const REMOTE_ATTRIBUTES = new WeakMap<Node, Record<string, string>>();

/**
 * Gets the remote attributes of an element node. If the node is not an element
 * node, this method returns `undefined`. If the element does not have any remote
 * attributes explicitly defined, this method will instead return the `attributes`
 * of the element, converted into a simple object form. This makes it easy for you
 * to represent “standard” HTML elements, such as `<div>` or `<span>`, as remote
 * elements.
 */
export function remoteAttributes(node: Node) {
  let attributes = REMOTE_ATTRIBUTES.get(node);

  if (attributes != null) return attributes;

  // Custom elements are expected to handle their own attribute updates
  if (!(node instanceof Element) || node.tagName.includes('-'))
    return undefined;

  attributes = {};

  for (const {name, value} of node.attributes) {
    attributes[name] = value;
  }

  return attributes;
}

export const REMOTE_EVENT_LISTENERS = new WeakMap<
  Node,
  Record<string, (...args: any) => void>
>();

/**
 * Gets the remote event listeners of an element node. If the node is not an element
 * node, or does not have explicitly defined remote event listeners, this method returns
 * `undefined`.
 */
export function remoteEventListeners(node: Node) {
  return REMOTE_EVENT_LISTENERS.get(node);
}

/**
 * Updates a single remote property on an element node. If the element is
 * connected to a remote root, this function will also make a `mutate()` call
 * to communicate the change to the host.
 */
export function updateRemoteElementProperty(
  node: Element,
  property: string,
  value: unknown,
) {
  let properties = REMOTE_PROPERTIES.get(node);

  if (properties == null) {
    properties = {};
    REMOTE_PROPERTIES.set(node, properties);
  }

  if (properties[property] === value) return;

  properties[property] = value;

  const connection = REMOTE_CONNECTIONS.get(node);

  if (connection == null) return;

  connection.mutate([
    [
      MUTATION_TYPE_UPDATE_PROPERTY,
      remoteId(node),
      property,
      value,
      UPDATE_PROPERTY_TYPE_PROPERTY,
    ],
  ]);
}

/**
 * Updates a single remote attribute on an element node. If the element is
 * connected to a remote root, this function will also make a `mutate()` call
 * to communicate the change to the host.
 */
export function updateRemoteElementAttribute(
  node: Element,
  attribute: string,
  value?: string,
) {
  let attributes = REMOTE_ATTRIBUTES.get(node);

  if (attributes == null) {
    attributes = {};
    REMOTE_ATTRIBUTES.set(node, attributes);
  }

  if (attributes[attribute] === value) return;

  if (value == null) {
    delete attributes[attribute];
  } else {
    attributes[attribute] = String(value);
  }

  const connection = REMOTE_CONNECTIONS.get(node);

  if (connection == null) return;

  connection.mutate([
    [
      MUTATION_TYPE_UPDATE_PROPERTY,
      remoteId(node),
      attribute,
      value,
      UPDATE_PROPERTY_TYPE_ATTRIBUTE,
    ],
  ]);
}

/**
 * Updates a single remote event listener on an element node. If the element is
 * connected to a remote root, this function will also make a `mutate()` call
 * to communicate the change to the host.
 */
export function updateRemoteElementEventListener(
  node: Element,
  event: string,
  listener?: (...args: any[]) => any,
) {
  let eventListeners = REMOTE_EVENT_LISTENERS.get(node);

  if (eventListeners == null) {
    eventListeners = {};
    REMOTE_EVENT_LISTENERS.set(node, eventListeners);
  }

  if (eventListeners[event] === listener) return;

  if (listener == null) {
    delete eventListeners[event];
  } else {
    eventListeners[event] = listener;
  }

  const connection = REMOTE_CONNECTIONS.get(node);

  if (connection == null) return;

  connection.mutate([
    [
      MUTATION_TYPE_UPDATE_PROPERTY,
      remoteId(node),
      event,
      listener,
      UPDATE_PROPERTY_TYPE_EVENT_LISTENER,
    ],
  ]);
}

/**
 * Connects a node to a `RemoteConnection` instance. Any future updates to this node
 * will be communicated to the host by way of this connection.
 */
export function connectRemoteNode(node: Node, connection: RemoteConnection) {
  const existingConnection = REMOTE_CONNECTIONS.get(node);

  if (existingConnection === connection) return;

  REMOTE_CONNECTIONS.set(node, connection);

  if (node.childNodes) {
    for (let i = 0; i < node.childNodes.length; i++) {
      connectRemoteNode(node.childNodes[i]!, connection);
    }
  }
}

/**
 * Disconnects a node from its `RemoteConnection` instance. Future updates to this
 * this element will not be communicated to a host, until you call `connectRemoteNode` again.
 */
export function disconnectRemoteNode(node: Node) {
  const existingConnection = REMOTE_CONNECTIONS.get(node);

  if (existingConnection == null) return;

  REMOTE_CONNECTIONS.delete(node);

  if (node.childNodes) {
    for (let i = 0; i < node.childNodes.length; i++) {
      disconnectRemoteNode(node.childNodes[i]!);
    }
  }
}

/**
 * Converts an HTML Node into a simple JavaScript object, in the shape that
 * `RemoteConnection.mutate()` expects to receive.
 */
export function serializeRemoteNode(node: Node): RemoteNodeSerialization {
  const {nodeType} = node;

  switch (nodeType) {
    // Element
    case 1: {
      return {
        id: remoteId(node),
        type: nodeType,
        element: (node as Element).localName,
        properties: cloneMaybeObject(remoteProperties(node)),
        attributes: cloneMaybeObject(remoteAttributes(node)),
        eventListeners: cloneMaybeObject(remoteEventListeners(node)),
        children: Array.from(node.childNodes).map(serializeRemoteNode),
      };
    }
    // TextNode
    case 3:
    // Comment
    // eslint-disable-next-line no-fallthrough
    case 8: {
      return {
        id: remoteId(node),
        type: nodeType,
        data: (node as Text | Comment).data,
      };
    }
    default: {
      throw new Error(
        `Cannot serialize node of type ${
          node.nodeType
        } (${typeof node.nodeType})`,
      );
    }
  }
}

function cloneMaybeObject<T>(maybeObject?: T): T | undefined {
  return maybeObject ? {...maybeObject} : undefined;
}

/**
 * Performs a method through `RemoteConnection.call()`, using the remote ID and
 * connection for the provided node.
 */
export function callRemoteElementMethod(
  node: Element,
  method: string,
  ...args: unknown[]
) {
  const id = REMOTE_IDS.get(node);
  const connection = REMOTE_CONNECTIONS.get(node);

  if (id == null || connection == null) {
    throw new Error(`Cannot call method ${method} on an unconnected node`);
  }

  return connection.call(id, method, ...args);
}



================================================
FILE: packages/core/source/elements/RemoteElement.ts
================================================
import {RemoteEvent} from './RemoteEvent.ts';
import {
  updateRemoteElementProperty,
  updateRemoteElementAttribute,
  updateRemoteElementEventListener,
  callRemoteElementMethod,
  remoteProperties as getRemoteProperties,
  remoteEventListeners as getRemoteEventListeners,
} from './internals.ts';
import type {
  RemoteElementAttributeDefinition,
  RemoteElementEventListenerDefinition,
  RemoteElementEventListenersDefinition,
  RemoteElementPropertiesDefinition,
  RemoteElementPropertyDefinition,
  RemoteElementPropertyType,
  RemoteElementPropertyTypeOrBuiltIn,
  RemoteElementSlotsDefinition,
  RemoteElementSlotDefinition,
} from './types.ts';

/**
 * A class that represents a remote custom element, which can have properties,
 * attributes, event listeners, methods, and slots that are synchronized with
 * a host environment.
 */
export type RemoteElementConstructor<
  Properties extends Record<string, any> = {},
  Methods extends Record<string, (...args: any[]) => any> = {},
  Slots extends Record<string, any> = {},
  EventListeners extends Record<string, any> = {},
> = {
  new (): RemoteElement<Properties, Methods, Slots, EventListeners> &
    Properties &
    Methods;

  /**
   * The slots that can be populated on this remote element.
   */
  readonly remoteSlots?:
    | RemoteElementSlotsDefinition<Slots>
    | readonly (keyof Slots)[];

  /**
   * The resolved slot definitions for this remote element.
   */
  readonly remoteSlotDefinitions: Map<string, RemoteElementSlotDefinition>;

  /**
   * The properties that can be synchronized between this remote element and
   * its host representation.
   */
  readonly remoteProperties?:
    | RemoteElementPropertiesDefinition<Properties>
    | readonly (keyof Properties)[];

  /**
   * The resolved property definitions for this remote element.
   */
  readonly remotePropertyDefinitions: Map<
    string,
    RemoteElementPropertyNormalizedDefinition
  >;

  /**
   * Creates a new definition for a property that will be synchronized between
   * this remote element and its host representation.
   */
  createProperty<Value = unknown>(
    name: string,
    definition?: RemoteElementPropertyDefinition<Value>,
  ): void;

  /**
   * The attributes that can be synchronized between this remote element and
   * its host representation.
   */
  readonly remoteAttributes?: readonly string[];

  /**
   * The resolved attribute definitions for this remote element.
   */
  readonly remoteAttributeDefinitions: Map<
    string,
    RemoteElementAttributeDefinition
  >;

  /**
   * The event listeners that can be synchronized between this remote element
   * and its host representation.
   */
  readonly remoteEvents?:
    | RemoteElementEventListenersDefinition<EventListeners>
    | readonly (keyof EventListeners)[];

  /**
   * The resolved event listener definitions for this remote element.
   */
  readonly remoteEventDefinitions: Map<
    string,
    RemoteElementEventListenerDefinition
  >;

  /**
   * The methods on the corresponding host element that you can call from the remote
   * environment.
   */
  readonly remoteMethods?: Methods | readonly (keyof Methods)[];
};

/**
 * Returns the properties type from a remote element constructor.
 */
export type RemotePropertiesFromElementConstructor<T> = T extends {
  new (): RemoteElement<infer Properties, any, any, any>;
}
  ? Properties
  : never;

/**
 * Returns the methods type from a remote element constructor.
 */
export type RemoteMethodsFromElementConstructor<T> = T extends {
  new (): RemoteElement<any, infer Methods, any, any>;
}
  ? Methods
  : never;

/**
 * Returns the slots type from a remote element constructor.
 */
export type RemoteSlotsFromElementConstructor<T> = T extends {
  new (): RemoteElement<any, any, infer Slots, any>;
}
  ? Slots
  : never;

/**
 * Returns the event listeners type from a remote element constructor.
 */
export type RemoteEventListenersFromElementConstructor<T> = T extends {
  new (): RemoteElement<any, any, any, infer EventListeners>;
}
  ? EventListeners
  : never;

/**
 * Options that can be passed when creating a new remote element class with
 * `createRemoteElement()`.
 */
export interface RemoteElementCreatorOptions<
  Properties extends Record<string, any> = {},
  Methods extends Record<string, any> = {},
  Slots extends Record<string, any> = {},
  EventListeners extends Record<string, any> = {},
> {
  /**
   * The slots that can be populated on this remote element.
   */
  slots?: RemoteElementConstructor<
    Properties,
    Methods,
    Slots,
    EventListeners
  >['remoteSlots'];

  /**
   * The properties that can be synchronized between this remote element and
   * its host representation.
   */
  properties?: RemoteElementConstructor<
    Properties,
    Methods,
    Slots,
    EventListeners
  >['remoteProperties'];

  /**
   * The attributes that can be synchronized between this remote element and
   * its host representation.
   */
  attributes?: RemoteElementConstructor<
    Properties,
    Methods,
    Slots,
    EventListeners
  >['remoteAttributes'];

  /**
   * The event listeners that can be synchronized between this remote element
   * and its host representation.
   */
  events?: RemoteElementConstructor<
    Properties,
    Methods,
    Slots,
    EventListeners
  >['remoteEvents'];

  /**
   * The methods on the corresponding host element that you can call from the remote
   * environment.
   */
  methods?: RemoteElementConstructor<
    Properties,
    Methods,
    Slots,
    EventListeners
  >['remoteMethods'];
}

const EMPTY_DEFINITION = Object.freeze({});

export function createRemoteElement<
  Properties extends Record<string, any> = {},
  Methods extends Record<string, any> = {},
  Slots extends Record<string, any> = {},
  EventListeners extends Record<string, any> = {},
>({
  slots,
  properties,
  attributes,
  events,
  methods,
}: NoInfer<
  RemoteElementCreatorOptions<Properties, Methods, Slots, EventListeners>
> = {}): RemoteElementConstructor<Properties, Methods, Slots, EventListeners> {
  const RemoteElementConstructor = class extends RemoteElement<
    Properties,
    Methods,
    Slots,
    EventListeners
  > {
    static readonly remoteSlots = slots;
    static readonly remoteProperties = properties;
    static readonly remoteAttributes = attributes;
    static readonly remoteEvents = events;
    static readonly remoteMethods = methods;
  } as any;

  return RemoteElementConstructor;
}

// Heavily inspired by https://github.com/lit/lit/blob/343187b1acbbdb02ce8d01fa0a0d326870419763/packages/reactive-element/src/reactive-element.ts

/**
 * A base class for creating “remote” HTML elements, which have properties, attributes,
 * event listeners, slots, and methods that can be synchronized between a host and
 * remote environment. When subclassing `RemoteElement`, you can define how different fields
 * in the class will be synchronized by defining the `remoteProperties`, `remoteAttributes`,
 * `remoteEvents`, and/or `remoteMethods` static properties.
 *
 * @example
 * ```ts
 * class CustomButton extends RemoteElement {
 *   static remoteAttributes = ['disabled', 'primary'];
 *   static remoteEvents = ['click'];
 *
 *   focus() {
 *     console.log('Calling focus in the remote environment...');
 *     return this.callRemoteMethod('focus');
 *   }
 * }
 * ```
 */
export abstract class RemoteElement<
  Properties extends Record<string, any> = {},
  Methods extends Record<string, (...args: any[]) => any> = {},
  Slots extends Record<string, any> = {},
  EventListeners extends Record<string, any> = {},
> extends HTMLElement {
  static readonly slottable = true;

  static readonly remoteSlots?: any;
  static readonly remoteProperties?: any;
  static readonly remoteAttributes?: any;
  static readonly remoteEvents?: any;
  static readonly remoteMethods?: any;

  static get observedAttributes() {
    return this.finalize().__observedAttributes;
  }

  /**
   * The resolved property definitions for this remote element.
   */
  static get remotePropertyDefinitions(): Map<
    string,
    RemoteElementPropertyNormalizedDefinition
  > {
    return this.finalize().__remotePropertyDefinitions;
  }

  /**
   * The resolved attribute definitions for this remote element.
   */
  static get remoteAttributeDefinitions(): Map<
    string,
    RemoteElementAttributeDefinition
  > {
    return this.finalize().__remoteAttributeDefinitions;
  }

  /**
   * The resolved event listener definitions for this remote element.
   */
  static get remoteEventDefinitions(): Map<
    string,
    RemoteElementEventListenerDefinition
  > {
    return this.finalize().__remoteEventDefinitions;
  }

  /**
   * The resolved slot definitions for this remote element.
   */
  static get remoteSlotDefinitions(): Map<string, RemoteElementSlotDefinition> {
    return this.finalize().__remoteSlotDefinitions;
  }

  protected static __finalized = true;
  private static readonly __observedAttributes: string[] = [];
  private static readonly __attributeToPropertyMap = new Map<string, string>();
  private static readonly __eventToPropertyMap = new Map<string, string>();
  private static readonly __remotePropertyDefinitions = new Map<
    string,
    RemoteElementPropertyNormalizedDefinition
  >();
  private static readonly __remoteAttributeDefinitions = new Map<
    string,
    RemoteElementAttributeDefinition
  >();
  private static readonly __remoteEventDefinitions = new Map<
    string,
    RemoteElementEventListenerDefinition
  >();
  private static readonly __remoteSlotDefinitions = new Map<
    string,
    RemoteElementSlotDefinition
  >();

  /**
   * Creates a new definition for a property that will be synchronized between
   * this remote element and its host representation.
   */
  static createProperty<Value = unknown>(
    name: string,
    definition?: RemoteElementPropertyDefinition<Value>,
  ) {
    saveRemoteProperty(
      name,
      definition,
      this.observedAttributes,
      this.remotePropertyDefinitions,
      this.__attributeToPropertyMap,
      this.__eventToPropertyMap,
    );
  }

  /**
   * Consumes all the static members defined on the class and converts them
   * into the internal representation used to handle properties, attributes,
   * and event listeners.
   */
  protected static finalize(): typeof this {
    // eslint-disable-next-line no-prototype-builtins
    if (this.hasOwnProperty('__finalized')) {
      return this;
    }

    this.__finalized = true;
    const {
      slottable,
      remoteSlots,
      remoteProperties,
      remoteAttributes,
      remoteEvents,
      remoteMethods,
    } = this;

    // finalize any superclasses
    const SuperConstructor = Object.getPrototypeOf(
      this,
    ) as typeof RemoteElement;

    const observedAttributes = new Set<string>();
    if (slottable) observedAttributes.add('slot');

    const attributeToPropertyMap = new Map<string, string>();
    const eventToPropertyMap = new Map<string, string>();
    const remoteSlotDefinitions = new Map<
      string,
      RemoteElementSlotDefinition
    >();
    const remotePropertyDefinitions = new Map<
      string,
      RemoteElementPropertyNormalizedDefinition
    >();
    const remoteAttributeDefinitions = new Map<
      string,
      RemoteElementAttributeDefinition
    >();
    const remoteEventDefinitions = new Map<
      string,
      RemoteElementEventListenerDefinition
    >();

    if (typeof SuperConstructor.finalize === 'function') {
      SuperConstructor.finalize();

      SuperConstructor.observedAttributes.forEach((attribute) => {
        observedAttributes.add(attribute);
      });

      SuperConstructor.remotePropertyDefinitions.forEach(
        (definition, property) => {
          remotePropertyDefinitions.set(property, definition);
        },
      );

      SuperConstructor.remoteAttributeDefinitions.forEach(
        (definition, event) => {
          remoteAttributeDefinitions.set(event, definition);
        },
      );

      SuperConstructor.remoteEventDefinitions.forEach((definition, event) => {
        remoteEventDefinitions.set(event, definition);
      });

      SuperConstructor.remoteSlotDefinitions.forEach((definition, slot) => {
        remoteSlotDefinitions.set(slot, definition);
      });
    }

    if (remoteSlots != null) {
      const slotNames = Array.isArray(remoteSlots)
        ? remoteSlots
        : Object.keys(remoteSlots);

      slotNames.forEach((slotName) => {
        remoteSlotDefinitions.set(slotName, EMPTY_DEFINITION);
      });
    }

    if (remoteProperties != null) {
      if (Array.isArray(remoteProperties)) {
        remoteProperties.forEach((propertyName) => {
          saveRemoteProperty(
            propertyName,
            undefined,
            observedAttributes,
            remotePropertyDefinitions,
            attributeToPropertyMap,
            eventToPropertyMap,
          );
        });
      } else {
        Object.keys(remoteProperties).forEach((propertyName) => {
          saveRemoteProperty(
            propertyName,
            (remoteProperties as any)[propertyName],
            observedAttributes,
            remotePropertyDefinitions,
            attributeToPropertyMap,
            eventToPropertyMap,
          );
        });
      }
    }

    if (remoteAttributes != null) {
      remoteAttributes.forEach((attribute: string) => {
        remoteAttributeDefinitions.set(attribute, EMPTY_DEFINITION);
        observedAttributes.add(attribute);
      });
    }

    if (remoteEvents != null) {
      if (Array.isArray(remoteEvents)) {
        remoteEvents.forEach((event: string) => {
          remoteEventDefinitions.set(event, EMPTY_DEFINITION);
        });
      } else {
        Object.keys(remoteEvents).forEach((event) => {
          remoteEventDefinitions.set(event, remoteEvents[event]);
        });
      }
    }

    if (remoteMethods != null) {
      if (Array.isArray(remoteMethods)) {
        for (const method of remoteMethods) {
          // @ts-expect-error We are dynamically defining methods, which TypeScript can’t
          // really keep track of.
          this.prototype[method] = function (
            this: RemoteElement,
            ...args: any[]
          ) {
            return this.callRemoteMethod(method, ...args);
          };
        }
      } else {
        Object.assign(this, remoteMethods);
      }
    }

    Object.defineProperties(this, {
      __observedAttributes: {
        value: [...observedAttributes],
        enumerable: false,
      },
      __remoteSlotDefinitions: {
        value: remoteSlotDefinitions,
        enumerable: false,
      },
      __remotePropertyDefinitions: {
        value: remotePropertyDefinitions,
        enumerable: false,
      },
      __remoteAttributeDefinitions: {
        value: remoteAttributeDefinitions,
        enumerable: false,
      },
      __remoteEventDefinitions: {
        value: remoteEventDefinitions,
        enumerable: false,
      },
      __attributeToPropertyMap: {
        value: attributeToPropertyMap,
        enumerable: false,
      },
      __eventToPropertyMap: {
        value: eventToPropertyMap,
        enumerable: false,
      },
    });

    return this;
  }

  // Just need to use these types so TS doesn’t lose track of them.
  /** @internal */
  __slots?: Slots;

  /** @internal */
  __properties?: Properties;

  /** @internal */
  __methods?: Methods;

  /** @internal */
  __eventListeners?: EventListeners;

  constructor() {
    super();
    (this.constructor as typeof RemoteElement).finalize();

    const propertyDescriptors: PropertyDescriptorMap = {};
    const initialPropertiesToSet: Record<string, any> = {};

    const prototype = Object.getPrototypeOf(this);
    const ThisClass = this.constructor as typeof RemoteElement;

    for (const [
      property,
      description,
    ] of ThisClass.remotePropertyDefinitions.entries()) {
      const aliasedName = description.name;

      // Don’t override actual accessors. This is handled by the
      // `remoteProperty()` decorator applied to the accessor.
      // eslint-disable-next-line no-prototype-builtins
      if (prototype.hasOwnProperty(property)) {
        continue;
      }

      if (property === aliasedName) {
        initialPropertiesToSet[property] = description.default;
      }

      const propertyDescriptor = {
        configurable: true,
        enumerable: property === aliasedName,
        get: () => {
          return getRemoteProperties(this)?.[aliasedName];
        },
        set: (value: any) => {
          updateRemoteElementProperty(this, aliasedName, value);
        },
      };

      propertyDescriptors[property] = propertyDescriptor;
    }

    for (const [
      event,
      definition,
    ] of ThisClass.remoteEventDefinitions.entries()) {
      const propertyFromDefinition = definition.property ?? true;

      if (!propertyFromDefinition) continue;

      const property =
        propertyFromDefinition === true ? `on${event}` : propertyFromDefinition;

      propertyDescriptors[property] = {
        configurable: true,
        enumerable: true,
        get: () => {
          return getRemoteEvents(this).properties.get(property) ?? null;
        },
        set: (value: any) => {
          const remoteEvents = getRemoteEvents(this);
          const currentListener = remoteEvents.properties.get(property);

          if (typeof value === 'function') {
            // Wrapping this in a custom function so you can’t call `removeEventListener`
            // on it.
            function handler(this: any, ...args: any[]) {
              return value.call(this, ...args);
            }

            remoteEvents.properties.set(property, handler);
            this.addEventListener(event, handler);
          } else {
            remoteEvents.properties.delete(property);
          }

          if (currentListener) {
            this.removeEventListener(event, currentListener);
          }
        },
      };
    }

    Object.defineProperties(this, propertyDescriptors);
    Object.assign(this, initialPropertiesToSet);
  }

  attributeChangedCallback(attribute: string, _oldValue: any, newValue: any) {
    if (
      attribute === 'slot' &&
      (this.constructor as typeof RemoteElement).slottable
    ) {
      updateRemoteElementAttribute(
        this,
        attribute,
        newValue ? String(newValue) : undefined,
      );

      return;
    }

    const {
      remotePropertyDefinitions,
      remoteAttributeDefinitions,
      __attributeToPropertyMap: attributeToPropertyMap,
    } = this.constructor as typeof RemoteElement;

    if (remoteAttributeDefinitions.has(attribute)) {
      updateRemoteElementAttribute(this, attribute, newValue);
      return;
    }

    const property = attributeToPropertyMap.get(attribute);

    const propertyDefinition =
      property == null ? property : remotePropertyDefinitions.get(property);

    if (propertyDefinition == null) return;

    (this as any)[property!] = convertAttributeValueToProperty(
      newValue,
      propertyDefinition.type,
    );
  }

  connectedCallback() {
    // Ensure a connection is made with the host environment, so that
    // the event will be emitted even if no listener is directly attached
    // to this element.
    for (const [event, descriptor] of (
      this.constructor as typeof RemoteElement
    ).remoteEventDefinitions.entries()) {
      if (descriptor.bubbles) {
        this.addEventListener(event, noopBubblesEventListener);
      }
    }
  }

  disconnectedCallback() {
    for (const [event, descriptor] of (
      this.constructor as typeof RemoteElement
    ).remoteEventDefinitions.entries()) {
      if (descriptor.bubbles) {
        this.removeEventListener(event, noopBubblesEventListener);
      }
    }
  }

  addEventListener(
    type: string,
    listener:
      | ((event: RemoteEvent) => void)
      | {handleEvent: (event: RemoteEvent) => void}
      | null,
    options?: boolean | AddEventListenerOptions,
  ): void;
  addEventListener(
    type: string,
    listener: EventListenerOrEventListenerObject,
    options?: boolean | AddEventListenerOptions,
  ) {
    const {remoteEventDefinitions, __eventToPropertyMap: eventToPropertyMap} =
      this.constructor as typeof RemoteElement;

    const listenerDefinition = remoteEventDefinitions.get(type);
    const property = eventToPropertyMap.get(type);

    if (listenerDefinition == null && property == null) {
      return super.addEventListener(type, listener, options);
    }

    const remoteEvents = getRemoteEvents(this);
    const remoteEvent = getRemoteEventRecord.call(this, type, {
      property,
      definition: listenerDefinition,
    });

    const normalizedListener =
      typeof options === 'object' && options?.once
        ? (...args: Parameters<EventListener>) => {
            const result =
              typeof listener === 'object'
                ? listener.handleEvent(...args)
                : listener.call(this, ...args);
            removeRemoteListener.call(this, type, listener, listenerRecord);
            return result;
          }
        : listener;

    const listenerRecord: RemoteEventListenerRecord = [
      normalizedListener,
      remoteEvent,
    ];

    remoteEvent.listeners.add(listener);
    remoteEvents.listeners.set(listener, listenerRecord);

    super.addEventListener(type, normalizedListener, options);

    if (typeof options === 'object' && options.signal) {
      options.signal.addEventListener(
        'abort',
        () => {
          removeRemoteListener.call(this, type, listener, listenerRecord);
        },
        {once: true},
      );
    }

    if (listenerDefinition) {
      updateRemoteElementEventListener(this, type, remoteEvent.dispatch);
    } else {
      updateRemoteElementProperty(this, property!, remoteEvent.dispatch);
    }
  }

  removeEventListener(
    type: string,
    listener: EventListenerOrEventListenerObject,
    options?: boolean | EventListenerOptions,
  ) {
    const listenerRecord = REMOTE_EVENTS.get(this)?.listeners.get(listener);
    const normalizedListener = listenerRecord ? listenerRecord[0] : listener;

    super.removeEventListener(type, normalizedListener, options);

    if (listenerRecord == null) return;

    removeRemoteListener.call(this, type, listener, listenerRecord);
  }

  /**
   * Updates a single remote property on an element node. If the element is
   * connected to a remote root, this function will also make a `mutate()` call
   * to communicate the change to the host.
   */
  updateRemoteProperty(name: string, value?: unknown) {
    updateRemoteElementProperty(this, name, value);
  }

  /**
   * Updates a single remote attribute on an element node. If the element is
   * connected to a remote root, this function will also make a `mutate()` call
   * to communicate the change to the host.
   */
  updateRemoteAttribute(name: string, value?: string) {
    updateRemoteElementAttribute(this, name, value);
  }

  /**
   * Performs a method through `RemoteConnection.call()`, using the remote ID and
   * connection for the provided node.
   */
  callRemoteMethod(method: string, ...args: any[]) {
    return callRemoteElementMethod(this, method, ...args);
  }
}

// Utilities

interface RemoteElementPropertyNormalizedDefinition<Value = unknown> {
  name: string;
  type: RemoteElementPropertyTypeOrBuiltIn<Value>;
  alias?: string[];
  event?: string;
  attribute?: string;
  default?: Value;
}

const REMOTE_EVENTS = new WeakMap<
  RemoteElement<any, any, any, any>,
  RemoteElementEventCache
>();

interface RemoteElementEventCache {
  readonly events: Map<string, RemoteEventRecord>;
  readonly properties: Map<string, ((event: any) => void) | null>;
  readonly listeners: WeakMap<
    EventListenerOrEventListenerObject,
    RemoteEventListenerRecord
  >;
}

interface RemoteEventRecord {
  readonly name: string;
  readonly property?: string;
  readonly definition?: RemoteElementEventListenerDefinition;
  readonly listeners: Set<EventListenerOrEventListenerObject>;
  dispatch(...args: any[]): unknown;
}

type RemoteEventListenerRecord = [
  EventListenerOrEventListenerObject,
  RemoteEventRecord,
];

function getRemoteEvents(element: RemoteElement<any, any, any, any>): {
  events: Map<string, RemoteEventRecord>;
  properties: Map<string, ((event: any) => void) | null>;
  listeners: WeakMap<
    EventListenerOrEventListenerObject,
    RemoteEventListenerRecord
  >;
} {
  let events = REMOTE_EVENTS.get(element);

  if (events) return events;

  events = {
    events: new Map(),
    properties: new Map(),
    listeners: new WeakMap(),
  };

  REMOTE_EVENTS.set(element, events);

  return events;
}

function getRemoteEventRecord(
  this: RemoteElement<any, any, any, any>,
  type: string,
  {property, definition}: Pick<RemoteEventRecord, 'property' | 'definition'>,
) {
  const remoteEvents = getRemoteEvents(this);

  let remoteEvent = remoteEvents.events.get(type);
  if (remoteEvent == null) {
    remoteEvent = {
      name: type,
      property,
      definition,
      listeners: new Set(),
      dispatch: (...args: any[]) => {
        const event =
          definition?.dispatchEvent?.apply(this, args) ??
          new RemoteEvent(type, {
            detail: args[0],
            bubbles: definition?.bubbles,
          });

        this.dispatchEvent(event);

        return (event as any).response;
      },
    };

    remoteEvents.events.set(type, remoteEvent);
  }

  return remoteEvent;
}

function removeRemoteListener(
  this: RemoteElement<any, any, any, any>,
  type: string,
  listener: EventListenerOrEventListenerObject,
  listenerRecord: RemoteEventListenerRecord,
) {
  const remoteEvents = getRemoteEvents(this);

  const remoteEvent = listenerRecord[1];
  remoteEvent.listeners.delete(listener);
  remoteEvents.listeners.delete(listener);

  if (remoteEvent.listeners.size > 0) return;

  remoteEvents.events.delete(type);

  if (remoteEvent.property) {
    if (
      getRemoteProperties(this)?.[remoteEvent.property] === remoteEvent.dispatch
    ) {
      updateRemoteElementProperty(this, remoteEvent.property, undefined);
    }
  } else {
    if (getRemoteEventListeners(this)?.[type] === remoteEvent.dispatch) {
      updateRemoteElementEventListener(this, type, undefined);
    }
  }
}

function saveRemoteProperty<Value = unknown>(
  name: string,
  description: RemoteElementPropertyDefinition<Value> | undefined,
  observedAttributes: Set<string> | string[],
  remotePropertyDefinitions: Map<
    string,
    RemoteElementPropertyNormalizedDefinition
  >,
  attributeToPropertyMap: Map<string, string>,
  eventToPropertyMap: Map<string, string>,
) {
  if (remotePropertyDefinitions.has(name)) {
    return remotePropertyDefinitions.get(name)!;
  }

  const looksLikeEventCallback = name[0] === 'o' && name[1] === 'n';

  const resolvedDescription =
    description ?? ({} as RemoteElementPropertyDefinition<Value>);
  let {alias} = resolvedDescription;
  const {
    type = looksLikeEventCallback ? Function : String,
    attribute = type !== Function,
    event = looksLikeEventCallback,
    default: defaultValue = type === Boolean ? false : undefined,
  } = resolvedDescription;

  if (alias == null) {
    // Svelte lowercases property names before assigning them to elements,
    // this ensures that those properties are forwarded to their canonical
    // names.
    const lowercaseProperty = name.toLowerCase();
    if (lowercaseProperty !== name) {
      alias = [lowercaseProperty];
    }

    // Preact (and others) automatically treat properties that start with
    // `on` as being event listeners, and uses an actual event listener for
    // them. This alias gives wrapping components an alternative property
    // to write to that won't be treated as an event listener.
    if (looksLikeEventCallback) {
      alias ??= [];
      alias.unshift(`_${name}`);
    }
  }

  let attributeName: string | undefined;

  if (attribute === true) {
    attributeName = camelToKebabCase(name);
  } else if (typeof attribute === 'string') {
    attributeName = attribute;
  }

  if (attributeName) {
    if (Array.isArray(observedAttributes)) {
      observedAttributes.push(attributeName);
    } else {
      observedAttributes.add(attributeName);
    }

    attributeToPropertyMap.set(attributeName, name);
  }

  let eventName: string | undefined;

  if (event === true) {
    eventName = camelToKebabCase(looksLikeEventCallback ? name.slice(2) : name);
  } else if (typeof event === 'string') {
    eventName = event;
  }

  if (eventName) {
    eventToPropertyMap.set(eventName, name);
  }

  const definition: RemoteElementPropertyNormalizedDefinition = {
    name,
    type,
    alias,
    event: eventName,
    attribute: attributeName,
    default: defaultValue,
  };

  remotePropertyDefinitions.set(name, definition);

  if (alias) {
    for (const propertyAlias of alias) {
      remotePropertyDefinitions.set(propertyAlias, definition);
    }
  }

  return definition;
}

function convertAttributeValueToProperty<Value = unknown>(
  value: string | null,
  type: RemoteElementPropertyTypeOrBuiltIn<Value>,
) {
  if (value == null) return undefined;

  switch (type) {
    case Boolean:
      return value != null && value !== 'false';
    case Object:
    case Array:
      try {
        return JSON.parse(value);
      } catch {
        return undefined;
      }
    case String:
      return String(value);
    case Number:
      return Number.parseFloat(value);
    case Function:
      return undefined;
    default: {
      return (type as RemoteElementPropertyType<Value>).parse?.(value);
    }
  }
}

function camelToKebabCase(str: string) {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}

function noopBubblesEventListener() {}



================================================
FILE: packages/core/source/elements/RemoteEvent.ts
================================================
/**
 * An event class that is used to store and return a potentially-asynchronous
 * result as part of a remote property call. Remote DOM uses this class to convert
 * a remote property call into event listeners on the `RemoteElement` custom
 * element base class.
 */
export class RemoteEvent<
  Detail = unknown,
  Response = unknown,
> extends CustomEvent<Detail> {
  /**
   * The last value received from a `respondWith()` call.
   */
  readonly response?: Response;

  /**
   * Provides the `response` value to be sent as the return value for
   * the remote property function that triggered this event.
   */
  respondWith(response: Response) {
    (this as any).response = response;
  }
}



================================================
FILE: packages/core/source/elements/RemoteFragmentElement.ts
================================================
import {RemoteElement} from './RemoteElement';

/**
 * A custom element that can be used as the `remote-fragment` element in a remote
 * environment, which is used by a number of Remote DOM libraries to represent
 * cases where multiple sibling elements are returned.
 */
export class RemoteFragmentElement extends RemoteElement {}



================================================
FILE: packages/core/source/elements/RemoteMutationObserver.ts
================================================
import {
  remoteId,
  setRemoteId,
  connectRemoteNode,
  disconnectRemoteNode,
  serializeRemoteNode,
} from './internals.ts';
import {
  ROOT_ID,
  MUTATION_TYPE_INSERT_CHILD,
  MUTATION_TYPE_REMOVE_CHILD,
  MUTATION_TYPE_UPDATE_TEXT,
  MUTATION_TYPE_UPDATE_PROPERTY,
} from '../constants.ts';
import type {RemoteConnection, RemoteMutationRecord} from '../types.ts';

/**
 * Builds on the browser’s [`MutationObserver`](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)
 * to detect changes in a remote element, and to communicate those changes in a way
 * that Remote DOM can understand. You create this object from a “remote
 * connection”, which you’ll generally get from the [`@remote-dom/core/receiver`](/packages/core#remote-domcorereceiver)
 * package. Then, you’ll observe changes in the HTML element that contains your
 * tree of remote elements.
 *
 * @example
 * import {RemoteMutationObserver} from '@remote-dom/core/elements';
 *
 * const observer = new RemoteMutationObserver(connection);
 *
 * // Now, any changes to the `body` element will be communicated
 * // to the host environment.
 * observer.observe(document.body);
 */
export class RemoteMutationObserver extends MutationObserver {
  readonly connection: RemoteConnection;
  readonly #observed: Set<Node>;

  constructor(connection: RemoteConnection) {
    super((records) => {
      const addedNodes: Node[] = [];
      const remoteRecords: RemoteMutationRecord[] = [];

      for (const record of records) {
        const targetId = remoteId(record.target);

        if (record.type === 'childList') {
          const position = record.previousSibling
            ? indexOf(record.previousSibling, record.target.childNodes) + 1
            : 0;

          record.removedNodes.forEach((node) => {
            disconnectRemoteNode(node);

            remoteRecords.push([
              MUTATION_TYPE_REMOVE_CHILD,
              targetId,
              position,
            ]);
          });

          // A mutation observer will queue some changes, so we might get one record
          // for attaching a parent element, and additional records for attaching descendants.
          // We serialize the entire tree when a new node was added, so we don’t want to
          // send additional “insert child” records when we see those descendants — they
          // will already be included the insertion of the parent.
          record.addedNodes.forEach((node, index) => {
            if (
              addedNodes.some((addedNode) => {
                return addedNode === node || addedNode.contains(node);
              })
            ) {
              return;
            }

            addedNodes.push(node);
            connectRemoteNode(node, connection);

            remoteRecords.push([
              MUTATION_TYPE_INSERT_CHILD,
              targetId,
              serializeRemoteNode(node),
              position + index,
            ]);
          });
        } else if (record.type === 'characterData') {
          remoteRecords.push([
            MUTATION_TYPE_UPDATE_TEXT,
            targetId,
            record.target.textContent ?? '',
          ]);
        } else if (
          record.type === 'attributes' &&
          record.attributeName != null &&
          record.target instanceof Element &&
          !record.target.tagName.includes('-')
        ) {
          remoteRecords.push([
            MUTATION_TYPE_UPDATE_PROPERTY,
            targetId,
            record.attributeName,
            (record.target as Element).getAttribute(record.attributeName),
          ]);
        }
      }

      connection.mutate(remoteRecords);
    });

    this.connection = connection;
    this.#observed = new Set();
  }

  /**
   * Starts watching changes to the element, and communicates changes to the
   * host environment. By default, this method will also communicate any initial
   * children of the element to the host environment.
   */
  observe(
    target: Node,
    options?: MutationObserverInit & {
      /**
       * The ID of the root element. If you do not provide an ID, a default value
       * considered to be the “root” element will be used. This means that its remote
       * attributes, properties, event listeners, and children will all be sent as the root
       * element to the remote receiver.
       *
       * You need to override the default behavior if you are wanting to observe a set of
       * nodes, and send each of them to the remote receiver. This may be needed when observing
       * a `DocumentFragment` or `<template>` element, which allow for multiple children.
       */
      id?: string;

      /**
       * Whether to send the initial state of the tree to the mutation
       * callback.
       *
       * @default true
       */
      initial?: boolean;
    },
  ) {
    const id = options?.id ?? ROOT_ID;
    setRemoteId(target, id);
    this.#observed.add(target);

    if (options?.initial !== false && target.childNodes.length > 0) {
      if (id !== ROOT_ID) {
        this.connection.mutate([
          [
            MUTATION_TYPE_INSERT_CHILD,
            ROOT_ID,
            serializeRemoteNode(target),
            this.#observed.size - 1,
          ],
        ]);
      } else if (target.childNodes.length > 0) {
        const records: RemoteMutationRecord[] = [];

        for (let i = 0; i < target.childNodes.length; i++) {
          const node = target.childNodes[i]!;
          connectRemoteNode(node, this.connection);

          records.push([
            MUTATION_TYPE_INSERT_CHILD,
            ROOT_ID,
            serializeRemoteNode(node),
            i,
          ]);
        }

        this.connection.mutate(records);
      }
    }

    super.observe(target, {
      subtree: true,
      childList: true,
      attributes: true,
      characterData: true,
      ...options,
    });
  }

  disconnect({empty = false}: {empty?: boolean} = {}) {
    if (empty && this.#observed.size > 0) {
      const records: RemoteMutationRecord[] = [];

      for (const node of this.#observed) {
        disconnectRemoteNode(node);
        const id = remoteId(node);

        if (id === ROOT_ID) {
          for (let i = 0; i < node.childNodes.length; i++) {
            records.push([MUTATION_TYPE_REMOVE_CHILD, id, 0]);
          }
        } else {
          records.push([MUTATION_TYPE_REMOVE_CHILD, ROOT_ID, 0]);
        }
      }

      this.connection.mutate(records);
    }

    this.#observed.clear();
    super.disconnect();
  }
}

function indexOf(node: Node, list: NodeList) {
  for (let i = 0; i < list.length; i++) {
    if (list[i] === node) return i;
  }

  return -1;
}



================================================
FILE: packages/core/source/elements/RemoteReceiverElement.ts
================================================
import {DOMRemoteReceiver} from '../receivers/DOMRemoteReceiver.ts';

type DOMRemoteReceiverOptions = NonNullable<
  ConstructorParameters<typeof DOMRemoteReceiver>[0]
>;

/**
 * A custom element that can be used to simplify receiving updates to a
 * remote tree of elements in a host environment. On the host, you can create
 * a `RemoteReceiverElement` and use its `connection` property to connect
 * it to a remote environment
 *
 * @example
 * ```ts
 * import {RemoteReceiverElement} from '@remote-dom/core/elements';
 *
 * customElements.define('remote-receiver', RemoteReceiverElement);
 *
 * const element = document.createElement('remote-receiver');
 * console.log(element.connection); // RemoteConnection
 * ```
 */
export class RemoteReceiverElement extends HTMLElement {
  /**
   * The `RemoteConnection` object that connects this element to a remote
   * tree of elements.
   */
  readonly connection: DOMRemoteReceiver['connection'];

  /**
   * Called on remote properties and elements when they are accepted by this
   * element. To handle the passing of functions as remote properties, you
   * will likely want to use this callback to mark any functions contained
   * in the remote properties of the received elements as “used”, since they
   * may be called at any time by the host implementation.
   */
  retain?: DOMRemoteReceiverOptions['retain'];

  /**
   * Called on remote properties and elements when they are no longer attached
   * to the remote tree. To handle the passing of functions as remote properties,
   * you will likely want to use this callback to mark any functions contained
   * in the unused elements as “unused”, since they will no longer be called
   * by the host implementation.
   */
  release?: DOMRemoteReceiverOptions['release'];

  /**
   * Customizes how [remote methods](https://github.com/Shopify/remote-dom/blob/main/packages/core#remotemethods)
   * are called. By default, the receiver will call a matching method found on
   * the HTML element that represents the remote element. However, you may want to
   * customize this behavior in order to avoid exposing methods on your HTML
   * elements that should not be callable by the remote environment.
   *
   * @param element The HTML element representing the remote element the method is being called on.
   * @param method The name of the method being called.
   * @param args Arguments passed to the method from the remote environment.
   *
   * @example
   * customElements.define('remote-receiver', RemoteReceiverElement);
   *
   * const receiver = document.createElement('remote-receiver');
   * receiver.call = (element, method, ...args) => {
   *   // Prevent calling any methods that start with an underscore
   *   if (method.startsWith('_')) {
   *     throw new Error(`Cannot call method ${method}`);
   *   }
   *
   *   return element[method](...args);
   * };
   */
  call?: DOMRemoteReceiverOptions['call'];

  constructor() {
    super();

    const receiver = new DOMRemoteReceiver({
      root: this,
      call: (element, method, ...args) =>
        this.call
          ? this.call(element, method, ...args)
          : (element as any)[method](...args),
      retain: (value) => this.retain?.(value),
      release: (value) => this.release?.(value),
    });

    this.connection = receiver.connection;
  }
}



================================================
FILE: packages/core/source/elements/RemoteRootElement.ts
================================================
import {ROOT_ID, MUTATION_TYPE_INSERT_CHILD} from '../constants.ts';
import type {RemoteConnection, RemoteMutationRecord} from '../types.ts';

import {
  setRemoteId,
  remoteConnection,
  connectRemoteNode,
  serializeRemoteNode,
  updateRemoteElementProperty,
  callRemoteElementMethod,
} from './internals.ts';

/**
 * A custom element that represents the root of a remote tree of elements.
 * To use this element, define it as a custom element and create it with
 * `document.createElement()`. Then, call its `connect()` method with a
 * `RemoteConnection` instance from a host environment, and start appending
 * child nodes to the tree. Any changes to the tree nested under this element
 * will be synchronized with the host environment automatically.
 *
 * @example
 * ```ts
 * import {RemoteRootElement} from '@remote-dom/core/elements';
 *
 * customElements.define('remote-root', RemoteRootElement);
 *
 * const element = document.createElement('remote-root');
 *
 * withRemoteConnectionFromHost((connection) => {
 *   element.connect(connection);
 * });
 *
 * element.append('Hello world!');
 */
export class RemoteRootElement extends HTMLElement {
  constructor() {
    super();
    setRemoteId(this, ROOT_ID);
  }

  connect(connection: RemoteConnection): void {
    if (remoteConnection(this) === connection) return;

    connectRemoteNode(this, connection);

    if (this.childNodes.length === 0) return;

    const records: RemoteMutationRecord[] = [];

    for (let i = 0; i < this.childNodes.length; i++) {
      const node = this.childNodes[i]!;

      records.push([
        MUTATION_TYPE_INSERT_CHILD,
        ROOT_ID,
        serializeRemoteNode(node),
        i,
      ]);
    }

    connection.mutate(records);
  }

  updateRemoteProperty(name: string, value?: unknown) {
    updateRemoteElementProperty(this, name, value);
  }

  callRemoteMethod(method: string, ...args: any[]) {
    return callRemoteElementMethod(this, method, ...args);
  }
}



================================================
FILE: packages/core/source/elements/types.ts
================================================
/**
 * The details for a single attribute that will be defined on a `RemoteElement`.
 */
export interface RemoteElementAttributeDefinition {}

/**
 * The details for a single event listener that will be defined on a `RemoteElement`.
 */
export interface RemoteElementEventListenerDefinition {
  bubbles?: boolean;
  property?: boolean | string;
  dispatchEvent?(this: Element, ...args: any[]): Event | undefined | void;
}

/**
 * Configuration for event listeners that will be synchronized between a remote
 * element and its host representation.
 */
export type RemoteElementEventListenersDefinition<
  EventListeners extends Record<string, any> = {},
> = {
  [Event in keyof EventListeners]: RemoteElementEventListenerDefinition;
};

/**
 * The details for a single method that will be defined on a `RemoteElement`.
 */
export interface RemoteElementMethodDefinition {}

/**
 * Configuration for methods that will be synchronized between a remote element
 * and its host representation.
 */
export type RemoteElementMethodsDefinition<
  Slots extends Record<string, any> = {},
> = {
  [Slot in keyof Slots]: RemoteElementMethodDefinition;
};

/**
 * The details for a single property that will be defined on a `RemoteElement`.
 */
export interface RemoteElementPropertyDefinition<Value = unknown> {
  /**
   * The type of the property, which will control how it is reflected to and
   * from an attribute. Defaults to assuming the property contains a string value.
   */
  type?: RemoteElementPropertyTypeOrBuiltIn<Value>;

  /**
   * A list of aliases for this property. When the property is set, the aliases
   * will be defined as dedicated properties, but will always read and write to the
   * same underlying value.
   *
   * @deprecated
   */
  alias?: string[];

  /**
   * Whether the property should be settable using `addEventListener()`. When set to
   * `true`, Remote DOM infers the name of the event from the property name. When set
   * to a string, Remote DOM uses the string as the event name. When set to anything
   * else, there will be no connection between the property and event listener.
   *
   * @deprecated Use `RemoteElement.eventListeners` instead.
   */
  event?: boolean | string;

  /**
   * The attribute to reflect this property to. The value of the property will be serialized
   * according to the logic you provide with the `type` field. If set to `true` or omitted, an
   * attribute will be maintained with same name as the property. You can also set this option to
   * a string to provide a custom attribute name. If you want to disable attribute reflection
   * altogether, set this option to `false`.
   */
  attribute?: string | boolean;

  /**
   * The default value for the property. This value will be communicated to the host as if the
   * property was set directly.
   */
  default?: Value;
}

/**
 * Configuration for properties that will be synchronized between a remote
 * element and its host representation.
 */
export type RemoteElementPropertiesDefinition<
  Properties extends Record<string, any> = {},
> = {
  [Property in keyof Properties]: RemoteElementPropertyDefinition<
    Properties[Property]
  >;
};

/**
 * An object that can be used to define the type of a property on a remote
 * element, which will control its attribute reflection behavior.
 */
export type RemoteElementPropertyTypeOrBuiltIn<Value = unknown> =
  | typeof String
  | typeof Number
  | typeof Boolean
  | typeof Object
  | typeof Array
  | typeof Function
  | RemoteElementPropertyType<Value>;

/**
 * An object that provides custom logic for parsing a property from its
 * matching attribute value, and that can serialize the property back to
 * a string for the attribute.
 */
export interface RemoteElementPropertyType<Value = unknown> {
  parse?(value: string | unknown): Value;
  serialize?(value: Value): string | unknown;
}

/**
 * The details for a single slot that can be filled on a `RemoteElement`.
 */
export interface RemoteElementSlotDefinition {}

/**
 * Configuration for slots that will be synchronized between a remote element
 * and its host representation.
 */
export type RemoteElementSlotsDefinition<
  Slots extends Record<string, any> = {},
> = {
  [Slot in keyof Slots]: RemoteElementSlotDefinition;
};



================================================
FILE: packages/core/source/elements/decorators/custom-element.ts
================================================
export function customElement(name: string) {
  return <Class extends CustomElementConstructor>(
    _: Class,
    {addInitializer}: ClassDecoratorContext<Class>,
  ) => {
    addInitializer(function defineElement() {
      customElements.define(name, this);
    });
  };
}



================================================
FILE: packages/core/source/elements/decorators/remote-properties.ts
================================================
import type {RemoteElementPropertiesDefinition} from '../types.ts';
import type {RemoteElementConstructor} from '../RemoteElement.ts';

export function remoteProperties<Properties extends Record<string, any> = {}>(
  properties: RemoteElementPropertiesDefinition<Properties>,
) {
  return <ElementConstructor extends RemoteElementConstructor<Properties, any>>(
    Class: ElementConstructor,
    _context: ClassDecoratorContext<ElementConstructor>,
  ): ElementConstructor => {
    return class extends (Class as any) {
      static remoteProperties = properties;
    } as any;
  };
}



================================================
FILE: packages/core/source/elements/decorators/remote-property.ts
================================================
import type {RemoteElementPropertyDefinition} from '../types.ts';
import type {RemoteElement} from '../RemoteElement.ts';
import {updateRemoteElementProperty} from '../internals.ts';

export function remoteProperty<Value = unknown>(
  definition?: RemoteElementPropertyDefinition<Value>,
) {
  return <ElementType extends RemoteElement>(
    target: ClassAccessorDecoratorTarget<ElementType, Value>,
    context: ClassAccessorDecoratorContext<ElementType, Value>,
  ): ClassAccessorDecoratorResult<ElementType, Value> => {
    const property = context.name as string;

    context.addInitializer(function defineProperty() {
      (this.constructor as typeof RemoteElement).createProperty(
        property,
        definition,
      );
    });

    return {
      set(value) {
        target.set.call(this, value);
        updateRemoteElementProperty(this, property, value);
      },
      init(value) {
        updateRemoteElementProperty(this, property, value);
        return value;
      },
    };
  };
}



================================================
FILE: packages/core/source/elements/decorators/remote-slots.ts
================================================
import type {RemoteElementSlotsDefinition} from '../types.ts';
import type {RemoteElementConstructor} from '../RemoteElement.ts';

export function remoteSlots<Slots extends Record<string, any> = {}>(
  slots: RemoteElementSlotsDefinition<Slots>,
) {
  return <ElementConstructor extends RemoteElementConstructor<Slots, any>>(
    _: ElementConstructor,
    context: ClassDecoratorContext<ElementConstructor>,
  ) => {
    context.addInitializer(function defineElement() {
      (this as any).remoteSlots = {...this.remoteSlots, ...slots};
    });
  };
}



================================================
FILE: packages/core/source/elements/property-types/BooleanOrString.ts
================================================
import type {RemoteElementPropertyType} from '../types.ts';

export const BooleanOrString: RemoteElementPropertyType<boolean | string> = {
  parse(value) {
    if (value === '') return true;
    if (value === 'false') return false;
    return String(value);
  },
  serialize(value) {
    if (typeof value === 'boolean') {
      return value ? '' : null;
    }

    return String(value);
  },
};



================================================
FILE: packages/core/source/elements/tests/connection.test.ts
================================================
import '../../polyfill/polyfill.ts';

import {describe, expect, it, vi, type MockedObject} from 'vitest';

import {BatchingRemoteConnection, RemoteConnection} from '../../elements';

describe('BatchingRemoteConnection', () => {
  it('batches mutations', async () => {
    const connection = createRemoteConnectionSpy();
    const batchingConnection = new BatchingRemoteConnection(connection);

    batchingConnection.mutate([1, 2, 3]);
    batchingConnection.mutate([4, 5, 6]);

    expect(connection.mutate).not.toHaveBeenCalled();

    await waitForNextTask();

    expect(connection.mutate).toHaveBeenCalledTimes(1);
    expect(connection.mutate).toHaveBeenCalledWith([1, 2, 3, 4, 5, 6]);

    batchingConnection.mutate([7, 8, 9]);

    expect(connection.mutate).toHaveBeenCalledTimes(1);

    await waitForNextTask();

    expect(connection.mutate).toHaveBeenCalledTimes(2);
    expect(connection.mutate).toHaveBeenCalledWith([7, 8, 9]);
  });

  it('batches mutations with setTimeout when there is no MessageChannel', async () => {
    vi.useFakeTimers();
    vi.spyOn(globalThis, 'MessageChannel', 'get').mockReturnValue(
      undefined as any,
    );
    const setTimeoutSpy = vi.spyOn(globalThis, 'setTimeout');
    const connection = createRemoteConnectionSpy();
    const batchingConnection = new BatchingRemoteConnection(connection);

    batchingConnection.mutate([1, 2, 3]);
    batchingConnection.mutate([4, 5, 6]);

    expect(connection.mutate).not.toHaveBeenCalled();

    vi.runAllTimers();

    expect(setTimeoutSpy).toHaveBeenCalledTimes(1);
    expect(connection.mutate).toHaveBeenCalledTimes(1);
    expect(connection.mutate).toHaveBeenCalledWith([1, 2, 3, 4, 5, 6]);

    vi.restoreAllMocks();
    vi.useRealTimers();
  });

  it('flushes mutations', async () => {
    const connection = createRemoteConnectionSpy();
    const batchingConnection = new BatchingRemoteConnection(connection);

    batchingConnection.mutate([1, 2, 3]);
    batchingConnection.flush();

    expect(connection.mutate).toHaveBeenCalledOnce();
    expect(connection.mutate).toHaveBeenCalledWith([1, 2, 3]);

    await waitForNextTask();

    // ensure it wasn't called again
    expect(connection.mutate).toHaveBeenCalledOnce();
    batchingConnection.mutate([4, 5, 6]);

    await waitForNextTask();

    expect(connection.mutate).toHaveBeenCalledTimes(2);
    expect(connection.mutate).toHaveBeenCalledWith([4, 5, 6]);
  });

  it('enqueues the batch function only once while items are in the queue', async () => {
    const connection = createRemoteConnectionSpy();
    const batch = vi.fn();
    const batchingConnection = new BatchingRemoteConnection(connection, {
      batch,
    });

    batchingConnection.mutate([1, 2, 3]);
    batchingConnection.mutate([4, 5, 6]);
    expect(batch).toHaveBeenCalledOnce();

    const batchCallback = batch.mock.calls[0][0];
    batchCallback();

    batchingConnection.mutate([7, 8, 9]);
    expect(batch).toHaveBeenCalledTimes(2);
  });
});

async function waitForNextTask() {
  const channel = new MessageChannel();
  const promise = new Promise((resolve) => {
    channel.port1.onmessage = resolve;
  });
  channel.port2.postMessage(null);

  await promise;
}

function createRemoteConnectionSpy(): MockedObject<RemoteConnection> {
  return {
    mutate: vi.fn(),
    call: vi.fn(),
  };
}



================================================
FILE: packages/core/source/elements/tests/RemoteMutationObserver.test.ts
================================================
// @vitest-environment jsdom

import {describe, expect, it, vi} from 'vitest';

import {RemoteMutationObserver} from '../RemoteMutationObserver.ts';
import {RemoteReceiver} from '../../receivers/RemoteReceiver.ts';
import {RemoteElement} from '../RemoteElement.ts';

class MyRemoteElement extends RemoteElement {
  static remoteAttributes = ['src'];
}

customElements.define('my-remote-element', MyRemoteElement);

describe('RemoteMutationObserver', () => {
  describe('observe()', () => {
    describe('initial children', () => {
      it('transports initial children when observing an element with existing children', () => {
        const receiver = new RemoteReceiver();
        const observer = new RemoteMutationObserver(receiver.connection);
        const container = document.createElement('div');

        // Setup initial children
        const child1 = document.createElement('span');
        child1.textContent = 'Child 1';
        const child2 = document.createElement('div');
        child2.textContent = 'Child 2';
        const textNode = document.createTextNode('Text node');

        container.appendChild(child1);
        container.appendChild(textNode);
        container.appendChild(child2);

        observer.observe(container);

        expect(receiver.root.children).toHaveLength(3);
        expect(receiver.root.children[0]).toMatchObject({
          type: 1,
          element: 'span',
          children: [
            {
              type: 3,
              data: 'Child 1',
            },
          ],
        });
        expect(receiver.root.children[1]).toMatchObject({
          type: 3,
          data: 'Text node',
        });
        expect(receiver.root.children[2]).toMatchObject({
          type: 1,
          element: 'div',
          children: [
            {
              type: 3,
              data: 'Child 2',
            },
          ],
        });
      });

      it('does not transport initial children when initial option is false', () => {
        const receiver = new RemoteReceiver();
        const observer = new RemoteMutationObserver(receiver.connection);
        const container = document.createElement('div');
        const child = document.createElement('span');
        child.textContent = 'Child';
        container.appendChild(child);

        observer.observe(container, {initial: false});

        expect(receiver.root.children).toHaveLength(0);
      });

      it('does not transport initial children when element has no children', () => {
        const receiver = new RemoteReceiver();
        const observer = new RemoteMutationObserver(receiver.connection);
        const container = document.createElement('div');

        observer.observe(container);

        expect(receiver.root.children).toHaveLength(0);
      });

      it('transports nested initial children correctly', () => {
        const receiver = new RemoteReceiver();
        const observer = new RemoteMutationObserver(receiver.connection);
        const container = document.createElement('div');
        const child = document.createElement('div');
        const grandchild = document.createElement('span');
        grandchild.textContent = 'Grandchild';
        child.appendChild(grandchild);
        container.appendChild(child);

        observer.observe(container);

        expect(receiver.root.children).toHaveLength(1);
        expect(receiver.root.children[0]).toMatchObject({
          type: 1,
          element: 'div',
          children: [
            {
              type: 1,
              element: 'span',
              children: [
                {
                  type: 3,
                  data: 'Grandchild',
                },
              ],
            },
          ],
        });
      });
    });

    describe('multiple children', () => {
      it('sends custom ID elements as separate children to root when not using ROOT_ID', () => {
        const receiver = new RemoteReceiver();
        const observer = new RemoteMutationObserver(receiver.connection);
        const container = document.createElement('div');
        const child1 = document.createElement('span');
        child1.textContent = 'Child 1';
        const child2 = document.createElement('div');
        child2.textContent = 'Child 2';

        container.appendChild(child1);
        container.appendChild(child2);

        observer.observe(container, {id: 'custom-root'});

        expect(receiver.root.children).toHaveLength(1);
        expect(receiver.root.children[0]).toMatchObject({
          id: 'custom-root',
          type: 1,
          element: 'div',
          children: [
            {
              type: 1,
              element: 'span',
              children: [
                {
                  type: 3,
                  data: 'Child 1',
                },
              ],
            },
            {
              type: 1,
              element: 'div',
              children: [
                {
                  type: 3,
                  data: 'Child 2',
                },
              ],
            },
          ],
        });
      });
    });

    it('passes through mutation observer options', () => {
      const receiver = new RemoteReceiver();
      const observer = new RemoteMutationObserver(receiver.connection);
      const container = document.createElement('div');
      const spy = vi.spyOn(MutationObserver.prototype, 'observe');

      observer.observe(container, {
        subtree: false,
        childList: false,
        attributes: true,
        characterData: false,
      });

      expect(spy).toHaveBeenCalledWith(container, {
        subtree: false,
        childList: false,
        attributes: true,
        characterData: false,
      });

      spy.mockRestore();
    });

    it('defaults to observing all mutation types', () => {
      const receiver = new RemoteReceiver();
      const observer = new RemoteMutationObserver(receiver.connection);
      const container = document.createElement('div');
      const spy = vi.spyOn(MutationObserver.prototype, 'observe');

      observer.observe(container);

      expect(spy).toHaveBeenCalledWith(container, {
        subtree: true,
        childList: true,
        attributes: true,
        characterData: true,
      });

      spy.mockRestore();
    });
  });

  describe('updates', () => {
    it('handles child insertion', async () => {
      const receiver = new RemoteReceiver();
      const observer = new RemoteMutationObserver(receiver.connection);
      const container = document.createElement('div');

      observer.observe(container);

      const newChild = document.createElement('span');
      newChild.textContent = 'New child';

      container.appendChild(newChild);
      await flushMutationObserver(observer);

      expect(receiver.root.children).toHaveLength(1);
      expect(receiver.root.children[0]).toMatchObject({
        type: 1,
        element: 'span',
        children: [
          {
            type: 3,
            data: 'New child',
          },
        ],
      });
    });

    it('handles child removal', async () => {
      const receiver = new RemoteReceiver();
      const observer = new RemoteMutationObserver(receiver.connection);
      const container = document.createElement('div');
      const child = document.createElement('span');
      child.textContent = 'Child to remove';
      container.appendChild(child);

      observer.observe(container);

      expect(receiver.root.children).toHaveLength(1);

      container.removeChild(child);
      await flushMutationObserver(observer);

      expect(receiver.root.children).toHaveLength(0);
    });

    it('handles text content updates', async () => {
      const receiver = new RemoteReceiver();
      const observer = new RemoteMutationObserver(receiver.connection);
      const container = document.createElement('div');
      const textNode = document.createTextNode('Initial text');
      container.appendChild(textNode);

      observer.observe(container);

      expect(receiver.root.children[0]).toMatchObject({
        type: 3,
        data: 'Initial text',
      });

      textNode.textContent = 'Updated text';
      await flushMutationObserver(observer);

      expect(receiver.root.children[0]).toMatchObject({
        type: 3,
        data: 'Updated text',
      });
    });

    it('handles attribute updates', async () => {
      const receiver = new RemoteReceiver();
      const observer = new RemoteMutationObserver(receiver.connection);
      const container = document.createElement('div');
      const element = document.createElement('my-remote-element');
      element.setAttribute('src', 'https://example.com');
      container.appendChild(element);

      observer.observe(container);

      expect(receiver.root.children[0]).toMatchObject({
        type: 1,
        element: 'my-remote-element',
        attributes: {
          src: 'https://example.com',
        },
      });

      element.setAttribute('src', 'https://example.com/updated');
      await flushMutationObserver(observer);

      expect(receiver.root.children[0]).toMatchObject({
        type: 1,
        element: 'my-remote-element',
        attributes: {
          src: 'https://example.com/updated',
        },
      });
    });

    it('handles attribute removal', async () => {
      const receiver = new RemoteReceiver();
      const observer = new RemoteMutationObserver(receiver.connection);
      const container = document.createElement('div');
      const element = document.createElement('my-remote-element');
      element.setAttribute('src', 'https://example.com');
      container.appendChild(element);

      observer.observe(container);

      expect(receiver.root.children[0]).toMatchObject({
        type: 1,
        element: 'my-remote-element',
        attributes: {
          src: 'https://example.com',
        },
      });

      element.removeAttribute('src');
      await flushMutationObserver(observer);

      expect(receiver.root.children[0]).toMatchObject({
        type: 1,
        element: 'my-remote-element',
        attributes: {},
      });
    });

    it('handles nested child insertion', async () => {
      const receiver = new RemoteReceiver();
      const observer = new RemoteMutationObserver(receiver.connection);
      const container = document.createElement('div');
      const parent = document.createElement('div');
      container.appendChild(parent);

      observer.observe(container);
      expect(receiver.root.children[0]).toMatchObject({
        type: 1,
        element: 'div',
        children: [],
      });

      const child = document.createElement('span');
      child.textContent = 'Nested child';
      parent.appendChild(child);
      await flushMutationObserver(observer);

      expect(receiver.root.children[0]).toMatchObject({
        type: 1,
        element: 'div',
        children: [
          {
            type: 1,
            element: 'span',
            children: [
              {
                type: 3,
                data: 'Nested child',
              },
            ],
          },
        ],
      });
    });

    it('batches multiple mutations in a single call', async () => {
      const receiver = new RemoteReceiver();
      const observer = new RemoteMutationObserver(receiver.connection);
      const container = document.createElement('div');
      const child1 = document.createElement('span');
      const child2 = document.createElement('div');

      observer.observe(container);

      container.appendChild(child1);
      container.appendChild(child2);
      await flushMutationObserver(observer);

      expect(receiver.root.children).toHaveLength(2);
      expect(receiver.root.children[0]).toMatchObject({
        type: 1,
        element: 'span',
      });
      expect(receiver.root.children[1]).toMatchObject({
        type: 1,
        element: 'div',
      });
    });
  });

  describe('disconnect()', () => {
    it('disconnects without emptying when empty option is false', async () => {
      const receiver = new RemoteReceiver();
      const observer = new RemoteMutationObserver(receiver.connection);
      const container = document.createElement('div');
      const child = document.createElement('span');
      container.appendChild(child);

      observer.observe(container);
      expect(receiver.root.children).toHaveLength(1);

      observer.disconnect({empty: false});

      // Children should still be there
      expect(receiver.root.children).toHaveLength(1);
    });

    it('empties observed nodes when empty option is true', async () => {
      const receiver = new RemoteReceiver();
      const observer = new RemoteMutationObserver(receiver.connection);
      const container = document.createElement('div');
      const child = document.createElement('span');
      container.appendChild(child);

      observer.observe(container);
      expect(receiver.root.children).toHaveLength(1);

      observer.disconnect({empty: true});

      expect(receiver.root.children).toHaveLength(0);
    });

    it('empties multiple observed nodes when empty option is true', async () => {
      const receiver = new RemoteReceiver();
      const observer = new RemoteMutationObserver(receiver.connection);
      const container = document.createElement('div');
      const container2 = document.createElement('div');
      const child1 = document.createElement('span');
      const child2 = document.createElement('div');

      container.appendChild(child1);
      container2.appendChild(child2);

      observer.observe(container);
      observer.observe(container2, {id: 'custom-id'});
      expect(receiver.root.children).toHaveLength(2);

      observer.disconnect({empty: true});

      expect(receiver.root.children).toHaveLength(0);
    });

    it('stops observing mutations after disconnect', async () => {
      const receiver = new RemoteReceiver();
      const observer = new RemoteMutationObserver(receiver.connection);
      const container = document.createElement('div');

      observer.observe(container);

      const child = document.createElement('span');
      container.appendChild(child);

      observer.disconnect();

      expect(receiver.root.children).toHaveLength(0);
    });
  });
});

async function flushMutationObserver(_observer: MutationObserver) {
  // Observer fires in a tick after the current task, so we delay
  // just long enough for that to run.
  await new Promise((resolve) => setTimeout(resolve, 0));
}



================================================
FILE: packages/core/source/polyfill/hooks.ts
================================================
import {HOOKS, type Hooks} from '@remote-dom/polyfill';

import {
  MUTATION_TYPE_INSERT_CHILD,
  MUTATION_TYPE_REMOVE_CHILD,
  MUTATION_TYPE_UPDATE_TEXT,
} from '../constants.ts';

import {
  remoteId,
  remoteConnection,
  connectRemoteNode,
  disconnectRemoteNode,
  serializeRemoteNode,
  updateRemoteElementAttribute,
} from '../elements/internals.ts';

import {window} from './window.ts';

const hooks = window[HOOKS];

hooks.insertChild = (parent, node, index) => {
  const connection = remoteConnection(parent);
  if (connection == null) return;

  connectRemoteNode(node, connection);

  connection.mutate([
    [
      MUTATION_TYPE_INSERT_CHILD,
      remoteId(parent),
      serializeRemoteNode(node),
      index,
    ],
  ]);
};

hooks.removeChild = (parent, node, index) => {
  const connection = remoteConnection(parent);
  if (connection == null) return;

  disconnectRemoteNode(node);

  connection.mutate([[MUTATION_TYPE_REMOVE_CHILD, remoteId(parent), index]]);
};

hooks.setText = (text, data) => {
  const connection = remoteConnection(text);
  if (connection == null) return;

  connection.mutate([[MUTATION_TYPE_UPDATE_TEXT, remoteId(text), data]]);
};

// When an attribute is updated, we will send a message to the host to update the
// attribute, but only for native HTML elements. Custom elements are expected to
// handle their own attribute updates (which is done automatically in the `RemoteElement`
// base class).

hooks.setAttribute = (element, name, value) => {
  // Custom elements need to define their own logic for handling attribute
  // updates.
  if (element.tagName.includes('-')) return;

  updateRemoteElementAttribute(element, name, value);
};

hooks.removeAttribute = (element, name) => {
  // Custom elements need to define their own logic for handling attribute
  // updates.
  if (element.tagName.includes('-')) return;

  updateRemoteElementAttribute(element, name);
};

export {hooks, type Hooks};



================================================
FILE: packages/core/source/polyfill/polyfill.ts
================================================
import {Window} from '@remote-dom/polyfill';
import {window} from './window.ts';
import {hooks, type Hooks} from './hooks.ts';

Window.setGlobal(window);

export {hooks, window, Window, type Hooks};



================================================
FILE: packages/core/source/polyfill/window.ts
================================================
import {Window} from '@remote-dom/polyfill';

const window = new Window();

export {window};



================================================
FILE: packages/core/source/receivers/DOMRemoteReceiver.ts
================================================
import {createRemoteConnection, type RemoteConnection} from '../connection.ts';
import {
  NODE_TYPE_TEXT,
  NODE_TYPE_COMMENT,
  NODE_TYPE_ELEMENT,
  ROOT_ID,
  UPDATE_PROPERTY_TYPE_PROPERTY,
  UPDATE_PROPERTY_TYPE_ATTRIBUTE,
  UPDATE_PROPERTY_TYPE_EVENT_LISTENER,
} from '../constants.ts';
import {setRemoteId} from '../elements/internals.ts';
import type {RemoteNodeSerialization} from '../types.ts';
import type {RemoteReceiverOptions} from './shared.ts';

const REMOTE_IDS = new WeakMap<Node, string>();
const REMOTE_PROPERTIES = new WeakMap<Node, Record<string, any>>();
const REMOTE_EVENT_LISTENERS = new WeakMap<Node, Record<string, any>>();

/**
 * Takes care of mapping remote elements to matching HTML elements
 * on the host page. If you implement your UI with [custom elements](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements),
 * `DOMRemoteReceiver` is a simple option that avoids much of the
 * manual work required when using the basic `RemoteReceiver`.
 */
export class DOMRemoteReceiver {
  /**
   * The root element that will contain the host implementations of
   * all nodes attached to the remote tree. To connect the receiver to
   * a new element, call the `connect()` method.
   */
  readonly root: DocumentFragment | Element;

  /**
   * An object that can synchronize a tree of elements between two JavaScript
   * environments. This object acts as a “thin waist”, allowing for efficient
   * communication of changes between a “remote” environment (usually, a JavaScript
   * sandbox, such as an `iframe` or Web Worker) and a “host” environment
   * (usually, a top-level browser page).
   */
  readonly connection: RemoteConnection;

  private readonly attached = new Map<string, Node>();

  constructor({
    root,
    retain,
    release,
    call,
    cache,
  }: RemoteReceiverOptions & {
    /**
     * The root element for this receiver. This acts as a shortcut for calling
     * `connect()` after creating the receiver.
     */
    root?: Element;

    /**
     * Customizes how [remote methods](https://github.com/Shopify/remote-dom/blob/main/packages/core#remotemethods)
     * are called. By default, the receiver will call a matching method found on
     * the HTML element that represents the remote element. However, you may want to
     * customize this behavior in order to avoid exposing methods on your HTML
     * elements that should not be callable by the remote environment.
     *
     * @param element The HTML element representing the remote element the method is being called on.
     * @param method The name of the method being called.
     * @param args Arguments passed to the method from the remote environment.
     *
     * @example
     * const receiver = new DOMRemoteReceiver({
     *   call(element, method, ...args) {
     *     // Prevent calling any methods that start with an underscore
     *     if (method.startsWith('_')) {
     *       throw new Error(`Cannot call method ${method}`);
     *     }
     *
     *     return element[method](...args);
     *   },
     * });
     */
    call?(element: Element, method: string, ...args: any[]): any;

    /**
     * Controls how DOM elements created in based on remote elements are retained
     * once they are disconnected from the remote environment.
     */
    cache?: {
      /**
       * A timeout in milliseconds after which a detached element will be released.
       */
      maxAge?: number;
    };
  } = {}) {
    this.root = root ?? document.createDocumentFragment();

    const {attached} = this;
    const destroyTimeouts = new Map<string, number>();

    this.connection = createRemoteConnection({
      call: (id, method, ...args) => {
        const element =
          id === ROOT_ID && this.root.nodeType !== 11
            ? this.root
            : attached.get(id)!;

        return call
          ? call(element as any, method, ...args)
          : (element as any)[method](...args);
      },
      insertChild: (id, child, index) => {
        const parent = id === ROOT_ID ? this.root : attached.get(id)!;

        const existingTimeout = destroyTimeouts.get(id);
        if (existingTimeout) clearTimeout(existingTimeout);

        parent.insertBefore(attach(child), parent.childNodes[index] || null);
      },
      removeChild: (id, index) => {
        const parent = id === ROOT_ID ? this.root : attached.get(id)!;
        const child = parent.childNodes[index]!;
        child.remove();

        if (cache?.maxAge) {
          const existingTimeout = destroyTimeouts.get(id);
          if (existingTimeout) clearTimeout(existingTimeout);

          const timeout = setTimeout(() => {
            detach(child);
          }, cache.maxAge);
          destroyTimeouts.set(id, timeout as any);
        } else {
          detach(child);
        }
      },
      updateProperty: (
        id,
        property,
        value,
        type = UPDATE_PROPERTY_TYPE_PROPERTY,
      ) => {
        const element = attached.get(id)!;

        retain?.(value);

        const remoteProperties = REMOTE_PROPERTIES.get(element)!;
        const oldValue = remoteProperties[property];

        remoteProperties[property] = value;
        updateRemoteProperty(element as Element, property, value, type);

        release?.(oldValue);
      },
      updateText: (id, newText) => {
        const text = attached.get(id) as Text;
        text.data = newText;
      },
    });

    function attach(node: RemoteNodeSerialization) {
      const existingNode = attached.get(node.id);
      if (existingNode) return existingNode;

      let normalizedChild: Node;

      switch (node.type) {
        case NODE_TYPE_ELEMENT: {
          normalizedChild = document.createElement(node.element);

          if (node.properties) {
            REMOTE_PROPERTIES.set(normalizedChild, node.properties);

            for (const property of Object.keys(node.properties)) {
              const value = node.properties[property];
              retain?.(value);
              updateRemoteProperty(
                normalizedChild as Element,
                property,
                value,
                UPDATE_PROPERTY_TYPE_PROPERTY,
              );
            }
          } else {
            REMOTE_PROPERTIES.set(normalizedChild, {});
          }

          if (node.attributes) {
            for (const attribute of Object.keys(node.attributes)) {
              const value = node.attributes[attribute];
              retain?.(value);
              updateRemoteProperty(
                normalizedChild as Element,
                attribute,
                value,
                UPDATE_PROPERTY_TYPE_ATTRIBUTE,
              );
            }
          }

          REMOTE_EVENT_LISTENERS.set(normalizedChild, {});

          if (node.eventListeners) {
            for (const event of Object.keys(node.eventListeners)) {
              const listener = node.eventListeners[event];
              retain?.(listener);
              updateRemoteProperty(
                normalizedChild as Element,
                event,
                listener,
                UPDATE_PROPERTY_TYPE_EVENT_LISTENER,
              );
            }
          }

          for (const child of node.children) {
            normalizedChild.appendChild(attach(child));
          }

          break;
        }
        case NODE_TYPE_TEXT: {
          normalizedChild = document.createTextNode(node.data);
          break;
        }
        case NODE_TYPE_COMMENT: {
          normalizedChild = document.createComment(node.data);
          break;
        }
        default: {
          throw new Error(`Unknown node type: ${JSON.stringify(node)}`);
        }
      }

      setRemoteId(normalizedChild, node.id);

      attached.set(node.id, normalizedChild);

      return normalizedChild;
    }

    function detach(child: Node) {
      const id = REMOTE_IDS.get(child);
      if (id) attached.delete(id);

      const properties = REMOTE_PROPERTIES.get(child);
      if (properties && release) release(properties);

      if (child instanceof Element) {
        for (const grandChild of child.childNodes) {
          detach(grandChild);
        }
      }
    }
  }

  /**
   * Connects the receiver to a new root element. The representation of
   * any child elements of the remote root will be appended to this node
   * as children, and the `root` property will be updated to point to the
   * new element.
   */
  connect(element: Element) {
    const oldRoot = this.root;
    (this as any).root = element;

    oldRoot.childNodes.forEach((node) => {
      element.appendChild(node);
    });
  }

  /**
   * Disconnects the receiver from its current root element. Any current
   * children of the root element will be moved to a `DocumentFragment`
   * instead, so they can be re-attached to a new element later.
   */
  disconnect() {
    // DocumentFragment
    if (this.root.nodeType === 11) return this.root as DocumentFragment;

    const oldRoot = this.root;
    const fragment = new DocumentFragment();
    (this as any).root = fragment;

    oldRoot.childNodes.forEach((node) => {
      fragment.appendChild(node);
    });

    return fragment;
  }
}

function updateRemoteProperty(
  element: Element,
  property: string,
  value: unknown,
  type:
    | typeof UPDATE_PROPERTY_TYPE_PROPERTY
    | typeof UPDATE_PROPERTY_TYPE_ATTRIBUTE
    | typeof UPDATE_PROPERTY_TYPE_EVENT_LISTENER,
) {
  switch (type) {
    case UPDATE_PROPERTY_TYPE_PROPERTY: {
      (element as any)[property] = value;
      break;
    }
    case UPDATE_PROPERTY_TYPE_ATTRIBUTE: {
      if (value == null) {
        element.removeAttribute(property);
      } else {
        element.setAttribute(property, value as string);
      }

      break;
    }
    case UPDATE_PROPERTY_TYPE_EVENT_LISTENER: {
      const remoteListeners = REMOTE_EVENT_LISTENERS.get(element);
      const existing = remoteListeners?.[property];

      if (existing) element.removeEventListener(property, existing);

      if (value != null) {
        // Support a `RemoteEvent`-shaped event object, where the `detail` argument
        // is passed to the remote environment, and the resulting promise call is passed
        // to `event.resolve()`. A host implementation can use this conventional event shape
        // to use the internal function representation of the event listener.
        const handler = (event: any) => {
          // If the event is bubbling/ capturing, we don’t trigger the listener here,
          // we let the event be dispatched to the remote environment only from the actual
          // target element. In the remote environment, the event will go through a separate
          // capture/ bubbling phase, where it will invoke the remote event listener
          // that corresponds to this `value` function.
          if (event.target !== element) return;
          const result = (value as any)(event.detail);
          event.resolve?.(result);
        };

        if (remoteListeners) {
          remoteListeners[property] = handler;
        }

        element.addEventListener(property, handler);
      }

      break;
    }
  }
}



================================================
FILE: packages/core/source/receivers/RemoteReceiver.ts
================================================
import {createRemoteConnection, type RemoteConnection} from '../connection.ts';
import {
  NODE_TYPE_COMMENT,
  NODE_TYPE_ELEMENT,
  NODE_TYPE_ROOT,
  NODE_TYPE_TEXT,
  ROOT_ID,
  UPDATE_PROPERTY_TYPE_ATTRIBUTE,
  UPDATE_PROPERTY_TYPE_EVENT_LISTENER,
  UPDATE_PROPERTY_TYPE_PROPERTY,
} from '../constants.ts';
import type {
  RemoteTextSerialization,
  RemoteCommentSerialization,
  RemoteElementSerialization,
  RemoteNodeSerialization,
} from '../types.ts';
import type {RemoteReceiverOptions} from './shared.ts';

/**
 * Represents a text node of a remote tree in a plain JavaScript format, with
 * the addition of a `version` property that is incremented whenever the
 * node is updated.
 */
export interface RemoteReceiverText extends RemoteTextSerialization {
  readonly version: number;
}

/**
 * Represents a comment node of a remote tree in a plain JavaScript format, with
 * the addition of a `version` property that is incremented whenever the
 * node is updated.
 */
export interface RemoteReceiverComment extends RemoteCommentSerialization {
  readonly version: number;
}

/**
 * Represents an element node of a remote tree in a plain JavaScript format, with
 * the addition of a `version` property that is incremented whenever the
 * node is updated.
 */
export interface RemoteReceiverElement
  extends Omit<RemoteElementSerialization, 'children' | 'properties'> {
  readonly properties: NonNullable<RemoteElementSerialization['properties']>;
  readonly attributes: NonNullable<RemoteElementSerialization['attributes']>;
  readonly eventListeners: NonNullable<
    RemoteElementSerialization['eventListeners']
  >;
  readonly children: readonly RemoteReceiverNode[];
  readonly version: number;
}

/**
 * Represents the root node of the remote tree in a plain JavaScript format, with
 * the addition of a `version` property that is incremented whenever the
 * root is updated.
 */
export interface RemoteReceiverRoot {
  readonly id: typeof ROOT_ID;
  readonly type: typeof NODE_TYPE_ROOT;
  readonly children: readonly RemoteReceiverNode[];
  readonly properties: NonNullable<RemoteElementSerialization['properties']>;
  readonly attributes: NonNullable<RemoteElementSerialization['attributes']>;
  readonly eventListeners: NonNullable<
    RemoteElementSerialization['eventListeners']
  >;
  readonly version: number;
}

/**
 * Represents any node that can be stored in the host representation of the remote tree.
 */
export type RemoteReceiverNode =
  | RemoteReceiverText
  | RemoteReceiverComment
  | RemoteReceiverElement;

/**
 * Any node in the remote tree that can have children nodes.
 */
export type RemoteReceiverParent = RemoteReceiverElement | RemoteReceiverRoot;

type RemoteReceiverNodeOrRoot = RemoteReceiverNode | RemoteReceiverRoot;

type Writable<T> = {
  -readonly [P in keyof T]: T[P];
};

/**
 * A `RemoteReceiver` stores remote elements into a basic JavaScript representation,
 * and allows subscribing to individual elements in the remote environment.
 * This can be useful for mapping remote elements to components in a JavaScript
 * framework; for example, the [`@remote-dom/react` library](https://github.com/Shopify/remote-dom/blob/main/packages/react#remoterenderer)
 * uses this receiver to map remote elements to React components.
 */
export class RemoteReceiver {
  /**
   * Represents the root node of the remote tree. This node is always defined,
   * and you will likely be most interested in its `children` property, which
   * contains the top-level elements of the remote tree.
   */
  readonly root: RemoteReceiverRoot = {
    id: ROOT_ID,
    type: NODE_TYPE_ROOT,
    children: [],
    version: 0,
    properties: {},
    attributes: {},
    eventListeners: {},
  };

  /**
   * An object that can synchronize a tree of elements between two JavaScript
   * environments. This object acts as a “thin waist”, allowing for efficient
   * communication of changes between a “remote” environment (usually, a JavaScript
   * sandbox, such as an `iframe` or Web Worker) and a “host” environment
   * (usually, a top-level browser page).
   */
  readonly connection: RemoteConnection;

  private readonly attached = new Map<
    string | typeof ROOT_ID,
    RemoteReceiverNodeOrRoot
  >([[ROOT_ID, this.root]]);

  private readonly subscribers = new Map<
    string | typeof ROOT_ID,
    Set<(value: RemoteReceiverNodeOrRoot) => void>
  >();

  private readonly parents = new Map<string, string | typeof ROOT_ID>();
  private readonly implementations = new Map<
    string,
    Record<string, (...args: unknown[]) => unknown>
  >();

  constructor({
    retain,
    release,
    methods,
  }: RemoteReceiverOptions & {
    /**
     * A set of [remote methods](https://github.com/Shopify/remote-dom/blob/main/packages/core#remotemethods)
     * that can be called on the root node of the remote tree. This is a convenience
     * option that replaces the need to call `implement()` on the root node.
     */
    methods?: Record<string, (...args: any[]) => any> | null;
  } = {}) {
    const {attached, parents, subscribers} = this;

    this.connection = createRemoteConnection({
      call: (id, method, ...args) => {
        const implementation = this.implementations.get(id);
        const implementationMethod = implementation?.[method];

        if (typeof implementationMethod !== 'function') {
          throw new Error(
            `Node ${id} does not implement the ${method}() method`,
          );
        }

        return implementationMethod(...args);
      },
      insertChild: (id, child, index) => {
        const parent = attached.get(id) as Writable<RemoteReceiverParent>;

        const {children} = parent;

        const normalizedChild = attach(child, parent);

        if (index === children.length) {
          (children as Writable<typeof children>).push(normalizedChild);
        } else {
          (children as Writable<typeof children>).splice(
            index,
            0,
            normalizedChild,
          );
        }

        parent.version += 1;
        this.parents.set(child.id, parent.id);

        runSubscribers(parent);
      },
      removeChild: (id, index) => {
        const parent = attached.get(id) as Writable<RemoteReceiverParent>;

        const {children} = parent;

        const [removed] = (children as Writable<typeof children>).splice(
          index,
          1,
        );

        if (!removed) {
          return;
        }

        parent.version += 1;

        runSubscribers(parent);

        detach(removed);
      },
      updateProperty: (
        id,
        property,
        value,
        type = UPDATE_PROPERTY_TYPE_PROPERTY,
      ) => {
        const element = attached.get(id) as Writable<RemoteReceiverElement>;

        retain?.(value);

        let updateObject: Record<string, any>;

        switch (type) {
          case UPDATE_PROPERTY_TYPE_PROPERTY:
            updateObject = element.properties;
            break;
          case UPDATE_PROPERTY_TYPE_ATTRIBUTE:
            updateObject = element.attributes;
            break;
          case UPDATE_PROPERTY_TYPE_EVENT_LISTENER:
            updateObject = element.eventListeners;
            break;
        }

        const oldValue = updateObject[property];

        updateObject[property] = value;
        element.version += 1;

        let parentForUpdate: Writable<RemoteReceiverParent> | undefined;

        // If the slot changes, inform parent nodes so they can
        // re-parent it appropriately.
        if (property === 'slot') {
          const parentId = this.parents.get(id);

          parentForUpdate =
            parentId == null
              ? parentId
              : (attached.get(parentId) as Writable<RemoteReceiverParent>);

          if (parentForUpdate) {
            parentForUpdate.version += 1;
          }
        }

        runSubscribers(element);
        if (parentForUpdate) runSubscribers(parentForUpdate);

        release?.(oldValue);
      },
      updateText: (id, newText) => {
        const text = attached.get(id) as Writable<RemoteReceiverText>;

        text.data = newText;
        text.version += 1;

        runSubscribers(text);
      },
    });

    if (methods) this.implement(this.root, methods);

    function runSubscribers(attached: RemoteReceiverNodeOrRoot) {
      const subscribed = subscribers.get(attached.id);

      if (subscribed) {
        for (const subscriber of subscribed) {
          subscriber(attached);
        }
      }
    }

    function attach(
      child: RemoteNodeSerialization,
      parent: RemoteReceiverParent,
    ): RemoteReceiverNode {
      let normalizedChild: RemoteReceiverNode;

      switch (child.type) {
        case NODE_TYPE_TEXT:
        case NODE_TYPE_COMMENT: {
          const {id, type, data} = child;

          normalizedChild = {
            id,
            type,
            data,
            version: 0,
          } satisfies RemoteReceiverText | RemoteReceiverComment;

          break;
        }
        case NODE_TYPE_ELEMENT: {
          const {
            id,
            type,
            element,
            children,
            properties,
            attributes,
            eventListeners,
          } = child;
          retain?.(properties);
          retain?.(eventListeners);

          const resolvedChildren: RemoteReceiverNode[] = [];

          normalizedChild = {
            id,
            type,
            element,
            version: 0,
            children: resolvedChildren as readonly RemoteReceiverNode[],
            properties: {...properties},
            attributes: {...attributes},
            eventListeners: {...eventListeners},
          } satisfies RemoteReceiverElement;

          for (const grandChild of children) {
            resolvedChildren.push(attach(grandChild, normalizedChild));
          }

          break;
        }
        default: {
          throw new Error(`Unknown node type: ${JSON.stringify(child)}`);
        }
      }

      attached.set(normalizedChild.id, normalizedChild);
      parents.set(normalizedChild.id, parent.id);

      return normalizedChild;
    }

    function detach(child: RemoteReceiverNode) {
      attached.delete(child.id);
      parents.delete(child.id);

      if (release) {
        if ('properties' in child) release(child.properties);
        if ('eventListeners' in child) release(child.eventListeners);
      }

      if ('children' in child) {
        for (const grandChild of child.children) {
          detach(grandChild);
        }
      }
    }
  }

  /**
   * Fetches the latest state of a remote element that has been
   * received from the remote environment.
   *
   * @param node The remote node to fetch.
   * @returns The current state of the remote node, or `undefined` if the node is not connected to the remote tree.
   *
   * @example
   * import {RemoteReceiver} from '@remote-dom/core/receivers';
   *
   * const receiver = new RemoteReceiver();
   *
   * receiver.get(receiver.root) === receiver.root; // true
   */
  get<T extends RemoteReceiverNodeOrRoot>({id}: Pick<T, 'id'>): T | undefined {
    return this.attached.get(id) as any;
  }

  /**
   * Lets you define how [remote methods](https://github.com/Shopify/remote-dom/blob/main/packages/core#remotemethods)
   * are implemented for a particular element in the tree.
   *
   * @param node The remote node to subscribe for changes.
   * @param implementation A record containing the methods to expose for the passed node.
   *
   * @example
   * // In the host environment:
   * import {RemoteReceiver} from '@remote-dom/core/receivers';
   *
   * const receiver = new RemoteReceiver();
   *
   * receiver.implement(receiver.root, {
   *   alert(message) {
   *     window.alert(message);
   *   },
   * });
   *
   * // In the remote environment:
   * import {RemoteRootElement} from '@remote-dom/core/elements';
   *
   * customElements.define('remote-root', RemoteRootElement);
   *
   * const root = document.createElement('remote-root');
   * root.connect(receiver.connection);
   *
   * root.callRemoteMethod('alert', 'Hello, world!');
   */
  implement<T extends RemoteReceiverNodeOrRoot>(
    {id}: Pick<T, 'id'>,
    implementation?: Record<string, (...args: any[]) => any> | null,
  ) {
    if (implementation == null) {
      this.implementations.delete(id);
    } else {
      this.implementations.set(id, implementation);
    }
  }

  /**
   * Allows you to subscribe to changes in a remote element. This includes
   * changes to the remote element’s properties and list of children, but
   * note that you will not receive updates for properties or children of
   * _nested_ elements.
   *
   * @param node The remote node to subscribe for changes.
   * @param subscriber A function that will be called with the updated node on each change.
   *
   * @example
   * import {RemoteReceiver} from '@remote-dom/core/receivers';
   *
   * const abort = new AbortController();
   * const receiver = new RemoteReceiver();
   *
   * // Subscribe to all changes in the top-level children, attached
   * // directly to the remote “root”.
   * receiver.subscribe(
   *   receiver.root,
   *   (root) => {
   *     console.log('Root changed!', root);
   *   },
   *   {signal: abort.signal},
   * );
   */
  subscribe<T extends RemoteReceiverNodeOrRoot>(
    {id}: Pick<T, 'id'>,
    subscriber: (value: T) => void,
    {
      signal,
    }: {
      /**
       * An optional `AbortSignal` that can be used to unsubscribe from the changes.
       */
      signal?: AbortSignal;
    } = {},
  ) {
    let subscribersSet = this.subscribers.get(id);

    if (subscribersSet == null) {
      subscribersSet = new Set();
      this.subscribers.set(id, subscribersSet);
    }

    subscribersSet.add(subscriber as any);

    signal?.addEventListener('abort', () => {
      subscribersSet!.delete(subscriber as any);

      if (subscribersSet!.size === 0) {
        this.subscribers.delete(id);
      }
    });
  }
}



================================================
FILE: packages/core/source/receivers/shared.ts
================================================
/**
 * Options that are useful for all remote receiver implementations. All of the
 * receivers in `@remote-dom/core/receivers` accept these options.
 */
export interface RemoteReceiverOptions {
  /**
   * Called on remote properties and elements when they are accepted by the
   * receiver. To handle the passing of functions as remote properties, you
   * will likely want to use this callback to mark any functions contained
   * in the remote properties of the received elements as “used”, since they
   * may be called at any time by the host implementation.
   */
  retain?(value: any): void;

  /**
   * Called on remote properties and elements when they are no longer attached
   * to the remote tree. To handle the passing of functions as remote properties,
   * you will likely want to use this callback to mark any functions contained
   * in the unused elements as “unused”, since they will no longer be called
   * by the host implementation.
   */
  release?(value: any): void;
}



================================================
FILE: packages/core/source/tests/elements.test.ts
================================================
import '../polyfill/polyfill.ts';
import {describe, it, expect, vi, type MockedObject} from 'vitest';

import {
  RemoteElement,
  createRemoteElement,
  RemoteEvent,
  // remoteProperties,
  // remoteProperty,
  RemoteRootElement,
  type RemoteElementConstructor,
} from '../elements.ts';
import {remoteId} from '../elements/internals.ts';
import {
  RemoteReceiver,
  type RemoteReceiverElement,
} from '../receivers/RemoteReceiver.ts';
import {
  MUTATION_TYPE_UPDATE_PROPERTY,
  UPDATE_PROPERTY_TYPE_PROPERTY,
  UPDATE_PROPERTY_TYPE_ATTRIBUTE,
  MUTATION_TYPE_INSERT_CHILD,
  UPDATE_PROPERTY_TYPE_EVENT_LISTENER,
} from '../constants.ts';
import {NAME, OWNER_DOCUMENT} from '../../../polyfill/source/constants.ts';

describe('RemoteElement', () => {
  describe('properties', () => {
    it('serializes initial properties declared with a static `remoteProperties` field', () => {
      interface HelloElementProperties {
        name?: string;
      }

      class HelloElement extends RemoteElement<HelloElementProperties> {
        static remoteProperties = {
          name: {type: String},
        };
      }

      const {root, receiver} = createAndConnectRemoteRootElement();

      const name = 'Winston';
      const element = createElementFromConstructor(HelloElement);
      (element as HelloElementProperties).name = name;

      expect(receiver.connection.mutate).not.toHaveBeenCalled();

      root.append(element);

      expect(receiver.root.children).toStrictEqual([
        {
          type: 1,
          id: expect.any(String),
          element: expect.any(String),
          version: 0,
          children: [],
          properties: {name},
          attributes: {},
          eventListeners: {},
        },
      ]);
    });

    it('sends updates to properties declared with a static `remoteProperties` field', () => {
      interface HelloElementProperties {
        name?: string;
      }

      class HelloElement extends RemoteElement<HelloElementProperties> {
        static remoteProperties = {
          name: {type: String},
        };
      }

      const {element, receiver} = createAndConnectRemoteElement(HelloElement);

      const name = 'Winston';
      (element as HelloElementProperties).name = name;

      expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
        [
          MUTATION_TYPE_UPDATE_PROPERTY,
          remoteId(element),
          'name',
          name,
          UPDATE_PROPERTY_TYPE_PROPERTY,
        ],
      ]);
    });

    it('sends updates to properties declared with `createRemoteElement()`', () => {
      const HelloElement = createRemoteElement<{name: string}>({
        properties: {name: {attribute: true}},
      });

      const {element, receiver} = createAndConnectRemoteElement(HelloElement);

      const name = 'Winston';
      element.name = name;

      expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
        [
          MUTATION_TYPE_UPDATE_PROPERTY,
          remoteId(element),
          'name',
          name,
          UPDATE_PROPERTY_TYPE_PROPERTY,
        ],
      ]);
    });

    // it('sends updates to properties declared with the `@remoteProperties()` decorator', () => {
    //   @remoteProperties({
    //     name: {attribute: true},
    //   })
    //   class HelloElement extends RemoteElement<{name: string}> {
    //     name!: string;
    //   }

    //   const {element, receiver} = createAndConnectRemoteElement(HelloElement);

    //   const name = 'Winston';
    //   element.name = name;

    //   expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
    //     [MUTATION_TYPE_UPDATE_PROPERTY, remoteId(element), 'name', name],
    //   ]);
    // });

    // it('sends updates to properties declared with the `@remoteProperty()` decorator', () => {
    //   class HelloElement extends RemoteElement {
    //     @remoteProperty()
    //     accessor name!: string;
    //   }

    //   const {element, receiver} = createAndConnectRemoteElement(HelloElement);

    //   const name = 'Winston';
    //   element.name = name;

    //   expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
    //     [MUTATION_TYPE_UPDATE_PROPERTY, remoteId(element), 'name', name],
    //   ]);
    // });

    // it('serializes initial properties declared with the `@remoteProperty()` decorator', () => {
    //   const name = 'Winston';
    //   class HelloElement extends RemoteElement {
    //     @remoteProperty()
    //     accessor name = name;
    //   }

    //   const {root, receiver} = createAndConnectRemoteRootElement();

    //   const element = new HelloElement();
    //   element.name = name;

    //   expect(receiver.connection.mutate).not.toHaveBeenCalled();

    //   root.append(element);

    //   expect(receiver.root.children).toStrictEqual([
    //     {
    //       type: 1,
    //       id: expect.any(String),
    //       element: expect.any(String),
    //       version: 0,
    //       children: [],
    //       properties: {name},
    //     },
    //   ]);
    // });

    describe('attribute reflection', () => {
      it('reflects the value of a remote property from a matching attribute by default', () => {
        const ProductElement = createRemoteElement<{name: string}>({
          properties: {name: {}},
        });

        const {element, receiver} =
          createAndConnectRemoteElement(ProductElement);

        const name = 'Fiddle leaf fig';
        element.setAttribute('name', name);

        expect(element.name).toBe(name);
        expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'name',
            name,
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);
      });

      it('reflects the value of a remote property from a matching attribute when explicitly enabled', () => {
        const ProductElement = createRemoteElement<{name: string}>({
          properties: {name: {attribute: true}},
        });

        const {element, receiver} =
          createAndConnectRemoteElement(ProductElement);

        const name = 'Fiddle leaf fig';
        element.setAttribute('name', name);

        expect(element.name).toBe(name);
        expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'name',
            name,
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);
      });

      it('does not reflect the value of a remote property from a matching attribute when explicitly disabled', () => {
        const ProductElement = createRemoteElement<{name: string}>({
          properties: {name: {attribute: false}},
        });

        const {element, receiver} =
          createAndConnectRemoteElement(ProductElement);

        const name = 'Fiddle leaf fig';
        element.setAttribute('name', name);

        expect(element.name).toBe(undefined);
        expect(receiver.connection.mutate).not.toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'name',
            name,
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);
      });

      it('unsets the value of a remote property when a matching attribute is removed', () => {
        const ProductElement = createRemoteElement<{name: string}>({
          properties: {name: {}},
        });

        const {element, receiver} =
          createAndConnectRemoteElement(ProductElement);

        const name = 'Fiddle leaf fig';
        element.setAttribute('name', name);
        element.removeAttribute('name');

        expect(element.name).toBe(undefined);
        expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'name',
            undefined,
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);
      });

      it('reflects the value of a camel-cased remote property from a dash-cased attribute', () => {
        const ProductElement = createRemoteElement<{updatedAt: string}>({
          properties: {updatedAt: {attribute: true}},
        });

        const {element, receiver} =
          createAndConnectRemoteElement(ProductElement);

        const updatedAt = new Date().toISOString();
        element.setAttribute('updated-at', updatedAt);

        expect(element.updatedAt).toBe(updatedAt);
        expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'updatedAt',
            updatedAt,
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);
      });

      it('reflects the value of a remote property from a custom attribute name', () => {
        const attribute = 'updated';
        const ProductElement = createRemoteElement<{updatedAt: string}>({
          properties: {updatedAt: {attribute}},
        });

        const {element, receiver} =
          createAndConnectRemoteElement(ProductElement);

        const updatedAt = new Date().toISOString();
        element.setAttribute(attribute, updatedAt);

        expect(element.updatedAt).toBe(updatedAt);
        expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'updatedAt',
            updatedAt,
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);
      });

      it('parses the value of a remote property from a matching attribute using a number type', () => {
        const ProductElement = createRemoteElement<{inventory: number}>({
          properties: {inventory: {type: Number}},
        });

        const {element, receiver} =
          createAndConnectRemoteElement(ProductElement);

        const inventory = 42;
        element.setAttribute('inventory', String(inventory));

        expect(element.inventory).toBe(inventory);
        expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'inventory',
            inventory,
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);

        element.removeAttribute('inventory');

        expect(element.inventory).toBe(undefined);
        expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'inventory',
            undefined,
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);
      });

      it('parses the value of a remote property from a matching attribute using an object type', () => {
        const ProductElement = createRemoteElement<{collection: {id: string}}>({
          properties: {collection: {type: Object}},
        });

        const {element, receiver} =
          createAndConnectRemoteElement(ProductElement);

        const collection = {id: '1'};
        element.setAttribute('collection', JSON.stringify(collection));

        expect(element.collection).toStrictEqual(collection);
        expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'collection',
            collection,
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);

        element.removeAttribute('collection');

        expect(element.collection).toBe(undefined);
        expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'collection',
            undefined,
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);
      });

      it('parses the value of a remote property from a matching attribute using an object type that can’t be parsed as JSON', () => {
        const ProductElement = createRemoteElement<{collection: {id: string}}>({
          properties: {collection: {type: Object}},
        });

        const {element, receiver} =
          createAndConnectRemoteElement(ProductElement);

        element.setAttribute('collection', 'foo');

        expect(element.collection).toBe(undefined);
        expect(receiver.connection.mutate).not.toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'collection',
            expect.anything(),
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);
      });

      it('parses the value of a remote property from a matching attribute using an array type', () => {
        const ProductElement = createRemoteElement<{
          collections: {id: string}[];
        }>({
          properties: {collections: {type: Array}},
        });

        const {element, receiver} =
          createAndConnectRemoteElement(ProductElement);

        const collections = [{id: '1'}];
        element.setAttribute('collections', JSON.stringify(collections));

        expect(element.collections).toStrictEqual(collections);
        expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'collections',
            collections,
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);

        element.removeAttribute('collections');

        expect(element.collections).toBe(undefined);
        expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'collections',
            undefined,
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);
      });

      it('parses the value of a remote property from a matching attribute using an array type that can’t be parsed as JSON', () => {
        const ProductElement = createRemoteElement<{
          collections: {id: string}[];
        }>({
          properties: {collections: {type: Array}},
        });

        const {element, receiver} =
          createAndConnectRemoteElement(ProductElement);

        element.setAttribute('collections', 'foo');

        expect(element.collections).toBe(undefined);
        expect(receiver.connection.mutate).not.toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'collection',
            expect.anything(),
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);
      });

      it('parses the value for a remote property from an attribute using a custom type', () => {
        const attributePrefix = 'From attribute: ';

        const TestElement = createRemoteElement<{myField: string}>({
          properties: {
            myField: {
              attribute: true,
              type: {
                parse(value: unknown) {
                  return `${attributePrefix}${value}`;
                },
              },
            },
          },
        });

        const {element, receiver} = createAndConnectRemoteElement(TestElement);

        const value = 'Hello world';
        element.setAttribute('my-field', value);

        expect(element.myField).toBe(`${attributePrefix}${value}`);
        expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'myField',
            `${attributePrefix}${value}`,
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);
      });
    });

    describe('event listeners', () => {
      it('does not create a property for an unrecognized event', () => {
        const ButtonElement = createRemoteElement<{
          onPress(): void;
          press: boolean;
        }>({
          properties: {
            press: {},
            onPress: {event: false},
          },
        });

        const {element, receiver} =
          createAndConnectRemoteElement(ButtonElement);

        const listener = vi.fn();
        element.addEventListener('press', listener);

        expect(element.onPress).toBe(undefined);
        expect(receiver.connection.mutate).not.toHaveBeenCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            expect.anything(),
            expect.anything(),
            expect.anything(),
          ],
        ]);
      });

      it('proxies event listeners for the inferred event name of an `onX` property by default', () => {
        const ButtonElement = createRemoteElement<{onPress(): void}>({
          properties: {onPress: {}},
        });

        const {element, receiver} =
          createAndConnectRemoteElement(ButtonElement);

        const listener = vi.fn();
        element.addEventListener('press', listener);

        expect(element.onPress).toBeInstanceOf(Function);
        expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'onPress',
            element.onPress,
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);
      });

      it('proxies event listeners for a property that is declared as an event listener', () => {
        const ButtonElement = createRemoteElement<{press(): void}>({
          properties: {press: {event: true}},
        });

        const {element, receiver} =
          createAndConnectRemoteElement(ButtonElement);

        const listener = vi.fn();
        element.addEventListener('press', listener);

        expect(element.press).toBeInstanceOf(Function);
        expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'press',
            element.press,
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);
      });

      it('proxies event listeners to a custom event name', () => {
        const ButtonElement = createRemoteElement<{onPress(): void}>({
          properties: {onPress: {event: 'click'}},
        });

        const {element, receiver} =
          createAndConnectRemoteElement(ButtonElement);

        const listener = vi.fn();
        element.addEventListener('click', listener);

        expect(element.onPress).toBeInstanceOf(Function);
        expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'onPress',
            element.onPress,
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);
      });

      it('proxies event listeners to kebab-cased event names', () => {
        const ButtonElement = createRemoteElement<{onMouseEnter(): void}>({
          properties: {onMouseEnter: {}},
        });

        const {element, receiver} =
          createAndConnectRemoteElement(ButtonElement);

        const listener = vi.fn();
        element.addEventListener('mouse-enter', listener);

        expect(element.onMouseEnter).toBeInstanceOf(Function);
        expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'onMouseEnter',
            element.onMouseEnter,
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);
      });

      it('calls event listeners with a RemoteEvent containing a single function argument as the detail', () => {
        const ButtonElement = createRemoteElement<{onPress(detail: any): void}>(
          {
            properties: {onPress: {}},
          },
        );

        const {element} = createAndConnectRemoteElement(ButtonElement);

        const listener = vi.fn();
        element.addEventListener('press', listener);

        const detail = {hello: 'world'};

        element.onPress(detail);

        expect(listener).toHaveBeenCalledWith(expect.any(CustomEvent));
        expect(listener).toHaveBeenCalledWith(
          expect.objectContaining({type: 'press', detail}),
        );
      });

      it('returns the resolved value attached to a RemoteEvent', () => {
        const ButtonElement = createRemoteElement<{
          onPress(): void;
        }>({
          properties: {onPress: {}},
        });

        const {element} = createAndConnectRemoteElement(ButtonElement);

        const response = 'Hello world';
        element.addEventListener('press', (event: RemoteEvent) => {
          event.respondWith(response);
        });

        const result = element.onPress();

        expect(result).toBe(response);
      });

      it('removes an event listener property when the last event listener is removed', () => {
        const ButtonElement = createRemoteElement<{onPress(): void}>({
          properties: {onPress: {}},
        });

        const {element, receiver} =
          createAndConnectRemoteElement(ButtonElement);

        const firstListener = vi.fn();
        const secondListener = vi.fn();

        element.addEventListener('press', firstListener);

        receiver.connection.mutate.mockClear();

        element.addEventListener('press', secondListener);

        expect(element.onPress).toBeInstanceOf(Function);
        expect(receiver.connection.mutate).not.toHaveBeenCalled();

        element.removeEventListener('press', secondListener);

        expect(element.onPress).toBeInstanceOf(Function);
        expect(receiver.connection.mutate).not.toHaveBeenCalled();

        element.removeEventListener('press', firstListener);

        expect(element.onPress).toBeUndefined();
        expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'onPress',
            undefined,
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);
      });

      it('removes an event listener property declared with once', () => {
        const ButtonElement = createRemoteElement<{onPress(): void}>({
          properties: {onPress: {}},
        });

        const {element, receiver} =
          createAndConnectRemoteElement(ButtonElement);

        const listener = vi.fn();

        element.addEventListener('press', listener, {once: true});

        element.onPress();

        expect(element.onPress).toBeUndefined();
        expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'onPress',
            undefined,
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);
      });

      it('removes an event listener property declared with an abort signal', () => {
        const ButtonElement = createRemoteElement<{onPress(): void}>({
          properties: {onPress: {}},
        });

        const {element, receiver} =
          createAndConnectRemoteElement(ButtonElement);

        const listener = vi.fn();
        const abort = new AbortController();

        element.addEventListener('press', listener, {signal: abort.signal});

        abort.abort();

        expect(element.onPress).toBeUndefined();
        expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
          [
            MUTATION_TYPE_UPDATE_PROPERTY,
            remoteId(element),
            'onPress',
            undefined,
            UPDATE_PROPERTY_TYPE_PROPERTY,
          ],
        ]);
      });
    });
  });

  describe('attributes', () => {
    it('serializes initial attributes when the element is connected', () => {
      const ProductElement = createRemoteElement({
        attributes: ['name'],
      });

      const receiver = new TestRemoteReceiver();

      const root = createRemoteRootElement();
      const element = createElementFromConstructor(ProductElement);
      root.append(element);

      const name = 'Fiddle leaf fig';
      element.setAttribute('name', name);
      element.setAttribute('not-a-valid-attribute', 'foo');

      root.connect(receiver.connection);

      expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
        [
          MUTATION_TYPE_INSERT_CHILD,
          remoteId(root),
          expect.objectContaining({
            attributes: {name},
          }),
          0,
        ],
      ]);
    });

    it('automatically serializes the slot attribute without any additional configuration', () => {
      const ProductElement = createRemoteElement();

      const receiver = new TestRemoteReceiver();

      const root = createRemoteRootElement();
      const element = createElementFromConstructor(ProductElement);
      root.append(element);

      const slot = 'aside';
      element.setAttribute('slot', slot);

      root.connect(receiver.connection);

      expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
        [
          MUTATION_TYPE_INSERT_CHILD,
          remoteId(root),
          expect.objectContaining({
            attributes: {slot},
          }),
          0,
        ],
      ]);
    });

    it('reflects the value of a remote attribute automatically when the attribute is set', () => {
      const ProductElement = createRemoteElement({
        attributes: ['name'],
      });

      const {element, receiver} = createAndConnectRemoteElement(ProductElement);

      const name = 'Fiddle leaf fig';
      element.setAttribute('name', name);

      expect(element.getAttribute('name')).toBe(name);
      // @ts-expect-error We are testing that there is no attribute reflection, and the
      // type therefore also complains that `name` is not a property of `element`.
      expect(element.name).toBe(undefined);
      expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
        [
          MUTATION_TYPE_UPDATE_PROPERTY,
          remoteId(element),
          'name',
          name,
          UPDATE_PROPERTY_TYPE_ATTRIBUTE,
        ],
      ]);
    });

    it('reflects the value of a remote attribute automatically when the attribute is removed', () => {
      const ProductElement = createRemoteElement({
        attributes: ['name'],
      });

      const {element, receiver} = createAndConnectRemoteElement(ProductElement);

      const name = 'Fiddle leaf fig';
      element.setAttribute('name', name);
      element.removeAttribute('name');

      expect(element.getAttribute('name')).toBe(null);
      expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
        [
          MUTATION_TYPE_UPDATE_PROPERTY,
          remoteId(element),
          'name',
          null,
          UPDATE_PROPERTY_TYPE_ATTRIBUTE,
        ],
      ]);
    });
  });

  describe('event listeners', () => {
    it('proxies event listeners, passing along the original first argument of the caller and returning the result of event.response', async () => {
      const ButtonElement = createRemoteElement({
        events: ['press'],
      });

      const {element, receiver} = createAndConnectRemoteElement(ButtonElement);

      const listener = vi.fn((event: RemoteEvent) => {
        event.respondWith(Promise.resolve(`Detail: ${event.detail}`));
      });

      // We haven’t added a listener yet, so we should not have informed the host yet
      expect(receiver.connection.mutate).not.toHaveBeenCalledWith([
        [
          MUTATION_TYPE_UPDATE_PROPERTY,
          remoteId(element),
          'press',
          expect.any(Function),
          UPDATE_PROPERTY_TYPE_EVENT_LISTENER,
        ],
      ]);

      element.addEventListener('press', listener);

      expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
        [
          MUTATION_TYPE_UPDATE_PROPERTY,
          remoteId(element),
          'press',
          expect.any(Function),
          UPDATE_PROPERTY_TYPE_EVENT_LISTENER,
        ],
      ]);

      const dispatchFunction = receiver.get<RemoteReceiverElement>({
        id: remoteId(element),
      })?.eventListeners.press;
      const result = await dispatchFunction?.('Hello world');

      expect(listener).toHaveBeenCalledWith(expect.any(RemoteEvent));
      expect(listener).toHaveBeenCalledWith(
        expect.objectContaining({
          type: 'press',
          detail: 'Hello world',
        }),
      );
      expect(result).toBe('Detail: Hello world');
    });

    it('supports a `bubbles` event option that automatically listens for an event and marks it as bubbling', async () => {
      const ButtonElement = createRemoteElement({
        events: {
          press: {
            bubbles: true,
          },
        },
      });

      const {receiver, root, element} =
        createAndConnectRemoteElement(ButtonElement);

      // Attaching a listener to the root, to verify bubbling behavior.
      const listener = vi.fn();
      root.addEventListener('press', listener);

      const dispatchFunction = receiver.get<RemoteReceiverElement>({
        id: remoteId(element),
      })?.eventListeners.press;
      await dispatchFunction?.('Hello world');

      expect(listener).toHaveBeenCalledWith(expect.any(RemoteEvent));
      expect(listener).toHaveBeenCalledWith(
        expect.objectContaining({
          bubbles: true,
        }),
      );
    });

    it('uses a custom event provided by a `dispatchEvent()` event listener description', async () => {
      class CustomRemoteEvent extends RemoteEvent {}

      const dispatchListener = vi.fn();

      const ButtonElement = createRemoteElement({
        events: {
          press: {
            dispatchEvent(detail: string) {
              dispatchListener(this, detail);

              return new CustomRemoteEvent('press', {
                detail: `Detail: ${detail}`,
              });
            },
          },
        },
      });

      const {element, receiver} = createAndConnectRemoteElement(ButtonElement);

      const listener = vi.fn();

      element.addEventListener('press', listener);

      expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
        [
          MUTATION_TYPE_UPDATE_PROPERTY,
          remoteId(element),
          'press',
          expect.any(Function),
          UPDATE_PROPERTY_TYPE_EVENT_LISTENER,
        ],
      ]);

      const dispatchFunction = receiver.get<RemoteReceiverElement>({
        id: remoteId(element),
      })?.eventListeners.press;
      await dispatchFunction?.('Hello world');

      expect(dispatchListener).toHaveBeenCalledWith(element, 'Hello world');
      expect(listener).toHaveBeenCalledWith(expect.any(CustomRemoteEvent));
      expect(listener).toHaveBeenCalledWith(
        expect.objectContaining({
          detail: 'Detail: Hello world',
        }),
      );
    });

    it('passes all arguments to a custom event provided by a `dispatchEvent()` event listener description', async () => {
      class CustomRemoteEvent extends RemoteEvent {}

      const dispatchListener = vi.fn();

      const ButtonElement = createRemoteElement({
        events: {
          press: {
            dispatchEvent(...args: any[]) {
              dispatchListener(this, ...args);

              return new CustomRemoteEvent('press', {
                detail: args,
              });
            },
          },
        },
      });

      const {element, receiver} = createAndConnectRemoteElement(ButtonElement);

      const listener = vi.fn();

      element.addEventListener('press', listener);

      expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
        [
          MUTATION_TYPE_UPDATE_PROPERTY,
          remoteId(element),
          'press',
          expect.any(Function),
          UPDATE_PROPERTY_TYPE_EVENT_LISTENER,
        ],
      ]);

      const dispatchFunction = receiver.get<RemoteReceiverElement>({
        id: remoteId(element),
      })?.eventListeners.press;
      await dispatchFunction?.('Hello', 'world', '!');

      expect(dispatchListener).toHaveBeenCalledWith(
        element,
        'Hello',
        'world',
        '!',
      );
      expect(listener).toHaveBeenCalledWith(expect.any(CustomRemoteEvent));
      expect(listener).toHaveBeenCalledWith(
        expect.objectContaining({
          detail: ['Hello', 'world', '!'],
        }),
      );
    });

    it('removes an event listener when the last event listener is removed', () => {
      const ButtonElement = createRemoteElement({
        events: ['press'],
      });

      const {element, receiver} = createAndConnectRemoteElement(ButtonElement);

      const firstListener = vi.fn();
      const secondListener = vi.fn();

      element.addEventListener('press', firstListener);

      receiver.connection.mutate.mockClear();

      element.addEventListener('press', secondListener);

      expect(receiver.connection.mutate).not.toHaveBeenCalled();

      element.removeEventListener('press', secondListener);

      expect(receiver.connection.mutate).not.toHaveBeenCalled();

      element.removeEventListener('press', firstListener);

      expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
        [
          MUTATION_TYPE_UPDATE_PROPERTY,
          remoteId(element),
          'press',
          undefined,
          UPDATE_PROPERTY_TYPE_EVENT_LISTENER,
        ],
      ]);

      element.dispatchEvent(new RemoteEvent('press'));

      expect(firstListener).not.toHaveBeenCalled();
      expect(secondListener).not.toHaveBeenCalled();
    });

    it('removes an event listener declared with once', () => {
      const ButtonElement = createRemoteElement({
        events: ['press'],
      });

      const {element, receiver} = createAndConnectRemoteElement(ButtonElement);

      const listener = vi.fn();

      element.addEventListener('press', listener, {once: true});

      element.dispatchEvent(new RemoteEvent('press'));

      expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
        [
          MUTATION_TYPE_UPDATE_PROPERTY,
          remoteId(element),
          'press',
          undefined,
          UPDATE_PROPERTY_TYPE_EVENT_LISTENER,
        ],
      ]);

      expect(listener).toHaveBeenCalledTimes(1);

      listener.mockClear();

      element.dispatchEvent(new RemoteEvent('press'));

      expect(listener).not.toHaveBeenCalled();
    });

    it('removes an event listener declared with an abort signal', () => {
      const ButtonElement = createRemoteElement({
        events: ['press'],
      });

      const {element, receiver} = createAndConnectRemoteElement(ButtonElement);

      const listener = vi.fn();
      const abort = new AbortController();

      element.addEventListener('press', listener, {signal: abort.signal});

      abort.abort();

      expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
        [
          MUTATION_TYPE_UPDATE_PROPERTY,
          remoteId(element),
          'press',
          undefined,
          UPDATE_PROPERTY_TYPE_EVENT_LISTENER,
        ],
      ]);

      element.dispatchEvent(new RemoteEvent('press'));

      expect(listener).not.toHaveBeenCalled();
    });

    it('supports adding event listeners using a property', () => {
      const ButtonElement = createRemoteElement<{
        onpress: ((event: Event) => void) | null;
      }>({
        events: ['press'],
      });

      const {element, receiver} = createAndConnectRemoteElement(ButtonElement);

      const listener = vi.fn();

      element.onpress = listener;

      expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
        [
          MUTATION_TYPE_UPDATE_PROPERTY,
          remoteId(element),
          'press',
          expect.any(Function),
          UPDATE_PROPERTY_TYPE_EVENT_LISTENER,
        ],
      ]);

      const event = new RemoteEvent('press');

      element.dispatchEvent(event);

      expect(listener).toHaveBeenCalledWith(event);
    });

    it('supports adding event listeners using a custom property name', () => {
      const ButtonElement = createRemoteElement<{
        onPress: ((event: Event) => void) | null;
      }>({
        events: {
          press: {property: 'onPress'},
        },
      });

      const {element, receiver} = createAndConnectRemoteElement(ButtonElement);

      const listener = vi.fn();

      element.onPress = listener;

      expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
        [
          MUTATION_TYPE_UPDATE_PROPERTY,
          remoteId(element),
          'press',
          expect.any(Function),
          UPDATE_PROPERTY_TYPE_EVENT_LISTENER,
        ],
      ]);

      element.dispatchEvent(new RemoteEvent('press'));

      expect(listener).toHaveBeenCalledOnce();
    });

    it('supports disabling a property name that maps to the event listener', () => {
      const ButtonElement = createRemoteElement({
        events: {
          press: {property: false},
        },
      });

      const {element, receiver} = createAndConnectRemoteElement(ButtonElement);
      receiver.connection.mutate.mockClear();

      const listener = vi.fn();

      // @ts-expect-error This property is not available in this case
      element.onpress = listener;

      expect(receiver.connection.mutate).not.toHaveBeenCalled();

      element.dispatchEvent(new RemoteEvent('press'));

      expect(listener).not.toHaveBeenCalledOnce();
    });

    it('removes an event listener declared using a property when it is unset', () => {
      const ButtonElement = createRemoteElement<{
        onpress: ((event: Event) => void) | null;
      }>({
        events: ['press'],
      });

      const {element, receiver} = createAndConnectRemoteElement(ButtonElement);

      const firstListener = vi.fn();
      const secondListener = vi.fn();

      element.onpress = firstListener;

      receiver.connection.mutate.mockClear();

      element.onpress = secondListener;

      expect(receiver.connection.mutate).not.toHaveBeenCalled();

      element.onpress = null;

      expect(receiver.connection.mutate).toHaveBeenLastCalledWith([
        [
          MUTATION_TYPE_UPDATE_PROPERTY,
          remoteId(element),
          'press',
          undefined,
          UPDATE_PROPERTY_TYPE_EVENT_LISTENER,
        ],
      ]);

      element.dispatchEvent(new RemoteEvent('press'));

      expect(firstListener).not.toHaveBeenCalled();
      expect(secondListener).not.toHaveBeenCalled();
    });
  });

  describe('methods', () => {
    it('calls a method on the remote receiver', () => {
      class HelloElement extends RemoteElement<{}, {greet(): void}> {
        greet(name: string) {
          return this.callRemoteMethod('greet', name);
        }
      }

      const {root, receiver} = createAndConnectRemoteRootElement();

      const element = new HelloElement();
      root.append(element);

      const name = 'Winston';
      const spy = vi.fn((name: string) => `Hello ${name}!`);
      const receivedElement = receiver.root
        .children[0] as RemoteReceiverElement;

      receiver.implement(receivedElement, {greet: spy});

      expect(spy).not.toHaveBeenCalled();

      const result = element.greet(name);

      expect(result).toBe(`Hello ${name}!`);
      expect(spy).toHaveBeenCalledWith(name);
    });
  });
});

class TestRemoteReceiver
  implements
    Pick<
      RemoteReceiver,
      'root' | 'connection' | 'get' | 'implement' | 'subscribe'
    >
{
  readonly #receiver = new RemoteReceiver();
  readonly connection: RemoteReceiver['connection'] &
    MockedObject<RemoteReceiver['connection']>;

  get root() {
    return this.#receiver.root;
  }

  constructor() {
    const {connection} = this.#receiver;
    this.connection = {
      mutate: vi.fn(connection.mutate),
      call: vi.fn(connection.call),
    };
  }

  get: RemoteReceiver['get'] = this.#receiver.get.bind(this.#receiver);
  implement = this.#receiver.implement.bind(this.#receiver);
  subscribe = this.#receiver.subscribe.bind(this.#receiver);
}

function createAndConnectRemoteElement<
  ElementType extends RemoteElementConstructor,
>(ElementConstructor: ElementType) {
  const {receiver, root} = createAndConnectRemoteRootElement();
  const element = createElementFromConstructor(ElementConstructor);
  root.append(element);
  return {root, element, receiver};
}

function createElementFromConstructor<
  ElementType extends CustomElementConstructor,
>(
  ElementConstructor: ElementType,
  tagName: string = 'test-custom-element',
  ownerDocument: Document = window.document,
) {
  const element = new ElementConstructor() as InstanceType<ElementType>;

  Object.defineProperties(element, {
    [NAME]: {value: tagName, writable: true, enumerable: false},
    [OWNER_DOCUMENT]: {
      value: ownerDocument,
      writable: true,
      enumerable: false,
    },
  });

  return element;
}

function createAndConnectRemoteRootElement() {
  const root = createRemoteRootElement();
  const receiver = new TestRemoteReceiver();
  root.connect(receiver.connection);
  document.body.append(root);
  return {root, receiver};
}

function createRemoteRootElement() {
  return createElementFromConstructor(RemoteRootElement, 'remote-root');
}



================================================
FILE: packages/core/source/tests/html.test.ts
================================================
import '../polyfill/polyfill.ts';
import {describe, it, expect} from 'vitest';

import {html, type PropertiesWithChildren} from '../html.ts';

class Button extends HTMLElement {
  emphasized = false;
}

class RemoteFragment extends HTMLElement {}

customElements.define('ui-button', Button);
customElements.define('remote-fragment', RemoteFragment);

describe('html', () => {
  it('renders a text node', () => {
    const text = html`Hello world!` satisfies Text;

    expect(text).toBeInstanceOf(Text);
    expect(text.textContent).toBe('Hello world!');
  });

  it('renders an element', () => {
    const element = html`<ui-button>Press me!</ui-button>` satisfies Button;

    expect(element).toBeInstanceOf(Button);
    expect(element.localName).toBe('ui-button');
    expect(element.textContent).toBe('Press me!');
  });

  it('renders an element with attributes', () => {
    const element = html`
      <ui-button data-id="123">Press me!</ui-button>
    ` satisfies Button;

    expect(element.getAttribute('data-id')).toBe('123');
  });

  it('renders an element with boolean attributes', () => {
    const element = html`<ui-button active
      >Press me!</ui-button
    >` satisfies Button;

    expect(element.getAttribute('active')).toBe('');
  });

  it('renders an element with properties', () => {
    const element = html`<ui-button emphasized
      >Press me!</ui-button
    >` satisfies Button;

    expect(element.emphasized).toBe(true);
  });

  it('renders a node passed as a property to a slot with a matching name', () => {
    const icon = html`<ui-icon name="check" />`;
    const button = html`<ui-button icon=${icon}
      >Press me!</ui-button
    >` satisfies Button;

    expect(button.childNodes).toStrictEqual(
      expect.arrayContaining([expect.any(Text), expect.any(RemoteFragment)]),
    );
    expect(button.childNodes[1]!.childNodes).toEqual([icon]);
    expect((button.childNodes[1] as RemoteFragment).slot).toBe('icon');
  });

  it('renders multiple children', () => {
    const children = html`${'My button: '}
      <ui-button>Press me!</ui-button>` satisfies [Text, Button];

    expect(children).toStrictEqual(
      expect.arrayContaining([expect.any(Text), expect.any(Button)]),
    );
    expect(children[0].textContent).toBe('My button: ');
    expect(children[1].localName).toBe('ui-button');
    expect(children[1].textContent).toBe('Press me!');
  });

  it('can embed existing DOM nodes', () => {
    const text = html`Press me!`;
    const icon = html`<ui-icon slot="icon" name="check" />`;
    const button = html`<ui-button>${text}${icon}</ui-button>` satisfies Button;

    expect(button.localName).toBe('ui-button');
    expect(button.childNodes).toEqual([text, icon]);
  });

  it('converts numbers passed as children into text nodes', () => {
    const button = html`<ui-button
      >Clicked ${0} times</ui-button
    >` satisfies Button;

    expect(button.outerHTML).toBe('<ui-button>Clicked 0 times</ui-button>');
    expect(button.childNodes).toEqual([
      expect.any(Text),
      expect.any(Text),
      expect.any(Text),
    ]);
    expect(button.childNodes[1]!.textContent).toBe('0');
  });

  it('ignores falsy children', () => {
    const button = html`
      <ui-button>${false}${null}${undefined}Press me!<//>
    ` satisfies Button;

    expect(button.outerHTML).toBe('<ui-button>Press me!</ui-button>');
    expect(button.childNodes).toEqual([expect.any(Text)]);
  });

  describe('components', () => {
    it('returns the result of calling a component', () => {
      function MyButton({children}: PropertiesWithChildren) {
        return html`<ui-button>${children}</ui-button>` satisfies Button;
      }

      const button = html`<${MyButton}>Press me!<//>` satisfies Button;

      expect(button).toBeInstanceOf(Button);
      expect(button.localName).toBe('ui-button');
      expect(button.textContent).toBe('Press me!');
    });

    it('flattens top-level components returning multiple children', () => {
      function Description({
        term,
        definition,
      }: {
        term: string;
        definition: string;
      }) {
        return html`
          <dt>${term}</dt>
          <dd>${definition}</dd>
        `;
      }

      const descriptions = html`
        <${Description} term="Shovel" definition="A tool for digging" />
        <${Description} term="Rake" definition="A tool for cleaning up" />
      `;

      expect(descriptions).toStrictEqual([
        expect.any(Element),
        expect.any(Element),
        expect.any(Element),
        expect.any(Element),
      ]);
    });

    it('omits components that return falsy results', () => {
      function Empty() {
        return null;
      }

      const nothing = html`<${Empty} /><${Empty} />`;

      expect(nothing).toBeNull();
    });
  });
});



================================================
FILE: packages/polyfill/README.md
================================================
# `@remote-dom/polyfill`

A polyfill for the browser APIs used by Remote DOM. This allows you to use Remote DOM in environments that don’t have a native DOM, like [Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API).

This package provides a low-level polyfill, with hooks that allow other libraries to intercept changes to the DOM. Unless you know you need this package, you probably want to import from [`@remote-dom/core/polyfill`](../core/README.md#remote-domcorepolyfill) instead, which uses the hooks provided by this library to automatically synchronize remote elements between environments.

## Installation

```sh
npm install @remote-dom/polyfill --save # npm
pnpm install @remote-dom/polyfill --save # pnpm
yarn add @remote-dom/polyfill # yarn
```

## Usage

This package provides a `Window` class, which implements a limited subset of the [`Window` browser interface](https://developer.mozilla.org/en-US/docs/Web/API/Window). You’ll create an instance of the `Window` class and install it to the global environment using the `Window.setGlobal()` method.

```ts
import {Window} from '@remote-dom/polyfill';

const window = new Window();
Window.setGlobal(window);

// Now you can use many important DOM APIs, like `document` and `Element`:
const div = document.createElement('div');
```

This process will install polyfilled versions of the following globals:

- [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window), [`parent`](https://developer.mozilla.org/en-US/docs/Web/API/Window/parent), [`top`](https://developer.mozilla.org/en-US/docs/Web/API/Window/top), and [`self`](https://developer.mozilla.org/en-US/docs/Web/API/Window/self) which are all references to the `Window` instance (`self` is only overwritten when it is not already defined, to avoid overwriting the Web Worker `self` binding).
- [`document`](https://developer.mozilla.org/en-US/docs/Web/API/Window/document)
- [`customElements`](https://developer.mozilla.org/en-US/docs/Web/API/Window/customElements)
- [`location`](https://developer.mozilla.org/en-US/docs/Web/API/Window/location) and [`navigator`](https://developer.mozilla.org/en-US/docs/Web/API/Window/navigator), though these are just set to `globalThis.location` and `globalThis.navigator`.
- The [`Event`](https://developer.mozilla.org/en-US/docs/Web/API/Event), [`EventTarget`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget), [`CustomEvent`](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent), [`Node`](https://developer.mozilla.org/en-US/docs/Web/API/Node), [`ParentNode`](https://developer.mozilla.org/en-US/docs/Web/API/ParentNode), [`ChildNode`](https://developer.mozilla.org/en-US/docs/Web/API/ChildNode), [`Document`](https://developer.mozilla.org/en-US/docs/Web/API/Document), [`DocumentFragment`](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment), [`CharacterData`](https://developer.mozilla.org/en-US/docs/Web/API/CharacterData), [`Comment`](https://developer.mozilla.org/en-US/docs/Web/API/Comment), [`Text`](https://developer.mozilla.org/en-US/docs/Web/API/Text), [`Element`](https://developer.mozilla.org/en-US/docs/Web/API/Element), [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement), [`SVGElement`](https://developer.mozilla.org/en-US/docs/Web/API/SVGElement), [`HTMLTemplateElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement), and [`MutationObserver`](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) constructors.

This polyfill lets you hook into many of the operations that happen in the DOM, like creating elements, updating attributes, and adding event listeners. You define these hooks by overwriting any of the properties on the `hooks` export of this library.

```ts
import {hooks} from '@remote-dom/polyfill';

hooks.createElement = (element) => {
  console.log('Creating element:', element);
};
```



================================================
FILE: packages/polyfill/CHANGELOG.md
================================================
# @remote-dom/polyfill

## 1.5.1

### Patch Changes

- [#600](https://github.com/Shopify/remote-dom/pull/600) [`d9b4dab`](https://github.com/Shopify/remote-dom/commit/d9b4dab1ce2f76751fafab04e7a6ede8a3aa8045) Thanks [@henrytao-me](https://github.com/henrytao-me)! - Fix document fragment owner document

## 1.5.0

### Minor Changes

- [#593](https://github.com/Shopify/remote-dom/pull/593) [`61f5cba`](https://github.com/Shopify/remote-dom/commit/61f5cbaa9965f7befbea3d3dfc2d2b2a0798c958) Thanks [@developit](https://github.com/developit)! - Add support for `not` in query-selectors

## 1.4.7

### Patch Changes

- [#594](https://github.com/Shopify/remote-dom/pull/594) [`789a7c7`](https://github.com/Shopify/remote-dom/commit/789a7c7480a445d1e5973bd6e2aa4e8889ec6f85) Thanks [@robin-drexler](https://github.com/robin-drexler)! - add `FocusEvent`, `ClipboardEvent` and `ToggleEvent` to polyfill

## 1.4.6

### Patch Changes

- [#590](https://github.com/Shopify/remote-dom/pull/590) [`8994a49`](https://github.com/Shopify/remote-dom/commit/8994a49913cd0122fdfbd21f971448afab3a3207) Thanks [@robin-drexler](https://github.com/robin-drexler)! - fix error events not working

## 1.4.5

### Patch Changes

- [#571](https://github.com/Shopify/remote-dom/pull/571) [`0bba42b`](https://github.com/Shopify/remote-dom/commit/0bba42b3246fd100fce6cc03900f2b4645092264) Thanks [@robin-drexler](https://github.com/robin-drexler)! - fix Element.innerHTML not allowing newlines before attributes

## 1.4.4

### Patch Changes

- [#570](https://github.com/Shopify/remote-dom/pull/570) [`33baaba`](https://github.com/Shopify/remote-dom/commit/33baaba512ca461068f57dcba707ef1cc640bfca) Thanks [@robin-drexler](https://github.com/robin-drexler)! - fix event listener methods not being bound to correctly

## 1.4.3

### Patch Changes

- [#541](https://github.com/Shopify/remote-dom/pull/541) [`f42f535`](https://github.com/Shopify/remote-dom/commit/f42f535fb08ace5ba9a4332f39b49281fd0880f3) Thanks [@developit](https://github.com/developit)! - fix typo in previousElementSibling

## 1.4.2

### Patch Changes

- [#499](https://github.com/Shopify/remote-dom/pull/499) [`994e2ea`](https://github.com/Shopify/remote-dom/commit/994e2ea2f7ab0e67a2c37e5295ce86618b004518) Thanks [@lemonmade](https://github.com/lemonmade)! - Roll back mutation of `globalThis` and `globalThis.self` in `Window.setGlobal()`

  This prevents the polyfill from interfering with globals like `globalThis.addEventListener`, which you may need to manage the communication between a sandboxed environment and the main thread.

  In the future, we will likely change the polyfill to require you to explicitly install the polyfill, instead of it being done automatically when you `@remote-dom/core/polyfill`. At that point, we will reintroduce the ability to more faithfully replicate more DOM globals, like having `globalThis`, `globalThis.self`, and `globalThis.window` all refer to the same polyfilled `Window` object. To install this polyfill today and get back to the behavior introduced by [this PR](https://github.com/Shopify/remote-dom/pull/470), you can call the new `Window.setGlobalThis()` method:

  ```js
  import {window, Window} from '@remote-dom/core/polyfill';

  Window.setGlobalThis(window);
  ```

## 1.4.1

### Patch Changes

- [#472](https://github.com/Shopify/remote-dom/pull/472) [`1473a3c`](https://github.com/Shopify/remote-dom/commit/1473a3c521e8d4d44d50c2f15680f28997270dc8) Thanks [@jakearchibald](https://github.com/jakearchibald)! - Fix removeChild so it clears parent/sibling references

- [#472](https://github.com/Shopify/remote-dom/pull/472) [`1473a3c`](https://github.com/Shopify/remote-dom/commit/1473a3c521e8d4d44d50c2f15680f28997270dc8) Thanks [@jakearchibald](https://github.com/jakearchibald)! - Add node.parentElement

- [#470](https://github.com/Shopify/remote-dom/pull/470) [`08839d3`](https://github.com/Shopify/remote-dom/commit/08839d3c136b63024ef725d9cf427e250f2978d3) Thanks [@developit](https://github.com/developit)! - window aliases should refer to globalThis

## 1.4.0

### Minor Changes

- [#446](https://github.com/Shopify/remote-dom/pull/446) [`b297fc5`](https://github.com/Shopify/remote-dom/commit/b297fc5efecc6479fa5e0e3bdcdb48dea721df43) Thanks [@jakearchibald](https://github.com/jakearchibald)! - Implement node.isConnected

### Patch Changes

- [#446](https://github.com/Shopify/remote-dom/pull/446) [`b297fc5`](https://github.com/Shopify/remote-dom/commit/b297fc5efecc6479fa5e0e3bdcdb48dea721df43) Thanks [@jakearchibald](https://github.com/jakearchibald)! - Ensure that the insert and remove hooks are only called for element parents.

- [#446](https://github.com/Shopify/remote-dom/pull/446) [`b297fc5`](https://github.com/Shopify/remote-dom/commit/b297fc5efecc6479fa5e0e3bdcdb48dea721df43) Thanks [@jakearchibald](https://github.com/jakearchibald)! - Make connectedCallback and disconnectedCallback call on connect/disconnect recursively

## 1.3.1

### Patch Changes

- [#436](https://github.com/Shopify/remote-dom/pull/436) [`5979797`](https://github.com/Shopify/remote-dom/commit/59797975a3ccf2bee825809f67e05ca4a28e2647) Thanks [@jakearchibald](https://github.com/jakearchibald)! - Ensure the `createText` hook is called when creating a new text node

## 1.3.0

### Minor Changes

- [#389](https://github.com/Shopify/remote-dom/pull/389) [`2479b21`](https://github.com/Shopify/remote-dom/commit/2479b21406f6149063bfc095dbb6c3a019386403) Thanks [@lemonmade](https://github.com/lemonmade)! - Added native support for synchronizing attributes and event listeners

  Previously, Remote DOM only offered “remote properties” as a way to synchronize element state between the host and remote environments. These remote properties effectively synchronize a subset of a custom element’s instance properties. The `RemoteElement` class offers [a declarative way to define the properties that should be synchronized](/packages/core/README.md#remote-properties).

  ```ts
  import {RemoteElement} from '@remote-dom/core/elements';

  class MyElement extends RemoteElement {
    static get remoteProperties() {
      return ['label'];
    }
  }

  customElements.define('my-element', MyElement);

  const myElement = document.createElement('my-element');
  myElement.label = 'Hello, World!';
  ```

  The same `remoteProperties` configuration can create special handling for attributes and event listeners. By default, a remote property is automatically updated when setting an [attribute](https://developer.mozilla.org/en-US/docs/Glossary/Attribute) of the same name:

  ```ts
  const myElement = document.createElement('my-element');
  myElement.setAttribute('label', 'Hello, World!');

  // myElement.label === 'Hello, World!', and this value is synchronized
  // with the host environment as a “remote property”
  ```

  Similarly, a remote property can be automatically updated when adding an event listener based on a conventional `on` property naming prefix:

  ```ts
  import {RemoteElement} from '@remote-dom/core/elements';

  class MyElement extends RemoteElement {
    static get remoteProperties() {
      return {
        onChange: {
          event: true,
        },
      };
    }
  }

  customElements.define('my-element', MyElement);

  const myElement = document.createElement('my-element');

  // This adds a callback property that is synchronized with the host environment
  myElement.onChange = () => console.log('Changed!');

  // And so does this, but using the `addEventListener` method instead
  myElement.addEventListener('change', () => console.log('Changed!'));
  ```

  These utilities are handy, but they don’t align with patterns in native DOM elements, particularly when it comes to events. Now, both of these can be represented in a fashion that is more conventional in HTML. The `remoteAttributes` configuration allows you to define a set of element attributes that will be synchronized directly the host environment, instead of being treated as instance properties:

  ```ts
  import {RemoteElement} from '@remote-dom/core/elements';

  class MyElement extends RemoteElement {
    static get remoteAttributes() {
      return ['label'];
    }

    // If you want to add instance properties, you can do it with getters and
    // setters that manipulate the attribute value:
    //
    // get label() {
    //   return this.getAttribute('label');
    // }
    //
    // set label(value) {
    //   this.setAttribute('label', value);
    // }
  }

  customElements.define('my-element', MyElement);

  const myElement = document.createElement('my-element');
  myElement.setAttribute('label', 'Hello, World!');
  ```

  Similarly, the `remoteEvents` configuration allows you to define a set of event listeners that will be synchronized directly with the host environment:

  ```ts
  import {RemoteElement} from '@remote-dom/core/elements';

  class MyElement extends RemoteElement {
    static get remoteEvents() {
      return ['change'];
    }
  }

  customElements.define('my-element', MyElement);

  const myElement = document.createElement('my-element');

  // And so does this, but using the `addEventListener` method instead
  myElement.addEventListener('change', () => console.log('Changed!'));

  // No `myElement.onChange` property is created
  ```

  The `remoteProperties` configuration will continue to be supported for cases where you want to synchronize instance properties. Because instance properties can be any JavaScript type, properties are the highest-fidelity field that can be synchronized between the remote and host environments. However, adding event listeners using the `remoteProperties.event` configuration is **deprecated and will be removed in the next major version**. You should use the `remoteEvents` configuration instead. If you were previously defining remote properties which only accepted strings, consider using the `remoteAttributes` configuration, which stores the value entirely in an HTML attribute instead.

  This change is being released in a backwards-compatible way, so you can continue to use the existing `remoteProperties` configuration on host and/or remote environments without any code changes.

  All host utilities have been updated to support the new `attributes` and `eventListeners` property that are synchronized with the remote environment. This includes updates to the [React](/packages/react/README.md#event-listener-props) and [Preact hosts to map events to conventional callback props](/packages/preact/README.md#event-listener-props), and updates to the [`DOMRemoteReceiver` class](/packages/core/README.md#domremotereceiver), which now applies fields to the host element exactly as they were applied in the remote environment:

  ```ts
  // Remote environment:

  class MyElement extends RemoteElement {
    static get remoteEvents() {
      return ['change'];
    }
  }

  customElements.define('my-element', MyElement);

  const myElement = document.createElement('my-element');

  myElement.addEventListener('change', (event) => {
    console.log('Changed! New value: ', event.detail);
  });

  // Host environment:

  class MyElement extends HTMLElement {
    connectedCallback() {
      // Emit a change event on this element, with detail that will be passed
      // to the remote environment
      this.addEventListener('change', (event) => {
        event.stopImmediatePropagation();

        this.dispatchEvent(
          new CustomEvent('change', {
            detail: this.value,
          }),
        );
      });
    }

    // Additional implementation details of the host custom element...
  }

  customElements.define('my-element', MyElement);
  ```

### Patch Changes

- [#389](https://github.com/Shopify/remote-dom/pull/389) [`2479b21`](https://github.com/Shopify/remote-dom/commit/2479b21406f6149063bfc095dbb6c3a019386403) Thanks [@lemonmade](https://github.com/lemonmade)! - Bug fixes to event dispatching

  - Listeners on the target are now called during both the capture and bubble phases.
  - `stopPropagation` now respected.
  - `stopImmediatePropagation` now also stops regular propagation.

- [#389](https://github.com/Shopify/remote-dom/pull/389) [`2479b21`](https://github.com/Shopify/remote-dom/commit/2479b21406f6149063bfc095dbb6c3a019386403) Thanks [@lemonmade](https://github.com/lemonmade)! - Fix `Event.bubbles` and `Event.composedPath()` implementations

## 1.2.1

### Patch Changes

- [#419](https://github.com/Shopify/remote-dom/pull/419) [`3c6bd29`](https://github.com/Shopify/remote-dom/commit/3c6bd291121b9fa02cac4ba57274601e97b2a2d2) Thanks [@lemonmade](https://github.com/lemonmade)! - Fix synchronization of `slot` property in some edge cases

## 1.2.0

### Minor Changes

- [#411](https://github.com/Shopify/remote-dom/pull/411) [`3bec698`](https://github.com/Shopify/remote-dom/commit/3bec6983756c4b8a6834a037ac520438ef59d28f) Thanks [@lemonmade](https://github.com/lemonmade)! - Add CommonJS export conditions

## 1.1.0

### Minor Changes

- [#402](https://github.com/Shopify/remote-dom/pull/402) [`218ba3b`](https://github.com/Shopify/remote-dom/commit/218ba3bf1ff2e7518a7dcec11ffd352de70b16f8) Thanks [@olavoasantos](https://github.com/olavoasantos)! - Refactor hooks into the Window instance

## 1.0.6

### Patch Changes

- [#406](https://github.com/Shopify/remote-dom/pull/406) [`2ea3459`](https://github.com/Shopify/remote-dom/commit/2ea3459e29afc1421b3283ad59514fed38a52515) Thanks [@developit](https://github.com/developit)! - Fixes `hooks.addEventListener()` being called even when `EventTarget.addEventListener()` rejects a duplicate listener registration

## 1.0.5

### Patch Changes

- [#401](https://github.com/Shopify/remote-dom/pull/401) [`578a8c6`](https://github.com/Shopify/remote-dom/commit/578a8c69ed1df63da77ab5a0efd0b28f8a0188d9) Thanks [@olavoasantos](https://github.com/olavoasantos)! - Expose documentElement, head and body elements on the Document polyfill

## 1.0.4

### Patch Changes

- [`72304d6`](https://github.com/Shopify/remote-dom/commit/72304d6a76d28712c62698803d6ec65d9ac29614) Thanks [@lemonmade](https://github.com/lemonmade)! - Add `Node.contains()` method used by React

- [`e6deda6`](https://github.com/Shopify/remote-dom/commit/e6deda6b90c4c6cff94cac60619a7ef1deb7524e) Thanks [@lemonmade](https://github.com/lemonmade)! - Add missing `CustomElementRegistry.getName()` function

## 1.0.3

### Patch Changes

- [`549a423`](https://github.com/Shopify/remote-dom/commit/549a423b31d89354fa8ef91e8533eff69953d695) Thanks [@lemonmade](https://github.com/lemonmade)! - Consult custom elements in `createElementNS`

- [`31f8720`](https://github.com/Shopify/remote-dom/commit/31f8720e916ce8ac69bc079ba8e2aac089313605) Thanks [@lemonmade](https://github.com/lemonmade)! - Fix `createElementNS` argument ordering

## 1.0.2

### Patch Changes

- [`7d5327c`](https://github.com/Shopify/remote-dom/commit/7d5327ca3fd02f625bb404d43d9b0f7c9a3b079d) Thanks [@lemonmade](https://github.com/lemonmade)! - Fix making `window` non-configurable in polyfill

## 1.0.1

### Patch Changes

- [#281](https://github.com/Shopify/remote-dom/pull/281) [`0c51bbc`](https://github.com/Shopify/remote-dom/commit/0c51bbc2c7419ce23e1b8d02d4a0323c5b180672) Thanks [@santala](https://github.com/santala)! - Fix missing createElement hook call

- [#281](https://github.com/Shopify/remote-dom/pull/281) [`6768867`](https://github.com/Shopify/remote-dom/commit/6768867ac4f24059c30daeaf9d6dc1f4809b0155) Thanks [@santala](https://github.com/santala)! - Fix Node.textContent incorrectly appending the textContent of subsequent siblings

## 1.0.0

### Major Changes

- [`37be652`](https://github.com/Shopify/remote-dom/commit/37be652f288d1eec170c0be13b2da516f8db5dcf) Thanks [@lemonmade](https://github.com/lemonmade)! - First release of Remote DOM. Read more about this [refactor of remote-ui on native DOM APIs](https://github.com/Shopify/remote-dom/discussions/267), and take a look at the [updated documentation](/README.md).

## 0.1.0

### Minor Changes

- [`7061ded`](https://github.com/Shopify/remote-dom/commit/7061ded1da4699c6dd6a820eeb940a8af7c66d82) Thanks [@lemonmade](https://github.com/lemonmade)! - Test minor bump

## 0.0.2

### Patch Changes

- [#251](https://github.com/Shopify/remote-dom/pull/251) [`5939cca`](https://github.com/Shopify/remote-dom/commit/5939cca8112417124327bd26f9e2c21f4bf9b20a) Thanks [@lemonmade](https://github.com/lemonmade)! - Test version bump



================================================
FILE: packages/polyfill/package.json
================================================
{
  "name": "@remote-dom/polyfill",
  "type": "module",
  "license": "MIT",
  "description": "A polyfill for the browser APIs used by Remote DOM",
  "publishConfig": {
    "access": "public",
    "@remote-dom/registry": "https://registry.npmjs.org"
  },
  "version": "1.5.1",
  "engines": {
    "node": ">=14.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/Shopify/remote-dom",
    "directory": "packages/polyfill"
  },
  "exports": {
    ".": {
      "types": "./build/typescript/index.d.ts",
      "quilt:source": "./source/index.ts",
      "quilt:esnext": "./build/esnext/index.esnext",
      "import": "./build/esm/index.mjs",
      "require": "./build/cjs/index.cjs"
    }
  },
  "types": "./build/typescript/index.d.ts",
  "sideEffects": false,
  "scripts": {
    "build": "rollup --config ./rollup.config.js"
  },
  "browserslist": [
    "defaults and not dead"
  ]
}



================================================
FILE: packages/polyfill/rollup.config.js
================================================
import {quiltPackage} from '@quilted/rollup/package';

export default quiltPackage({commonjs: true});



================================================
FILE: packages/polyfill/tsconfig.json
================================================
{
  "extends": "@quilted/typescript/tsconfig.package.json",
  "references": []
}



================================================
FILE: packages/polyfill/source/Attr.ts
================================================
import {
  NS,
  NEXT,
  VALUE,
  OWNER_ELEMENT,
  NAME,
  NamespaceURI,
  NodeType,
  HOOKS,
} from './constants.ts';
import {Node} from './Node.ts';
import type {Element} from './Element.ts';

export class Attr extends Node {
  nodeType = NodeType.ATTRIBUTE_NODE;
  [NS]: NamespaceURI | null = null;
  [NEXT]: Attr | null = null;
  [VALUE]: string;
  [OWNER_ELEMENT]: Element | null = null;

  constructor(name: string, value: string, namespace?: NamespaceURI | null) {
    super();
    this[NAME] = name;
    this[VALUE] = value;
    if (namespace) this[NS] = namespace;
  }

  get nodeName() {
    return this[NAME];
  }

  set nodeName(_readonly: string) {}
  get name() {
    return this[NAME];
  }

  set name(_readonly: string) {}
  get value() {
    return this[VALUE];
  }

  set value(value: string) {
    const str = String(value);
    this[VALUE] = str;
    const ownerElement = this[OWNER_ELEMENT];
    if (!ownerElement) return;
    this[HOOKS].setAttribute?.(ownerElement as any, this[NAME], str, this[NS]);
  }

  get nodeValue() {
    return this.value;
  }

  set nodeValue(value: string) {
    this.value = value;
  }

  get ownerElement() {
    return this[OWNER_ELEMENT];
  }

  get namespaceURI() {
    return this[NS];
  }

  get specified() {
    return true;
  }
}



================================================
FILE: packages/polyfill/source/CharacterData.ts
================================================
import {DATA, HOOKS} from './constants.ts';
import {ChildNode} from './ChildNode.ts';

export class CharacterData extends ChildNode {
  [DATA] = '';

  constructor(data: any) {
    super();
    this[DATA] = data == null ? '' : String(data);
  }

  protected setData(data: any) {
    let str = '';
    if (data != null) {
      str = typeof data === 'string' ? data : String(data);
    }
    this[DATA] = str;
    this[HOOKS].setText?.(this as any, str);
  }

  get data() {
    return this[DATA];
  }

  set data(data: any) {
    this.setData(data);
  }
}



================================================
FILE: packages/polyfill/source/ChildNode.ts
================================================
import {NEXT} from './constants.ts';
import type {ParentNode} from './ParentNode.ts';
import {Node} from './Node.ts';

export class ChildNode extends Node {
  remove() {
    const parent = this.parentNode;
    if (!parent) return;
    parent.removeChild(this);
  }

  replaceWith(...nodes: (Node | string)[]) {
    const parent = this.parentNode;
    if (!parent) return;
    const node = toNode(parent, nodes[0]);
    const next = node[NEXT];
    parent.replaceChild(this, node);
    for (let i = 1; i < nodes.length; i++) {
      parent.insertBefore(toNode(parent, nodes[i]), next);
    }
  }

  before(...nodes: (Node | string)[]) {
    const parent = this.parentNode;
    if (!parent) return;
    for (const node of nodes) {
      parent.insertBefore(toNode(parent, node), this);
    }
  }

  after(...nodes: (Node | string)[]) {
    const parent = this.parentNode;
    if (!parent) return;
    const next = this[NEXT];
    for (const node of nodes) {
      parent.insertBefore(toNode(parent, node), next);
    }
  }
}

export function toNode(parent: ParentNode, node: Node | any) {
  if (node instanceof Node) return node;
  const ownerDocument = parent.ownerDocument;
  return ownerDocument.createTextNode(String(node));
}



================================================
FILE: packages/polyfill/source/ClipboardEvent.ts
================================================
import {Event} from './Event.ts';

// https://w3c.github.io/clipboard-apis/#clipboardevent-interface
export class ClipboardEvent extends Event {
  readonly clipboardData: ClipboardEventInit['clipboardData'];

  constructor(type: string, eventInitDict: ClipboardEventInit = {}) {
    super(type, eventInitDict);

    this.clipboardData = eventInitDict.clipboardData ?? null;
  }
}



================================================
FILE: packages/polyfill/source/Comment.ts
================================================
import {NAME} from './constants.ts';
import {CharacterData} from './CharacterData.ts';

export class Comment extends CharacterData {
  nodeType = 8;
  [NAME] = '#comment';
}



================================================
FILE: packages/polyfill/source/constants.ts
================================================
export const NAME = Symbol('name');
export const VALUE = Symbol('value');
export const NS = Symbol('ns');
export const OWNER_ELEMENT = Symbol('owner');
export const OWNER_DOCUMENT = Symbol('owner_document');
export const ATTRIBUTES = Symbol('attributes');
export const PREV = Symbol('prev');
export const NEXT = Symbol('next');
export const CHILD = Symbol('child');
export const PARENT = Symbol('parent');
export const DATA = Symbol('data');
export const USER_PROPERTIES = Symbol('user_properties');
export const LISTENERS = Symbol('listeners');
export const IS_TRUSTED = Symbol('isTrusted');
export const PATH = Symbol('path');
export const STOP_IMMEDIATE_PROPAGATION = Symbol('stop_immediate_propagation');
export const CONTENT = Symbol('content');
export const HOOKS = Symbol('hooks');
export const IS_CONNECTED = Symbol('is_connected');

// @TODO remove explicit values
export const enum NodeType {
  NODE = 0,
  ELEMENT_NODE = 1,
  ATTRIBUTE_NODE = 2,
  TEXT_NODE = 3,
  CDATA_SECTION_NODE = 4,
  ENTITY_REFERENCE_NODE = 5,
  ENTITY_NODE = 6,
  PROCESSING_INSTRUCTION_NODE = 7,
  COMMENT_NODE = 8,
  DOCUMENT_NODE = 9,
  DOCUMENT_TYPE_NODE = 10,
  DOCUMENT_FRAGMENT_NODE = 11,
}

export const enum NamespaceURI {
  XHTML = 'http://www.w3.org/1999/xhtml',
  SVG = 'http://www.w3.org/2000/svg',
}



================================================
FILE: packages/polyfill/source/CustomElementRegistry.ts
================================================
export class CustomElementRegistryImplementation
  implements CustomElementRegistry
{
  private registry = new Map<string, CustomElementConstructor>();
  private listenersByName = new Map<
    string,
    ((Constructor: CustomElementConstructor) => void)[]
  >();

  define(
    name: string,
    Constructor: CustomElementConstructor,
    _options?: ElementDefinitionOptions,
  ) {
    this.registry.set(name, Constructor);

    const listeners = this.listenersByName.get(name);

    if (listeners == null) return;

    this.listenersByName.delete(name);

    for (const listener of listeners) {
      listener(Constructor);
    }
  }

  get(name: string) {
    return this.registry.get(name);
  }

  getName(Constructor: CustomElementConstructor) {
    for (const [name, value] of this.registry) {
      if (value === Constructor) return name;
    }

    return null;
  }

  whenDefined(name: string) {
    const Constructor = this.registry.get(name);

    if (Constructor != null) return Promise.resolve(Constructor);

    let listeners = this.listenersByName.get(name);

    if (listeners == null) {
      listeners = [];
      this.listenersByName.set(name, listeners);
    }

    return new Promise<CustomElementConstructor>((resolve) => {
      listeners!.push(resolve);
    });
  }

  upgrade(_root: Node) {
    // TODO
  }
}



================================================
FILE: packages/polyfill/source/CustomEvent.ts
================================================
import {Event} from './Event.ts';

export class CustomEvent<T = any> extends Event {
  /**
   * Returns any custom data event was created with. Typically used for synthetic events.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CustomEvent/detail)
   */
  readonly detail: T;

  constructor(type: string, eventInitDict?: CustomEventInit<T>) {
    super(type, eventInitDict);
    this.detail = eventInitDict?.detail as any;
  }

  /**
   * Returns any custom data event was created with. Typically used for synthetic events.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CustomEvent/detail)
   */
  initCustomEvent(
    type: string,
    bubbles?: boolean,
    cancelable?: boolean,
    detail?: T,
  ) {
    super.initEvent(type, bubbles, cancelable);
    (this as any).detail = detail;
  }
}



================================================
FILE: packages/polyfill/source/Document.ts
================================================
import {
  NS,
  NAME,
  NamespaceURI,
  NodeType,
  OWNER_DOCUMENT,
  HOOKS,
  IS_CONNECTED,
} from './constants.ts';
import type {Window} from './Window.ts';
import type {Node} from './Node.ts';
import {Event} from './Event.ts';
import {ParentNode} from './ParentNode.ts';
import {Element} from './Element.ts';
import {SVGElement} from './SVGElement.ts';
import {Text} from './Text.ts';
import {Comment} from './Comment.ts';
import {DocumentFragment} from './DocumentFragment.ts';
import {HTMLTemplateElement} from './HTMLTemplateElement.ts';
import {isParentNode, cloneNode} from './shared.ts';
import {HTMLBodyElement} from './HTMLBodyElement.ts';
import {HTMLHeadElement} from './HTMLHeadElement.ts';
import {HTMLHtmlElement} from './HTMLHtmlElement.ts';

export class Document extends ParentNode {
  nodeType = NodeType.DOCUMENT_NODE;
  [NAME] = '#document';
  body: HTMLBodyElement;
  head: HTMLHeadElement;
  documentElement: HTMLHtmlElement;
  defaultView: Window;
  [IS_CONNECTED] = true;

  constructor(defaultView: Window) {
    super();
    this.defaultView = defaultView;
    this[OWNER_DOCUMENT] = this;
    this.documentElement = setupElement(new HTMLHtmlElement(), this, 'html');
    this.body = setupElement(new HTMLBodyElement(), this, 'body');
    this.head = setupElement(new HTMLHeadElement(), this, 'head');

    this.appendChild(this.documentElement);
    this.documentElement.appendChild(this.head);
    this.documentElement.appendChild(this.body);
  }

  createElement(localName: string) {
    return createElement(this, localName);
  }

  createElementNS(namespaceURI: NamespaceURI, localName: string) {
    return createElement(this, localName, namespaceURI);
  }

  createTextNode(data: any) {
    const text = createNode(new Text(data), this);
    this[HOOKS].createText?.(text as any, String(data));
    return text;
  }

  createComment(data: any) {
    return createNode(new Comment(data), this);
  }

  createDocumentFragment() {
    return createNode(new DocumentFragment(), this);
  }

  createEvent() {
    return new Event('');
  }

  importNode(node: Node, deep?: boolean) {
    return cloneNode(node, deep, this);
  }

  adoptNode(node: Node) {
    if (node[OWNER_DOCUMENT] === this) return node;

    node.parentNode?.removeChild(node);
    adoptNode(node, this);

    return node;
  }
}

export function createNode<T extends Node>(node: T, ownerDocument: Document) {
  Object.defineProperty(node, OWNER_DOCUMENT, {
    value: ownerDocument,
    writable: true,
    enumerable: false,
  });

  return node;
}

export function createElement<T extends Element>(
  ownerDocument: Document,
  name: string,
  namespace?: NamespaceURI,
) {
  let element: T;
  const lowerName = String(name).toLowerCase();

  if (namespace === NamespaceURI.SVG) {
    element = new SVGElement() as any;
  } else if (lowerName === 'template') {
    element = new HTMLTemplateElement() as any;
  } else {
    const CustomElement = ownerDocument.defaultView.customElements.get(name);
    element = CustomElement ? (new CustomElement() as any) : new Element();
  }

  return setupElement(element, ownerDocument, name, namespace);
}

export function setupElement<T extends Element>(
  element: T,
  ownerDocument: Document,
  name: string,
  namespace?: NamespaceURI,
) {
  createNode(element, ownerDocument);

  Object.defineProperty(element, NAME, {value: name});

  if (namespace) {
    Object.defineProperty(element, NS, {value: namespace});
  }

  ownerDocument[HOOKS].createElement?.(element as any, namespace);

  return element;
}

export function adoptNode(node: Node, document: Document) {
  node[OWNER_DOCUMENT] = document;

  if (isParentNode(node)) {
    for (const child of node.childNodes) {
      adoptNode(child, document);
    }
  }
}



================================================
FILE: packages/polyfill/source/DocumentFragment.ts
================================================
import {NAME, OWNER_DOCUMENT, NodeType} from './constants.ts';
import {ParentNode} from './ParentNode.ts';

export class DocumentFragment extends ParentNode {
  nodeType = NodeType.DOCUMENT_FRAGMENT_NODE;
  [NAME] = '#document-fragment';
  [OWNER_DOCUMENT] = (typeof window !== 'undefined'
    ? window.document
    : null) as any;
}



================================================
FILE: packages/polyfill/source/Element.ts
================================================
import {NS, ATTRIBUTES, NamespaceURI, NodeType} from './constants.ts';
import {ParentNode} from './ParentNode.ts';
import {NamedNodeMap} from './NamedNodeMap.ts';
import {Attr} from './Attr.ts';
import {serializeNode, serializeChildren, parseHtml} from './serialization.ts';

export class Element extends ParentNode {
  static readonly observedAttributes?: string[];

  nodeType = NodeType.ELEMENT_NODE;

  [NS] = NamespaceURI.XHTML;
  get namespaceURI() {
    return this[NS];
  }

  get tagName() {
    return this.nodeName;
  }

  [ATTRIBUTES]!: NamedNodeMap;

  [anyProperty: string]: any;

  get slot() {
    return this.getAttribute('slot') ?? '';
  }

  set slot(slot: string) {
    const finalSlot = String(slot);

    if (this.getAttribute('slot') !== finalSlot) {
      this.attributes.setNamedItem(new Attr('slot', finalSlot));
    }
  }

  get attributes() {
    let attributes = this[ATTRIBUTES];
    if (!attributes) {
      attributes = new NamedNodeMap(this);
      this[ATTRIBUTES] = attributes;
    }
    return attributes;
  }

  getAttributeNames() {
    return [...this.attributes].map((attr) => attr.name);
  }

  get firstElementChild() {
    return this.children[0] ?? null;
  }

  get lastElementChild() {
    return this.children[this.children.length - 1] ?? null;
  }

  get nextElementSibling() {
    let sib = this.nextSibling;
    while (sib && sib.nodeType !== 1) sib = sib.nextSibling;
    return sib;
  }

  get previousElementSibling() {
    let sib = this.previousSibling;
    while (sib && sib.nodeType !== 1) sib = sib.previousSibling;
    return sib;
  }

  setAttribute(name: string, value: string) {
    this.attributes.setNamedItem(new Attr(name, String(value)));
  }

  setAttributeNS(namespace: NamespaceURI | null, name: string, value: string) {
    this.attributes.setNamedItemNS(new Attr(name, String(value), namespace));
  }

  getAttribute(name: string) {
    const attr = this.attributes.getNamedItem(name);
    return attr && attr.value;
  }

  getAttributeNS(namespace: NamespaceURI | null, name: string) {
    const attr = this.attributes.getNamedItemNS(namespace, name);
    return attr && attr.value;
  }

  hasAttribute(name: string) {
    const attr = this.attributes.getNamedItem(name);
    return attr != null;
  }

  hasAttributeNS(namespace: NamespaceURI | null, name: string) {
    const attr = this.attributes.getNamedItemNS(namespace, name);
    return attr != null;
  }

  removeAttribute(name: string) {
    this.attributes.removeNamedItem(name);
  }

  removeAttributeNS(namespace: NamespaceURI | null, name: string) {
    this.attributes.removeNamedItemNS(namespace, name);
  }

  get outerHTML() {
    return serializeNode(this);
  }

  get innerHTML() {
    return serializeChildren(this);
  }

  set innerHTML(html: any) {
    if (html == null || html === '') {
      this.replaceChildren();
    } else {
      const fragment = parseHtml(String(html), this);
      this.replaceChildren(fragment);
    }
  }
}



================================================
FILE: packages/polyfill/source/ErrorEvent.ts
================================================
import {Event} from './Event.ts';

// https://html.spec.whatwg.org/multipage/webappapis.html#errorevent
export class ErrorEvent extends Event {
  readonly message: ErrorEventInit['message'];
  readonly filename: ErrorEventInit['filename'];
  readonly lineno: ErrorEventInit['lineno'];
  readonly colno: ErrorEventInit['colno'];
  readonly error: ErrorEventInit['error'];

  constructor(type: string, eventInitDict: ErrorEventInit) {
    super(type, eventInitDict);

    this.message = eventInitDict.message;
    this.filename = eventInitDict.filename;
    this.lineno = eventInitDict.lineno;
    this.colno = eventInitDict.colno;
    this.error = eventInitDict.error;
  }
}



================================================
FILE: packages/polyfill/source/Event.ts
================================================
import {
  PATH,
  IS_TRUSTED,
  LISTENERS,
  STOP_IMMEDIATE_PROPAGATION,
} from './constants.ts';
import type {EventTarget} from './EventTarget.ts';

export const enum EventPhase {
  NONE = 0,
  CAPTURING_PHASE = 1,
  AT_TARGET = 2,
  BUBBLING_PHASE = 3,
}

export const CAPTURE_MARKER = '@';

export interface EventInit {
  bubbles?: boolean;
  cancelable?: boolean;
  composed?: boolean;
}

const now =
  typeof performance === 'undefined'
    ? Date.now
    : performance.now.bind(performance);

export class Event {
  static NONE = EventPhase.NONE;
  static CAPTURING_PHASE = EventPhase.CAPTURING_PHASE;
  static AT_TARGET = EventPhase.AT_TARGET;
  static BUBBLING_PHASE = EventPhase.BUBBLING_PHASE;

  // NONE = EventPhase.NONE;
  // CAPTURING_PHASE = EventPhase.CAPTURING_PHASE;
  // AT_TARGET = EventPhase.AT_TARGET;
  // BUBBLING_PHASE = EventPhase.BUBBLING_PHASE;

  timeStamp = now();
  target: EventTarget | null = null;
  currentTarget: EventTarget | null = null;
  srcElement: EventTarget | null = null;
  bubbles = false;
  cancelable = false;
  composed = false;
  defaultPrevented = false;
  cancelBubble = false;
  eventPhase: EventPhase = 0;
  // private inPassiveListener = false;
  data?: any;
  [PATH]: EventTarget[] = [];
  [IS_TRUSTED]!: boolean;
  [STOP_IMMEDIATE_PROPAGATION] = false;

  constructor(
    public type: string,
    options?: EventInit,
  ) {
    Object.defineProperty(this, IS_TRUSTED, {writable: true, value: false});
    if (options) {
      if (options.bubbles) this.bubbles = options.bubbles;
      if (options.cancelable) this.cancelable = options.cancelable;
      if (options.composed) this.composed = options.composed;
    }
  }

  get isTrusted() {
    return this[IS_TRUSTED];
  }

  composedPath() {
    return this[PATH];
  }

  stopPropagation() {
    this.cancelBubble = true;
  }

  stopImmediatePropagation() {
    this[STOP_IMMEDIATE_PROPAGATION] = true;
    this.cancelBubble = true;
  }

  preventDefault() {
    this.defaultPrevented = true;
  }

  set returnValue(value) {
    this.defaultPrevented = value;
  }

  get returnValue() {
    return this.defaultPrevented;
  }

  /** @deprecated */
  initEvent(type: string, bubbles?: boolean, cancelable?: boolean) {
    this.type = type;
    this.bubbles = Boolean(bubbles);
    this.cancelable = Boolean(cancelable);
  }
}

export function fireEvent(
  event: Event,
  currentTarget: EventTarget,
  phase: EventPhase.BUBBLING_PHASE | EventPhase.CAPTURING_PHASE,
): void {
  const listeners = currentTarget[LISTENERS];
  const list = listeners?.get(
    `${event.type}${
      phase === EventPhase.CAPTURING_PHASE ? CAPTURE_MARKER : ''
    }`,
  );

  if (!list) return;

  for (const listener of list) {
    event.eventPhase =
      event.target === currentTarget ? EventPhase.AT_TARGET : phase;
    event.currentTarget = currentTarget;

    try {
      if (typeof listener === 'object') {
        listener.handleEvent(event as any);
      } else {
        listener.call(currentTarget, event as any);
      }
    } catch (err) {
      setTimeout(thrower, 0, err);
    }

    if (event[STOP_IMMEDIATE_PROPAGATION]) break;
  }
}

function thrower(error: any) {
  throw error;
}



================================================
FILE: packages/polyfill/source/EventTarget.ts
================================================
import {HOOKS, PATH, LISTENERS, OWNER_DOCUMENT} from './constants.ts';
import {fireEvent, EventPhase} from './Event.ts';
import {CAPTURE_MARKER, type Event} from './Event.ts';
import type {ChildNode} from './ChildNode.ts';
import type {Document} from './Document.ts';

const ONCE_LISTENERS = Symbol('onceListeners');

export class EventTarget {
  [LISTENERS]:
    | Map<string, Set<EventListenerOrEventListenerObject>>
    | undefined = undefined;

  [ONCE_LISTENERS]:
    | WeakMap<EventListenerOrEventListenerObject, EventListener>
    | undefined = undefined;

  /**
   * Property set by entities that extend this class that are part of the DOM tree.
   * @internal
   */
  [OWNER_DOCUMENT]: Document | undefined = undefined;

  addEventListener(
    type: string,
    listener: EventListenerOrEventListenerObject | null,
    options?: boolean | AddEventListenerOptions,
  ) {
    if (listener == null) return;

    const capture = options === true || (options && options.capture === true);
    const once = typeof options === 'object' && options.once === true;
    const signal = typeof options === 'object' ? options.signal : undefined;
    const key = `${type}${capture ? CAPTURE_MARKER : ''}`;
    let normalizedListener = listener;

    if (once) {
      normalizedListener = function normalizedListener(
        this: EventTarget,
        ...args: Parameters<EventListener>
      ) {
        this.removeEventListener(type, listener, options);

        return typeof listener === 'object'
          ? listener.handleEvent(...args)
          : listener.call(this, ...args);
      };

      let onceListeners = this[ONCE_LISTENERS];
      if (!onceListeners) {
        onceListeners = new WeakMap();
        this[ONCE_LISTENERS] = onceListeners;
      }

      onceListeners.set(listener, normalizedListener);
    }

    let listeners = this[LISTENERS];
    if (!listeners) {
      listeners = new Map();
      this[LISTENERS] = listeners;
    }

    let list = listeners.get(key);
    if (!list) {
      list = new Set();
      listeners.set(key, list);
    }

    if (list.has(normalizedListener)) return;

    signal?.addEventListener(
      'abort',
      () => {
        removeEventListener.call(this, type, listener, options);
      },
      {once: true},
    );

    list.add(normalizedListener);
    this[OWNER_DOCUMENT]?.defaultView[HOOKS].addEventListener?.(
      this as any,
      type,
      listener,
      options,
    );
  }

  removeEventListener(
    type: string,
    listener: EventListenerOrEventListenerObject | null,
    options?: boolean | EventListenerOptions,
  ) {
    return removeEventListener.call(this, type, listener, options);
  }

  // function isChildNode(node: EventTarget): node is ChildNode {
  //   return PARENT in node;
  // }

  dispatchEvent(event: Event) {
    const path: EventTarget[] = [];
    // instanceof here is just to keep TypeScript happy
    let target = this as unknown as ChildNode | null;
    while (target != null) {
      path.push(target);
      target = target.parentNode;
    }
    // while (target instanceof Node && (target = target.parentNode)) {
    //   path.push(target);
    // }
    event.target = this;
    event.srcElement = this;
    event[PATH] = path;

    for (let i = path.length; i--; ) {
      fireEvent(event, path[i]!, EventPhase.CAPTURING_PHASE);
      if (event.cancelBubble) return event.defaultPrevented;
    }

    const bubblePath = event.bubbles ? path : path.slice(0, 1);

    for (let i = 0; i < bubblePath.length; i++) {
      fireEvent(event, bubblePath[i]!, EventPhase.BUBBLING_PHASE);
      if (event.cancelBubble) return event.defaultPrevented;
    }

    return event.defaultPrevented;
  }
}

function removeEventListener(
  this: EventTarget,
  type: string,
  listener: EventListenerOrEventListenerObject | null,
  options?: boolean | EventListenerOptions,
) {
  if (listener == null) return;

  const onceListeners = this[ONCE_LISTENERS];
  const normalizedListener = onceListeners?.get(listener) ?? listener;

  onceListeners?.delete(listener);

  const capture = options === true || (options && options.capture === true);
  const key = `${type}${capture ? CAPTURE_MARKER : ''}`;
  const list = this[LISTENERS]?.get(key);

  if (list) {
    const deleted = list.delete(normalizedListener);
    if (deleted) {
      this[OWNER_DOCUMENT]?.defaultView[HOOKS].removeEventListener?.(
        this as any,
        type,
        listener,
        options,
      );
    }
  }
}



================================================
FILE: packages/polyfill/source/FocusEvent.ts
================================================
import {Event} from './Event.ts';

// https://w3c.github.io/uievents/#interface-focusevent
export class FocusEvent extends Event {
  readonly relatedTarget: FocusEventInit['relatedTarget'];

  constructor(type: string, eventInitDict: FocusEventInit = {}) {
    super(type, eventInitDict);

    this.relatedTarget = eventInitDict.relatedTarget ?? null;
  }
}



================================================
FILE: packages/polyfill/source/hooks.ts
================================================
export interface Hooks {
  createElement(element: Element, ns?: string | null): void;
  setAttribute(
    element: Element,
    name: string,
    value: string,
    ns?: string | null,
  ): void;
  removeAttribute(element: Element, name: string, ns?: string | null): void;
  createText(text: Text, data: string): void;
  setText(text: Text, data: string): void;
  insertChild(parent: Element, node: Element | Text, index: number): void;
  removeChild(parent: Element, node: Element | Text, index: number): void;
  addEventListener(
    element: EventTarget,
    type: string,
    listener: EventListenerOrEventListenerObject | null,
    options?: boolean | AddEventListenerOptions,
  ): void;
  removeEventListener(
    element: EventTarget,
    type: string,
    listener: EventListenerOrEventListenerObject | null,
    options?: boolean | EventListenerOptions,
  ): void;
}



================================================
FILE: packages/polyfill/source/HTMLBodyElement.ts
================================================
import {Element} from './Element.ts';

export class HTMLBodyElement extends Element {}



================================================
FILE: packages/polyfill/source/HTMLElement.ts
================================================
import {Element} from './Element.ts';

export class HTMLElement extends Element {}



================================================
FILE: packages/polyfill/source/HTMLHeadElement.ts
================================================
import {Element} from './Element.ts';

export class HTMLHeadElement extends Element {}



================================================
FILE: packages/polyfill/source/HTMLHtmlElement.ts
================================================
import {Element} from './Element.ts';

export class HTMLHtmlElement extends Element {}



================================================
FILE: packages/polyfill/source/HTMLTemplateElement.ts
================================================
import {CONTENT} from './constants.ts';
import {DocumentFragment} from './DocumentFragment.ts';
import {Element} from './Element.ts';
import {parseHtml, serializeChildren} from './serialization.ts';

export class HTMLTemplateElement extends Element {
  [CONTENT]?: DocumentFragment;

  get content() {
    let content = this[CONTENT];
    if (!content) {
      content = this.ownerDocument.createDocumentFragment();
      this[CONTENT] = content;
    }
    return content;
  }

  set content(_) {}

  set innerHTML(html) {
    this.content.replaceChildren(parseHtml(String(html), this));
  }

  get innerHTML() {
    const content = this[CONTENT];
    return content ? serializeChildren(content) : '';
  }
}



================================================
FILE: packages/polyfill/source/index.ts
================================================
export {type Hooks} from './hooks.ts';
export {HOOKS} from './constants.ts';
export {Window} from './Window.ts';
export {HTMLElement} from './HTMLElement.ts';



================================================
FILE: packages/polyfill/source/MutationObserver.ts
================================================
export class MutationObserver {
  // stub implementation
}



================================================
FILE: packages/polyfill/source/NamedNodeMap.ts
================================================
import {
  CHILD,
  OWNER_ELEMENT,
  NS,
  NEXT,
  NamespaceURI,
  HOOKS,
} from './constants.ts';
import type {Attr} from './Attr.ts';
import type {Element} from './Element.ts';

export class NamedNodeMap {
  [CHILD]: Attr | null = null;
  [OWNER_ELEMENT]: Element;

  constructor(ownerElement: Element) {
    this[OWNER_ELEMENT] = ownerElement;
  }

  getNamedItem(name: string) {
    return this.getNamedItemNS(null, name);
  }

  getNamedItemNS(namespaceURI: NamespaceURI | null, name: string) {
    let attr = this[CHILD];
    while (attr) {
      if (attr.name === name && attr[NS] == namespaceURI) {
        return attr;
      }
      attr = attr[NEXT];
    }
    return null;
  }

  item(index: number) {
    let attr = this[CHILD];
    let i = 0;
    while (attr) {
      if (i++ === index) return attr;
      attr = attr[NEXT];
    }
    return null;
  }

  get length() {
    let index = 0;
    let attr = this[CHILD];
    while (attr) {
      index++;
      attr = attr[NEXT];
    }
    return index;
  }

  removeNamedItem(name: string) {
    return this.removeNamedItemNS(null, name);
  }

  removeNamedItemNS(namespaceURI: NamespaceURI | null, name: string) {
    const ownerElement = this[OWNER_ELEMENT];
    let attr = this[CHILD];
    let prev: typeof attr | null = null;

    while (attr != null) {
      if (attr.name === name && attr[NS] == namespaceURI) {
        if (prev) prev[NEXT] = attr[NEXT];
        if (this[CHILD] === attr) this[CHILD] = attr[NEXT];
        updateElementAttribute(ownerElement, attr.name, attr.value, null);
        ownerElement[HOOKS].removeAttribute?.(
          ownerElement as any,
          name,
          namespaceURI,
        );
        return attr;
      }

      prev = attr;
      attr = attr[NEXT];
    }

    return null;
  }

  setNamedItem(attr: Attr) {
    const ownerElement = this[OWNER_ELEMENT];
    let old = null;
    let child = this[CHILD];
    attr[OWNER_ELEMENT] = ownerElement;
    if (child == null) {
      this[CHILD] = attr;
      // return null;
    } else {
      let prev;
      while (child) {
        if (child.name === attr.name && child[NS] == attr[NS]) {
          if (prev) prev[NEXT] = attr;
          else this[CHILD] = attr;
          attr[NEXT] = child[NEXT];
          child[NEXT] = null;
          old = child;
          break;
          // return child;
        }
        prev = child;
        child = child[NEXT];
      }
      if (prev) prev[NEXT] = attr;
      else this[CHILD] = attr;
      // return null;
    }

    // only invoke the protocol if the value changed
    if (!old || old.value !== attr.value) {
      updateElementAttribute(
        ownerElement,
        attr.name,
        old?.value ?? null,
        attr.value,
      );

      ownerElement[HOOKS].setAttribute?.(
        ownerElement as any,
        attr.name,
        attr.value,
        attr[NS],
      );
    }

    return old;
  }

  setNamedItemNS(attr: Attr) {
    return this.setNamedItem(attr);
  }

  *[Symbol.iterator]() {
    let attr = this[CHILD];
    while (attr) {
      yield attr;
      attr = attr[NEXT];
    }
  }
}

function updateElementAttribute(
  element: Element,
  name: string,
  oldValue: string | null,
  newValue: string | null,
) {
  const {observedAttributes} = element.constructor as typeof Element;
  const {attributeChangedCallback} = element;

  if (name === 'slot') {
    element.slot = newValue ?? '';
  }

  if (
    attributeChangedCallback == null ||
    observedAttributes == null ||
    !observedAttributes.includes(name)
  ) {
    return;
  }

  return attributeChangedCallback.call(element, name, oldValue, newValue);
}



================================================
FILE: packages/polyfill/source/Node.ts
================================================
import {
  OWNER_DOCUMENT,
  NAME,
  PARENT,
  CHILD,
  PREV,
  NEXT,
  NamespaceURI,
  NodeType,
  HOOKS,
  IS_CONNECTED,
} from './constants.ts';
import type {Document} from './Document.ts';
import type {ParentNode} from './ParentNode.ts';
import {EventTarget} from './EventTarget.ts';
import {
  isCharacterData,
  isParentNode,
  isTextNode,
  cloneNode,
  descendants,
} from './shared.ts';

export class Node extends EventTarget {
  nodeType = NodeType.NODE;

  [OWNER_DOCUMENT]!: Document;
  [NAME] = '';
  [PARENT]: ParentNode | null = null;
  [CHILD]: Node | null = null;
  [PREV]: Node | null = null;
  [NEXT]: Node | null = null;
  [IS_CONNECTED] = false;

  protected get [HOOKS]() {
    return this[OWNER_DOCUMENT].defaultView[HOOKS];
  }

  get localName() {
    return this[NAME];
  }

  get nodeName() {
    return this[NAME].toUpperCase();
  }

  get ownerDocument() {
    return this[OWNER_DOCUMENT];
  }

  get isConnected() {
    return this[IS_CONNECTED];
  }

  isDefaultNamespace(namespace: string) {
    return namespace === NamespaceURI.XHTML;
  }

  get parentNode() {
    return this[PARENT];
  }

  set parentNode(_readonly) {}

  get parentElement(): ParentNode | null {
    const parent = this[PARENT];
    if (!parent || parent.nodeType !== 1) return null;
    return parent;
  }

  set parentElement(_readonly) {}

  get previousSibling() {
    return this[PREV];
  }

  set previousSibling(_readonly) {}

  get nextSibling() {
    return this[NEXT];
  }

  set nextSibling(_readonly) {}

  get previousElementSibling() {
    let sib = this[PREV];
    while (sib && sib.nodeType !== 1) sib = sib[PREV];
    return sib;
  }

  set previousElementSibling(_readonly) {}

  get nextElementSibling() {
    let sib = this[NEXT];
    while (sib && sib.nodeType !== 1) sib = sib[NEXT];
    return sib;
  }

  set nextElementSibling(_readonly) {}

  get firstChild() {
    return this[CHILD];
  }

  set firstChild(_readonly) {}

  get lastChild() {
    let child = this[CHILD];
    while (child) {
      const next = child[NEXT];
      if (next == null) break;
      child = next;
    }
    return child;
  }

  set lastChild(_readonly) {}

  get nodeValue(): string | null {
    if (isCharacterData(this)) return this.data;
    return null;
  }

  set nodeValue(data: string | null | undefined) {
    if (isCharacterData(this)) this.data = data;
  }

  get textContent(): string | null {
    if (isCharacterData(this)) return this.data;
    let text = '';

    for (const node of descendants(this)) {
      if (isTextNode(node)) {
        text += node.data;
      }
    }

    return text;
  }

  set textContent(data: any) {
    if (isCharacterData(this)) {
      this.data = data;
    } else if (isParentNode(this)) {
      let child;
      while ((child = this[CHILD])) {
        this.removeChild(child);
      }
      this.append(data);
    }
  }

  cloneNode(deep?: boolean) {
    return cloneNode(this, deep);
  }

  contains(node: Node | null) {
    let currentNode: Node | null = node;

    while (true) {
      if (currentNode == null) return false;
      if (currentNode === this) return true;
      currentNode = node!.parentNode;
    }
  }
}



================================================
FILE: packages/polyfill/source/NodeList.ts
================================================
export class NodeList extends Array {
  item(index: number) {
    return this[index];
  }
}



================================================
FILE: packages/polyfill/source/ParentNode.ts
================================================
import {
  CHILD,
  NEXT,
  PREV,
  PARENT,
  OWNER_DOCUMENT,
  NodeType,
  HOOKS,
  IS_CONNECTED,
} from './constants.ts';
import type {Node} from './Node.ts';
import {ChildNode, toNode} from './ChildNode.ts';
import {NodeList} from './NodeList.ts';
import {querySelectorAll, querySelector} from './selectors.ts';
import {selfAndDescendants} from './shared.ts';

export class ParentNode extends ChildNode {
  readonly childNodes = new NodeList();
  readonly children = new NodeList();

  appendChild(child: Node) {
    this.insertInto(child, null);
  }

  insertBefore(child: Node, ref?: Node | null) {
    this.insertInto(child, ref || null);
  }

  append(...nodes: (Node | string)[]) {
    for (const child of nodes) {
      if (child == null) continue;
      this.appendChild(toNode(this, child));
    }
  }

  prepend(...nodes: (Node | string)[]) {
    const before = this.firstChild;
    for (const child of nodes) {
      if (child == null) continue;
      this.insertBefore(toNode(this, child), before);
    }
  }

  replaceChildren(...nodes: (Node | string)[]) {
    let child;
    while ((child = this.firstChild)) {
      this.removeChild(child);
    }
    this.append(...nodes);
  }

  removeChild(child: Node) {
    if (child.parentNode !== this) throw Error(`not a child of this node`);
    const prev = child[PREV];
    const next = child[NEXT];
    if (prev) prev[NEXT] = next;
    else this[CHILD] = next;
    if (next) next[PREV] = prev;

    const childNodes = this.childNodes;

    const childNodesIndex = childNodes.indexOf(child);

    childNodes.splice(childNodesIndex, 1);

    if (child.nodeType === 1) {
      const children = this.children;
      children.splice(children.indexOf(child), 1);
    }

    child[PARENT] = null;
    child[NEXT] = null;
    child[PREV] = null;

    if (this[IS_CONNECTED]) {
      for (const node of selfAndDescendants(child)) {
        node[IS_CONNECTED] = false;
        (node as any).disconnectedCallback?.();
      }
    }

    if (this.nodeType === NodeType.ELEMENT_NODE) {
      this[HOOKS].removeChild?.(this as any, child as any, childNodesIndex);
    }
  }

  replaceChild(newChild: Node, oldChild: Node) {
    if (oldChild.parentNode !== this) {
      throw Error('reference node is not a child of this parent');
    }
    const next = oldChild[NEXT];
    this.removeChild(oldChild);
    this.insertInto(newChild, next);
  }

  querySelectorAll(selector: string) {
    return querySelectorAll(this, selector);
  }

  querySelector(selector: string) {
    return querySelector(this, selector);
  }

  private insertInto(child: Node, before: Node | null) {
    // append the children of a DocumentFragment:
    if (child.nodeType === NodeType.DOCUMENT_FRAGMENT_NODE) {
      let node = child[CHILD];
      while (node) {
        const next = node[NEXT];
        this.insertInto(node, before);
        node = next;
      }
      return;
    }

    if (child.parentNode !== null) {
      child.parentNode.removeChild(child);
    }

    if (before) {
      if (before.parentNode !== this) {
        throw Error('reference node is not a child of this parent');
      }
      child[NEXT] = before;
      child[PREV] = before[PREV];
      if (before[PREV] === null) this[CHILD] = child;
      before[PREV] = child;
    } else {
      child[NEXT] = null;
      let last = this[CHILD];
      if (last) {
        let next;
        while ((next = last[NEXT])) last = next;
        last[NEXT] = child;
        child[PREV] = last;
      } else {
        this[CHILD] = child;
        child[PREV] = null;
      }
    }

    const ownerDocument = this[OWNER_DOCUMENT];
    const isElement = child.nodeType === NodeType.ELEMENT_NODE;

    child[PARENT] = this;
    child[OWNER_DOCUMENT] = ownerDocument;

    const childNodes = this.childNodes;
    let insertIndex: number;

    if (before) {
      insertIndex = childNodes.indexOf(before);
      childNodes.splice(insertIndex, 0, child);

      if (isElement) {
        const children = this.children;
        let ref: Node | null = before;
        while (ref && ref.nodeType !== 1) ref = ref[NEXT];
        if (ref) {
          children.splice(children.indexOf(ref), 0, child);
        } else {
          children.push(child);
        }
      }
    } else {
      insertIndex = childNodes.length;
      childNodes.push(child);
      if (isElement) this.children.push(child);
    }

    if (this[IS_CONNECTED]) {
      for (const node of selfAndDescendants(child)) {
        node[IS_CONNECTED] = true;
        (node as any).connectedCallback?.();
      }
    }

    if (this.nodeType === NodeType.ELEMENT_NODE) {
      this[HOOKS].insertChild?.(this as any, child as any, insertIndex);
    }
  }
}



================================================
FILE: packages/polyfill/source/PromiseRejectionEvent.ts
================================================
import {Event} from './Event.ts';

//https://html.spec.whatwg.org/multipage/webappapis.html#promiserejectionevent
export class PromiseRejectionEvent extends Event {
  readonly promise: PromiseRejectionEventInit['promise'];
  readonly reason: PromiseRejectionEventInit['reason'];

  constructor(type: string, eventInitDict: PromiseRejectionEventInit) {
    super(type, eventInitDict);

    this.promise = eventInitDict.promise;
    this.reason = eventInitDict.reason;
  }
}



================================================
FILE: packages/polyfill/source/selectors.ts
================================================
import {CHILD, NEXT, PARENT, PREV} from './constants.ts';
import {isElementNode} from './shared.ts';

import type {Node} from './Node.ts';
import type {Element} from './Element.ts';
import type {ParentNode} from './ParentNode.ts';

const enum Combinator {
  Descendant,
  Child,
  Sibling,
  Adjacent,
  Inner,
}

const enum MatcherType {
  Unknown,
  Element,
  Id,
  Class,
  Attribute,
  Pseudo,
  Function,
}

interface Part {
  combinator: Combinator;
  matchers: Matcher[];
}

interface Matcher {
  type: MatcherType;
  name: string;
  value?: string;
}

const ELEMENT_SELECTOR_TEST = /[a-z]/;

export function querySelector(within: ParentNode, selector: string) {
  const parts = parseSelector(selector);
  let result: Element | null = null;

  const child = within[CHILD];
  if (child && parts[0]!.matchers.length) {
    walkNodesForSelector(child, parts, (node) => {
      result = node;
      return false;
    });
  }
  return result;
}

export function querySelectorAll(within: ParentNode, selector: string) {
  const parts = parseSelector(selector);
  const results: Element[] = [];

  const child = within[CHILD];
  if (child && parts[0]!.matchers.length) {
    walkNodesForSelector(child, parts, (node) => {
      results.push(node);
    });
  }
  return results;
}

export function parseSelector(selector: string) {
  let part: Part = {combinator: Combinator.Inner, matchers: []};
  const parts = [part];
  const tokenizer =
    /\s*?([>\s+~]?)\s*?(?:(?:\[\s*([^\]=]+)(?:=(['"])(.*?)\3)?\s*\])|([#.]?)([^\s#.[>:+~]+)|:(\w+)(?:\((.*?)\))?)/gi;
  let token;
  while ((token = tokenizer.exec(selector))) {
    // [1]: ancestor/parent/sibling/adjacent
    // [2]: attribute name
    // [4]: attribute value
    // [5]: id/class sigil
    // [6]: id/class name
    // [7]: :pseudo/:function() name
    // [8]: :function(argument) value
    if (token[1]) {
      // Update the combinator on the (now parent) Part:
      if (token[1] === '>') part.combinator = Combinator.Child;
      else if (token[1] === '+') part.combinator = Combinator.Adjacent;
      else if (token[1] === '~') part.combinator = Combinator.Sibling;
      else part.combinator = Combinator.Descendant;
      // Add a new Part for the next selector parts:
      part = {combinator: Combinator.Inner, matchers: []};
      parts.push(part);
    }

    let type = MatcherType.Unknown;
    if (token[2]) {
      type = MatcherType.Attribute;
    } else if (token[5]) {
      type = token[5] === '#' ? MatcherType.Id : MatcherType.Class;
    } else if (token[7]) {
      type = token[8] == null ? MatcherType.Pseudo : MatcherType.Function;
    } else if (token[6]) {
      if (token[6] === '*') {
        type = MatcherType.Unknown; // Universal selector matches all
      } else if (ELEMENT_SELECTOR_TEST.test(token[6])) {
        type = MatcherType.Element;
      }
    }
    part.matchers.push({
      type,
      name: (token[2] || token[6] || token[7])!,
      value: token[4] ?? token[6] ?? token[8],
    });
  }
  return parts;
}

function matchesSelector(element: Element, selector: string) {
  const parsed = parseSelector(selector);
  let part: Part | undefined;
  while ((part = parsed.pop())) {
    if (!matchesSelectorPart(element, part)) return false;
  }
  return true;
}

function walkNodesForSelector(
  node: Node,
  parts: Part[],
  callback: (node: Element) => boolean | void,
) {
  if (isElementNode(node)) {
    if (matchesSelectorRecursive(node, parts)) {
      if (callback(node) === false) return false;
    }
    const child = node[CHILD];
    if (child && walkNodesForSelector(child, parts, callback) === false) {
      return false;
    }
  }
  const next = node[NEXT];
  if (next && walkNodesForSelector(next, parts, callback) === false) {
    return false;
  }
  return true;
}

function matchesSelectorRecursive(element: Element, parts: Part[]): boolean {
  const {combinator, matchers} = parts[parts.length - 1]!;
  if (combinator === Combinator.Inner) {
    if (!matchesSelectorMatcher(element, matchers)) return false;
    const pp = parts.slice(0, -1);
    return pp.length === 0 || matchesSelectorRecursive(element, pp);
  }
  const link =
    combinator === Combinator.Child || combinator === Combinator.Descendant
      ? PARENT
      : PREV;
  let ref = element[link];
  if (!ref) return false;

  if (
    combinator === Combinator.Descendant ||
    combinator === Combinator.Sibling
  ) {
    // For descendant/sibling combinators, search through all ancestors/siblings
    while (ref) {
      if (isElementNode(ref) && matchesSelectorMatcher(ref, matchers)) {
        const pp = parts.slice(0, -1);
        if (pp.length === 0) return true;
        if (matchesSelectorRecursive(element, pp)) return true;
      }
      ref = ref[link];
    }
    return false;
  } else {
    // For child/adjacent combinators, check only the immediate parent/sibling
    // For sibling combinators, skip non-element siblings
    if (combinator === Combinator.Adjacent && !isElementNode(ref)) {
      // Skip to next element sibling
      while (ref && !isElementNode(ref)) {
        ref = ref[link];
      }
      if (!ref) return false;
    }

    if (!isElementNode(ref) || !matchesSelectorMatcher(ref, matchers)) {
      return false;
    }
    const pp = parts.slice(0, -1);
    return pp.length === 0 || matchesSelectorRecursive(element, pp);
  }
}

function matchesSelectorPart(element: Element, {combinator, matchers}: Part) {
  if (combinator === Combinator.Inner) {
    return matchesSelectorMatcher(element, matchers);
  }
  const link =
    combinator === Combinator.Child || combinator === Combinator.Descendant
      ? PARENT
      : PREV;
  let ref = element[link];
  if (!ref) return false;

  // For sibling combinators, skip non-element siblings
  if (combinator === Combinator.Adjacent && !isElementNode(ref)) {
    while (ref && !isElementNode(ref)) {
      ref = ref[link];
    }
    if (!ref) return false;
  }

  if (!isElementNode(ref) || !matchesSelectorMatcher(ref, matchers)) {
    return false;
  }

  if (
    combinator === Combinator.Descendant ||
    combinator === Combinator.Sibling
  ) {
    while ((ref = ref[link])) {
      if (isElementNode(ref) && matchesSelectorMatcher(ref, matchers))
        return true;
    }
  }
  return true;
}

function matchesSelectorMatcher(
  element: Element | null,
  matcher: Matcher | Matcher[],
) {
  if (!element) return false;
  if (Array.isArray(matcher)) {
    for (const single of matcher) {
      if (matchesSelectorMatcher(element, single) === false) return false;
    }
    return true;
  }
  const {type, name, value} = matcher;
  switch (type) {
    case MatcherType.Unknown:
      return name === '*'; // Universal selector
    case MatcherType.Element:
      return element.localName === name;
    case MatcherType.Id:
      return element.getAttribute('id') === name;
    case MatcherType.Class:
      const classAttr = element.getAttribute('class');
      if (!classAttr) return false;
      return classAttr.split(/\s+/).includes(name);
    case MatcherType.Attribute:
      return value == null
        ? element.hasAttribute(name)
        : element.getAttribute(name) === value;
    case MatcherType.Pseudo:
      switch (name) {
        default:
          throw Error(`Pseudo :${name} not implemented`);
      }
    case MatcherType.Function:
      switch (name) {
        case 'has':
          return matchesSelector(element, value || '');
        case 'not':
          return !matchesSelector(element, value || '');
        default:
          throw Error(`Function :${name}(${value}) not implemented`);
      }
  }
  return false;
}



================================================
FILE: packages/polyfill/source/serialization.ts
================================================
import {
  ATTRIBUTES,
  CHILD,
  DATA,
  NAME,
  NEXT,
  VALUE,
  NodeType,
} from './constants.ts';
import type {Node} from './Node.ts';
import type {Text} from './Text.ts';
import type {Comment} from './Comment.ts';
import type {ParentNode} from './ParentNode.ts';
import type {Element} from './Element.ts';

// const voidElements = {
//   img: true,
//   image: true,
// };
// const elementTokenizer =
//   /(?:<([a-z][a-z0-9-:]*)( [^<>'"\n=\s]+=(['"])[^>'"\n]*\3)*\s*(\/?)\s*>|<\/([a-z][a-z0-9-:]*)>|([^&<>]+))/gi;
// const attributeTokenizer = / ([^<>'"\n=\s]+)=(['"])([^>'"\n]*)\2/g;

const elementTokenizer =
  /(?:<([a-z][a-z0-9-:]*)((?:[\s]+[^<>'"=\s]+(?:=(['"])[^]*?\3|=[^>'"\s]*|))*)[\s]*(\/?)\s*>|<\/([a-z][a-z0-9-:]*)>|<!--(.*?)-->|([^&<>]+))/gi;

const attributeTokenizer =
  /\s([^<>'"=\n\s]+)(?:=(["'])([\s\S]*?)\2|=([^>'"\n\s]*)|)/g;

export function parseHtml(html: string, contextNode: Node) {
  const document = contextNode.ownerDocument;
  const root = document.createDocumentFragment();
  const stack: Node[] = [root];
  let parent: ParentNode = root;
  let token: RegExpExecArray | null;
  elementTokenizer.lastIndex = 0;
  while ((token = elementTokenizer.exec(html))) {
    const tag = token[1];
    if (tag) {
      const node = document.createElement(tag);
      const attrs = token[2]!;
      attributeTokenizer.lastIndex = 0;
      let t: RegExpExecArray | null;
      while ((t = attributeTokenizer.exec(attrs))) {
        node.setAttribute(t[1]!, t[3] || t[4] || '');
      }
      parent.append(node);
      // if (voidElements[tag] === true) continue;
      stack.push(parent);
      parent = node;
    } else if (token[5]) {
      parent = (stack.pop() as ParentNode) || root;
    } else if (token[6]) {
      parent.append(document.createComment(token[6]!));
    } else {
      parent.append(token[7]!);
    }
  }
  return root;
}

export function serializeChildren(parentNode: ParentNode) {
  let out = '';
  let child = parentNode[CHILD];
  while (child) {
    out += serializeNode(child);
    child = child[NEXT];
  }
  return out;
}

export function serializeNode(node: Node) {
  switch (node.nodeType) {
    case NodeType.ELEMENT_NODE: {
      const el = node as Element;
      let out = `<${el[NAME]}`;
      let attr = el[ATTRIBUTES]?.[CHILD];
      while (attr) {
        out += ` ${attr[NAME]}`;
        let value = attr[VALUE];
        if (value !== '') {
          value = String(value).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
          out += `="${value}"`;
        }
        attr = attr[NEXT];
      }
      out += '>';
      out += serializeChildren(el);
      // let child = el[CHILD];
      // while (child) {
      //   out += serialize(child);
      //   child = child[NEXT];
      // }
      out += `</${el[NAME]}>`;
      return out;
    }
    case NodeType.TEXT_NODE: {
      const text = node as Text;
      return text[DATA].replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }
    case NodeType.COMMENT_NODE: {
      const text = node as Comment;
      return `<!--${text[DATA]}-->`;
    }
  }
  return '';
}



================================================
FILE: packages/polyfill/source/shared.ts
================================================
import {
  DATA,
  OWNER_DOCUMENT,
  ATTRIBUTES,
  NodeType,
  CHILD,
  NEXT,
} from './constants.ts';
import type {Document} from './Document.ts';
import type {DocumentFragment} from './DocumentFragment.ts';
import type {Node} from './Node.ts';
import type {Comment} from './Comment.ts';
import type {ParentNode} from './ParentNode.ts';
import type {Element} from './Element.ts';
import type {CharacterData} from './CharacterData.ts';
import type {Text} from './Text.ts';

export function isCharacterData(node: Node): node is CharacterData {
  return DATA in node;
}

export function isTextNode(node: Node): node is Text {
  return node.nodeType === NodeType.TEXT_NODE;
}

export function isCommentNode(node: Node): node is Comment {
  return node.nodeType === NodeType.COMMENT_NODE;
}

export function isElementNode(node: Node): node is Element {
  return node.nodeType === NodeType.ELEMENT_NODE;
}

export function isDocumentFragmentNode(node: Node): node is DocumentFragment {
  return node.nodeType === NodeType.DOCUMENT_FRAGMENT_NODE;
}

export function isParentNode(node: Node): node is ParentNode {
  return 'appendChild' in node;
}

export function cloneNode(
  node: Node,
  deep?: boolean,
  document: Document = node.ownerDocument,
): Node {
  if (isTextNode(node)) {
    return document.createTextNode(node.data);
  } else if (isCommentNode(node)) {
    return document.createComment(node.data);
  } else if (isElementNode(node)) {
    const cloned = document.createElement(node.localName);

    if (node[ATTRIBUTES]) {
      for (let i = 0; i < node[ATTRIBUTES].length; i++) {
        const attribute = node[ATTRIBUTES].item(i)!;
        cloned.setAttributeNS(
          attribute.namespaceURI,
          attribute.name,
          attribute.value,
        );
      }
    }

    if (deep) {
      for (const child of node.childNodes) {
        cloned.appendChild(cloneNode(child, true, document));
      }
    }

    return cloned;
  } else if (isDocumentFragmentNode(node)) {
    const fragment = document.createDocumentFragment();

    if (deep) {
      for (const child of (node as DocumentFragment).childNodes) {
        fragment.appendChild(cloneNode(child, true, document));
      }
    }

    return fragment;
  } else {
    const cloned = new (node.constructor as any)();
    cloned[OWNER_DOCUMENT] = document;
    return cloned;
  }
}

export function descendants(node: Node) {
  const nodes: Node[] = [];
  const walk = (node: Node) => {
    nodes.push(node);
    const child = node[CHILD];
    if (child) walk(child);
    const sibling = node[NEXT];
    if (sibling) walk(sibling);
  };
  const child = node[CHILD];
  if (child) walk(child);
  return nodes;
}

export function selfAndDescendants(node: Node) {
  const nodes = descendants(node);
  nodes.unshift(node);
  return nodes;
}



================================================
FILE: packages/polyfill/source/SVGElement.ts
================================================
import {NS, NamespaceURI} from './constants.ts';
import {Element} from './Element.ts';

export class SVGElement extends Element {
  [NS] = NamespaceURI.SVG;

  get ownerSVGElement() {
    let root: SVGElement | null = null;
    let parent = this.parentNode;
    while (parent instanceof SVGElement) {
      root = parent;
      parent = parent.parentNode;
    }
    return root;
  }
}



================================================
FILE: packages/polyfill/source/Text.ts
================================================
import {NAME, NodeType} from './constants.ts';
import {CharacterData} from './CharacterData.ts';

export class Text extends CharacterData {
  nodeType = NodeType.TEXT_NODE;
  [NAME] = '#text';
}



================================================
FILE: packages/polyfill/source/ToggleEvent.ts
================================================
import {Event} from './Event.ts';

// https://html.spec.whatwg.org/multipage/popover.html#toggleevent
export class ToggleEvent extends Event {
  readonly oldState: ToggleEventInit['oldState'];
  readonly newState: ToggleEventInit['newState'];

  constructor(type: string, eventInitDict: ToggleEventInit) {
    super(type, eventInitDict);

    this.oldState = eventInitDict.oldState;
    this.newState = eventInitDict.newState;
  }
}



================================================
FILE: packages/polyfill/source/Window.ts
================================================
import {Document} from './Document.ts';
import {Event} from './Event.ts';
import {EventTarget} from './EventTarget.ts';
import {CustomEvent} from './CustomEvent.ts';
import {ErrorEvent} from './ErrorEvent.ts';
import {PromiseRejectionEvent} from './PromiseRejectionEvent.ts';
import {ToggleEvent} from './ToggleEvent.ts';
import {FocusEvent} from './FocusEvent.ts';
import {ClipboardEvent} from './ClipboardEvent.ts';
import {Node} from './Node.ts';
import {ParentNode} from './ParentNode.ts';
import {ChildNode} from './ChildNode.ts';
import {Element} from './Element.ts';
import {HTMLElement} from './HTMLElement.ts';
import {SVGElement} from './SVGElement.ts';
import {CharacterData} from './CharacterData.ts';
import {Text} from './Text.ts';
import {Comment} from './Comment.ts';
import {DocumentFragment} from './DocumentFragment.ts';
import {HTMLTemplateElement} from './HTMLTemplateElement.ts';
import {CustomElementRegistryImplementation} from './CustomElementRegistry.ts';
import {MutationObserver} from './MutationObserver.ts';
import {HOOKS} from './constants.ts';
import type {Hooks} from './hooks.ts';

type OnErrorHandler =
  | ((
      message: string,
      filename?: string,
      lineno?: number,
      colno?: number,
      error?: any,
    ) => void)
  | null;

export class Window extends EventTarget {
  [HOOKS]: Partial<Hooks> = {};
  name = '';
  window = this;
  parent = this;
  self = this;
  top = this;
  document = new Document(this);
  customElements = new CustomElementRegistryImplementation();
  location = globalThis.location;
  navigator = globalThis.navigator;
  Event = Event;
  ErrorEvent = ErrorEvent;
  PromiseRejectionEvent = PromiseRejectionEvent;
  ToggleEvent = ToggleEvent;
  FocusEvent = FocusEvent;
  ClipboardEvent = ClipboardEvent;
  EventTarget = EventTarget;
  CustomEvent = CustomEvent;
  Node = Node;
  ParentNode = ParentNode;
  ChildNode = ChildNode;
  DocumentFragment = DocumentFragment;
  Document = Document;
  CharacterData = CharacterData;
  Comment = Comment;
  Text = Text;
  Element = Element;
  HTMLElement = HTMLElement;
  SVGElement = SVGElement;
  HTMLTemplateElement = HTMLTemplateElement;
  MutationObserver = MutationObserver;

  #currentOnErrorHandler: ((event: any) => void) | null = null;
  #currentOriginalOnErrorHandler: OnErrorHandler = null;
  #currentOnUnhandledRejectionHandler: WindowEventHandlers['onunhandledrejection'] =
    null;

  get onerror() {
    return this.#currentOriginalOnErrorHandler;
  }
  set onerror(handler: OnErrorHandler) {
    if (this.#currentOnErrorHandler) {
      this.removeEventListener('error', this.#currentOnErrorHandler);
    }
    if (handler && typeof handler === 'function') {
      // the event listener version receives an event object
      // whereas winwow.onerror receives 5 arguments instead
      // we need to wrap the handler to convert the event object to the 5 arguments
      // and also make sure that when window.onerror is read to return the original handler
      // https://developer.mozilla.org/en-US/docs/Web/API/Window/error_event#syntax
      this.#currentOriginalOnErrorHandler = handler;
      this.#currentOnErrorHandler = (event: ErrorEvent) => {
        handler(
          event.message ?? 'Error',
          event.filename,
          event.lineno,
          event.colno,
          event.error,
        );
      };
      this.addEventListener('error', this.#currentOnErrorHandler);
    } else {
      this.#currentOnErrorHandler = null;
      this.#currentOriginalOnErrorHandler = null;
    }
  }

  get onunhandledrejection() {
    return this.#currentOnUnhandledRejectionHandler;
  }
  set onunhandledrejection(
    handler: WindowEventHandlers['onunhandledrejection'],
  ) {
    if (this.#currentOnUnhandledRejectionHandler) {
      this.removeEventListener(
        'unhandledrejection',
        this.#currentOnUnhandledRejectionHandler as any,
      );
    }
    if (handler && typeof handler === 'function') {
      this.#currentOnUnhandledRejectionHandler = handler;
      this.addEventListener(
        'unhandledrejection',
        this.#currentOnUnhandledRejectionHandler as any,
      );
    } else {
      this.#currentOnUnhandledRejectionHandler = null;
    }
  }

  static setGlobal(window: Window) {
    const properties = Object.getOwnPropertyDescriptors(window);

    delete (properties as any).self;

    Object.defineProperties(globalThis, properties);

    if (typeof globalThis.self === 'undefined') {
      Object.defineProperty(globalThis, 'self', {
        value: window,
        configurable: true,
        writable: true,
        enumerable: true,
      });
    } else {
      // There can already be a `self`, like when polyfilling the DOM
      // in a Web Worker. In those cases, just mirror all the `Window`
      // properties onto `self`, rather than wholly redefining it.
      Object.defineProperties(self, properties);
    }
  }

  static setGlobalThis(window: Window) {
    for (const property in window) {
      if ((window as any)[property] === window) {
        (window as any)[property] = globalThis;
      }
    }

    const properties = Object.getOwnPropertyDescriptors(window);
    const eventTargetPrototypeProperties = Object.getOwnPropertyDescriptors(
      EventTarget.prototype,
    );

    for (const descriptor of Object.values(eventTargetPrototypeProperties)) {
      if (typeof descriptor.value === 'function') {
        descriptor.value = descriptor.value.bind(window);
      }
    }

    Object.defineProperties(globalThis, properties);
    Object.defineProperties(globalThis, eventTargetPrototypeProperties);
  }
}



================================================
FILE: packages/polyfill/source/tests/global-errors.test.ts
================================================
import {ErrorEvent} from '../ErrorEvent.ts';
import {PromiseRejectionEvent} from '../PromiseRejectionEvent.ts';
import {Window} from '../Window.ts';
import {describe, it, expect, beforeEach, afterEach, vi} from 'vitest';

describe('global errors', () => {
  describe('onerror', () => {
    let originalOnerror: any;

    beforeEach(() => {
      originalOnerror = globalThis.onerror;
    });

    afterEach(() => {
      globalThis.onerror = originalOnerror;
    });

    it('sets onerror handler on window instance', () => {
      const handler = vi.fn();
      const window = new Window();

      window.onerror = handler;
      expect(window.onerror).toBe(handler);
    });

    it('overrides onerror handler on window instance', () => {
      const handler = vi.fn();
      const handler2 = vi.fn();

      const window = new Window();
      window.onerror = handler;
      window.onerror = handler2;

      expect(window.onerror).toBe(handler2);
    });

    it('calls handler when error occurs', () => {
      const handler = vi.fn();
      const window = new Window();

      const error = new Error('test');

      window.onerror = handler;
      window.dispatchEvent(
        new ErrorEvent('error', {
          error,
          filename: 'test.ts',
          lineno: 1,
          colno: 1,
        }),
      );

      expect(handler).toHaveBeenCalledWith('Error', 'test.ts', 1, 1, error);
    });

    it('allows null assignment', () => {
      const handler = vi.fn();
      const window = new Window();
      window.onerror = handler;
      expect(window.onerror).toBe(handler);

      window.onerror = null;
      expect(window.onerror).toBe(null);
    });

    it('works when window is set as global', () => {
      const window = new Window();
      Window.setGlobalThis(window);
      const handler = vi.fn();
      window.onerror = handler;

      expect(window.onerror).toBe(handler);
    });
  });

  describe('onunhandledrejection', () => {
    let originalOnunhandledrejection: any;

    beforeEach(() => {
      originalOnunhandledrejection = globalThis.onunhandledrejection;
    });

    afterEach(() => {
      globalThis.onunhandledrejection = originalOnunhandledrejection;
    });

    it('sets onunhandledrejection handler on window instance', () => {
      const handler = vi.fn();
      const window = new Window();

      window.onunhandledrejection = handler;
      expect(window.onunhandledrejection).toBe(handler);
    });

    it('overrides onunhandledrejection handler on window instance', () => {
      const handler = vi.fn();
      const handler2 = vi.fn();
      const window = new Window();

      window.onunhandledrejection = handler;
      window.onunhandledrejection = handler2;
      expect(window.onunhandledrejection).toBe(handler2);
    });

    it('calls handler when unhandled rejection occurs', () => {
      const handler = vi.fn();
      const window = new Window();
      window.onunhandledrejection = handler;

      const error = new Error('test');
      const promise = Promise.resolve();

      window.dispatchEvent(
        new PromiseRejectionEvent('unhandledrejection', {
          promise: promise,
          reason: error,
        }),
      );

      expect(handler).toHaveBeenCalledWith(
        expect.objectContaining({
          promise,
          reason: error,
        }),
      );

      expect(handler).toHaveBeenCalledWith(expect.any(PromiseRejectionEvent));
    });

    it('allows null assignment', () => {
      const handler = vi.fn();
      const window = new Window();
      window.onunhandledrejection = handler;
      expect(window.onunhandledrejection).toBe(handler);

      window.onunhandledrejection = null;
      expect(window.onunhandledrejection).toBe(null);
    });

    it('works when window is set as global', () => {
      const window = new Window();
      Window.setGlobalThis(window);
      const handler = vi.fn();
      window.onunhandledrejection = handler;

      expect(window.onunhandledrejection).toBe(handler);
    });
  });
});



================================================
FILE: packages/polyfill/source/tests/selectors.test.ts
================================================
import {Window} from '../index.ts';
import {parseSelector} from '../selectors.ts';

import {describe, it, expect, beforeEach} from 'vitest';

describe('selector parsing and matching', () => {
  beforeEach(() => {
    const window = new Window();
    Window.setGlobalThis(window);
  });

  describe('parseSelector', () => {
    it('parses element selectors', () => {
      const parts = parseSelector('div');
      expect(parts).toHaveLength(1);
      expect(parts[0]!.matchers).toHaveLength(1);
      expect(parts[0]!.matchers[0]!).toMatchObject({
        type: 1, // MatcherType.Element
        name: 'div',
        value: 'div',
      });
    });

    it('parses ID selectors', () => {
      const parts = parseSelector('#myid');
      expect(parts).toHaveLength(1);
      expect(parts[0]!.matchers[0]!).toMatchObject({
        type: 2, // MatcherType.Id
        name: 'myid',
        value: 'myid',
      });
    });

    it('parses class selectors', () => {
      const parts = parseSelector('.myclass');
      expect(parts).toHaveLength(1);
      expect(parts[0]!.matchers[0]!).toMatchObject({
        type: 3, // MatcherType.Class
        name: 'myclass',
        value: 'myclass',
      });
    });

    it('parses attribute selectors without values', () => {
      const parts = parseSelector('[disabled]');
      expect(parts).toHaveLength(1);
      expect(parts[0]!.matchers[0]!).toMatchObject({
        type: 4, // MatcherType.Attribute
        name: 'disabled',
        value: undefined,
      });
    });

    it('parses attribute selectors with values', () => {
      const parts = parseSelector('[type="button"]');
      expect(parts).toHaveLength(1);
      expect(parts[0]!.matchers[0]!).toMatchObject({
        type: 4, // MatcherType.Attribute
        name: 'type',
        value: 'button',
      });
    });

    it('parses pseudo-class selectors', () => {
      const parts = parseSelector(':hover');
      expect(parts).toHaveLength(1);
      expect(parts[0]!.matchers[0]!).toMatchObject({
        type: 5, // MatcherType.Pseudo
        name: 'hover',
        value: undefined,
      });
    });

    it('parses function selectors', () => {
      const parts = parseSelector(':has(div)');
      expect(parts).toHaveLength(1);
      expect(parts[0]!.matchers[0]!).toMatchObject({
        type: 6, // MatcherType.Function
        name: 'has',
        value: 'div',
      });
    });

    it('parses :not() function selectors', () => {
      const parts = parseSelector(':not(.hidden)');
      expect(parts).toHaveLength(1);
      expect(parts[0]!.matchers[0]!).toMatchObject({
        type: 6, // MatcherType.Function
        name: 'not',
        value: '.hidden',
      });
    });

    it('parses compound selectors', () => {
      const parts = parseSelector('div.myclass#myid[type="button"]');
      expect(parts).toHaveLength(1);
      expect(parts[0]!.matchers).toHaveLength(4);
      expect(parts[0]!.matchers[0]!.name).toBe('div');
      expect(parts[0]!.matchers[1]!.name).toBe('myclass');
      expect(parts[0]!.matchers[2]!.name).toBe('myid');
      expect(parts[0]!.matchers[3]!.name).toBe('type');
    });

    it('parses child combinator', () => {
      const parts = parseSelector('div > span');
      expect(parts).toHaveLength(2);
      expect(parts[0]!.combinator).toBe(1); // Combinator.Child
      expect(parts[0]!.matchers[0]!.name).toBe('div');
      expect(parts[1]!.matchers[0]!.name).toBe('span');
    });

    it('parses descendant combinator', () => {
      const parts = parseSelector('div span');
      expect(parts).toHaveLength(2);
      expect(parts[0]!.combinator).toBe(0); // Combinator.Descendant
      expect(parts[0]!.matchers[0]!.name).toBe('div');
      expect(parts[1]!.matchers[0]!.name).toBe('span');
    });

    it('parses adjacent sibling combinator', () => {
      const parts = parseSelector('h1 + p');
      expect(parts).toHaveLength(2);
      expect(parts[0]!.combinator).toBe(3); // Combinator.Adjacent
      expect(parts[0]!.matchers[0]!.name).toBe('h1');
      expect(parts[1]!.combinator).toBe(4); // Combinator.Inner
      expect(parts[1]!.matchers[0]!.name).toBe('p');
    });

    it('parses general sibling combinator', () => {
      const parts = parseSelector('h1 ~ p');
      expect(parts).toHaveLength(2);
      expect(parts[0]!.combinator).toBe(2); // Combinator.Sibling
      expect(parts[0]!.matchers[0]!.name).toBe('h1');
      expect(parts[1]!.combinator).toBe(4); // Combinator.Inner
      expect(parts[1]!.matchers[0]!.name).toBe('p');
    });

    it('parses complex selectors', () => {
      const parts = parseSelector('article > .header + .content:not(.hidden)');
      expect(parts).toHaveLength(3);
      expect(parts[0]!.combinator).toBe(1); // Child
      expect(parts[1]!.combinator).toBe(3); // Adjacent
      expect(parts[2]!.combinator).toBe(4); // Inner
      expect(parts[0]!.matchers[0]!.name).toBe('article');
      expect(parts[1]!.matchers[0]!.name).toBe('header');
      expect(parts[2]!.matchers).toHaveLength(2);
      expect(parts[2]!.matchers[0]!.name).toBe('content');
      expect(parts[2]!.matchers[1]!.name).toBe('not');
    });
  });

  describe('querySelector and querySelectorAll', () => {
    let container: Element;

    beforeEach(() => {
      container = document.createElement('div');
      container.innerHTML = `
        <article class="post" id="main-post">
          <h1 class="title">Main Title</h1>
          <div class="content">
            <p class="text">First paragraph</p>
            <p class="text hidden">Hidden paragraph</p>
            <span class="highlight">Highlighted text</span>
          </div>
          <aside class="sidebar">
            <ul class="nav">
              <li><a href="#" class="link active">Active Link</a></li>
              <li><a href="#" class="link">Regular Link</a></li>
            </ul>
          </aside>
        </article>
        <footer class="footer">
          <div class="content">
            <p class="text">Footer text</p>
          </div>
        </footer>
      `;
    });

    it('selects by element name', () => {
      const articles = container.querySelectorAll('article');
      expect(articles).toHaveLength(1);
      expect(articles[0]!.getAttribute('class')).toBe('post');

      const paragraphs = container.querySelectorAll('p');
      expect(paragraphs).toHaveLength(3);
    });

    it('selects by ID', () => {
      const main = container.querySelector('#main-post');
      expect(main?.tagName.toLowerCase()).toBe('article');
    });

    it('selects by class', () => {
      const texts = container.querySelectorAll('.text');
      expect(texts).toHaveLength(3);

      const hidden = container.querySelector('.hidden');
      expect(hidden?.textContent?.trim()).toBe('Hidden paragraph');
    });

    it('selects by attribute', () => {
      const links = container.querySelectorAll('[href]');
      expect(links).toHaveLength(2);

      const activeLinks = container.querySelectorAll('[href="#"]');
      expect(activeLinks).toHaveLength(2);
    });

    it('selects by compound selectors', () => {
      const activeLink = container.querySelector('a.link.active');
      expect(activeLink?.textContent?.trim()).toBe('Active Link');

      const hiddenText = container.querySelector('p.text.hidden');
      expect(hiddenText?.textContent?.trim()).toBe('Hidden paragraph');
    });

    it('selects with descendant combinator', () => {
      const contentTexts = container.querySelectorAll('.content p');
      expect(contentTexts).toHaveLength(3);

      const sidebarLinks = container.querySelectorAll('.sidebar a');
      expect(sidebarLinks).toHaveLength(2);
    });

    it('selects with child combinator', () => {
      const directContentChildren = container.querySelectorAll('.content > p');
      expect(directContentChildren).toHaveLength(3);

      const directArticleChildren = container.querySelectorAll('article > h1');
      expect(directArticleChildren).toHaveLength(1);
    });

    it('selects with adjacent sibling combinator', () => {
      const titleSibling = container.querySelector('h1 + div');
      expect(titleSibling?.getAttribute('class')).toBe('content');
    });

    it('selects with general sibling combinator', () => {
      const titleSiblings = container.querySelectorAll('h1 ~ div');
      expect(titleSiblings).toHaveLength(1);

      const contentSiblings = container.querySelectorAll('.content ~ aside');
      expect(contentSiblings).toHaveLength(1);
    });

    it('selects with :has() pseudo-class', () => {
      const hasLinks = container.querySelectorAll(':has(a)');
      expect(hasLinks.length).toBeGreaterThan(0);

      const hasActiveLink = container.querySelector(':has(.active)');
      expect(hasActiveLink).toBeTruthy();
    });

    it('handles complex selectors', () => {
      const complexSelector = container.querySelectorAll(
        'article .content > p.text',
      );
      expect(complexSelector).toHaveLength(2);

      const deepSelector = container.querySelector('.sidebar ul li a.active');
      expect(deepSelector?.textContent?.trim()).toBe('Active Link');
    });

    it('returns null/empty for non-matching selectors', () => {
      expect(container.querySelector('.nonexistent')).toBeNull();
      expect(container.querySelectorAll('.nonexistent')).toHaveLength(0);

      expect(container.querySelector('table')).toBeNull();
      expect(container.querySelector('#nonexistent-id')).toBeNull();
    });

    it('handles edge cases', () => {
      expect(container.querySelectorAll('')).toHaveLength(0);

      const allElements = container.querySelectorAll('*');
      expect(allElements.length).toBeGreaterThan(0);
    });
  });
});



================================================
FILE: packages/polyfill/source/tests/serialization.test.ts
================================================
import {Window} from '../index.ts';

import {describe, it, expect, beforeEach} from 'vitest';

describe('innerHtml', () => {
  beforeEach(() => {
    const window = new Window();
    Window.setGlobalThis(window);
  });

  it('parses a simple element', () => {
    const element = document.createElement('div');
    element.innerHTML = '<ui-button>Press me!</ui-button>';

    const button = element.querySelector('ui-button');
    expect(button?.textContent).toBe('Press me!');
  });

  it('parses an element with attributes', () => {
    const element = document.createElement('div');
    element.innerHTML = '<ui-button data-id="123">Press me!</ui-button>';

    const button = element.querySelector('ui-button');
    expect(button?.textContent).toBe('Press me!');
    expect(button?.getAttribute('data-id')).toBe('123');
  });

  it('parses an element with attributes on newlines', () => {
    const element = document.createElement('div');
    element.innerHTML = `<ui-button 
      data-id="123"
      data-id2="456"
      data-id3="789"
      data-id4="multiline
content
works too"
variant="primary" tone="neutral"
    >Press me!</ui-button>`;

    const button = element.querySelector('ui-button');

    expect(button?.getAttribute('data-id')).toBe('123');
    expect(button?.getAttribute('data-id2')).toBe('456');
    expect(button?.getAttribute('data-id3')).toBe('789');
    expect(button?.getAttribute('data-id4')).toBe(
      'multiline\ncontent\nworks too',
    );
    expect(button?.getAttribute('variant')).toBe('primary');
    expect(button?.getAttribute('tone')).toBe('neutral');
  });
});



================================================
FILE: packages/preact/README.md
================================================
# `@remote-dom/preact`

Utilities for rendering Remote DOM elements using [Preact](https://preactjs.com/).

## Installation

```sh
npm install @remote-dom/core @remote-dom/preact --save # npm
pnpm install @remote-dom/core @remote-dom/preact --save # pnpm
yarn add @remote-dom/core @remote-dom/preact # yarn
```

## Usage

This library provides helpers for both the “host” and “remote” environments. The `@remote-dom/preact` entry provides wrappers for [`RemoteElement` subclasses](../core/README.md#remoteelement) that add some nice Preact-specific features on top of core Remote DOM library. The `@remote-dom/preact/host` provides the [`SignalRemoteReceiver` class](../signals/README.md#signalremotereceiver) and [`RemoteRootRenderer` component](#remoterootreceiver), which are used to render a tree of remote elements to the host environment using Preact.

### Remote

#### `createRemoteComponent()`

Preact has built-in support for web components, so you can use `@remote-dom/core` with Preact without any additional setup:

```ts
import {h, render} from 'preact';
import {RemoteElement} from '@remote-dom/core/elements';

// Define your remote element...
// @see https://github.com/Shopify/remote-dom/tree/main/packages/core/README.md#remoteelement
class MyElement extends RemoteElement {
  static get remoteAttributes() {
    return ['label'];
  }
}

customElements.define('my-element', MyElement);

// ...and render it using Preact components

render(
  h('my-element', {label: 'Hello, world!'}),
  document.querySelector('#root'),
);
```

However, we can make the Preact integration a bit more seamless by using the `createRemoteComponent()` function to create a wrapper Preact component. This wrapper component will automatically have the TypeScript prop types it should, given the custom element definition you pass in, and will correctly assign the props on the component to either attributes, properties, or event listeners.

```tsx
import {render} from 'preact';

const MyElementComponent = createRemoteComponent('my-element', MyElement);

render(
  <MyElementComponent label="Hello, world!" />,
  document.querySelector('#root'),
);
```

More importantly, though, this wrapper will also take care of adapting some parts of the custom element API to be feel more natural in a Preact application.

##### Event listener props

Custom Preact components generally expose events as callback props on the component. To support this pattern, the `createRemoteComponent()` wrapper can map specific props on the resulting Preact component to event listeners on underlying custom element.

Imagine a `ui-card` element with a clickable header. When clicked, the card will emit an `expand` event to the remote environment, and reveal the children of the `ui-card` element to the user. First, we define our custom element:

```ts
import {RemoteElement} from '@remote-dom/core/elements';

class Card extends RemoteElement {
  static get remoteEvents() {
    return ['expand'];
  }
}

customElements.define('ui-card', Card);
```

Then, we use the `createRemoteComponent()` helper function to create a wrapper Preact component with an `onExpand` prop, mapped to the `expand` event:

```tsx
import {createRemoteComponent} from '@remote-dom/preact';

const Card = createRemoteComponent('ui-card', CardElement, {
  eventProps: {
    onExpand: {event: 'expand'},
  },
});

render(
  <Card
    onExpand={() => {
      console.log('Card expanded!');
    }}
  >
    This is the body of the card.
  </Card>,
  document.querySelector('#root'),
);
```

##### Slotted children to Preact elements

The `createRemoteComponent` helper also supports mapping slotted children to Preact elements. Each top-level slot of the element’s children will be mapped to a prop with the same name on the Preact component.

For example, our `ui-card` custom element could take a `header` slot for customizing the title of the card:

```ts
import {RemoteElement} from '@remote-dom/core/elements';

class Card extends RemoteElement {
  static get remoteSlots() {
    return ['header'];
  }
}

class Text extends RemoteElement {}

customElements.define('ui-card', Card);
customElements.define('ui-text', Text);
```

The `createRemoteComponent()` wrapper will allow you to pass a `header` prop to the resulting Preact component, which can be any other Preact element:

```tsx
import {render} from 'preact';
import {createRemoteComponent} from '@remote-dom/preact';

const Card = createRemoteComponent('ui-card', CardElement);
const Text = createRemoteComponent('ui-text', TextElement);

render(
  <Card header={<Text>Hello, world!</Text>}>
    This is the body of the card.
  </Card>,
  document.querySelector('#root'),
);
```

To make this work, the wrapper component will wrap the Preact element prop in a `<remote-fragment>` element, and place it as a child of the parent element. So, the above example could have been written manually like this:

```tsx
import {render} from 'preact';

render(
  <ui-card>
    This is the body of the card.
    <remote-fragment slot="header">
      <ui-text>Hello, world!</ui-text>
    </remote-fragment>
  </ui-card>,
  document.querySelector('#root'),
);
```

To disable this behavior, you can pass `{slotProps: {wrapper: false}}` option to `createRemoteComponent()`. This will cause any element props to be cloned with a `slot` prop, instead of wrapping them in a `<remote-fragment>` element.

```tsx
import {render} from 'preact';
import {createRemoteComponent} from '@remote-dom/preact';

const Card = createRemoteComponent('ui-card', CardElement, {
  slotProps: {
    wrapper: false,
  },
});

const Text = createRemoteComponent('ui-text', TextElement);

render(
  <Card header={<Text>Hello, world!</Text>}>
    This is the body of the card.
  </Card>,
  document.querySelector('#root'),
);

// Now, renders this tree of HTML elements:
// <ui-card>
//   This is the body of the card.
//   <ui-text slot="header">Hello, world!</ui-text>
// </ui-card>
```

### Host

#### `SignalRemoteReceiver`

The `@remote-dom/preact/host` package re-exports the [`SignalRemoteReceiver` class from `@remote-dom/signals`](../signals/). This object will store the state of the remote tree of elements, and the [`RemoteRootRenderer` component](#remoterootrenderer) expects to receive an instance of this class in order to map the remote tree to Preact components.

#### `createRemoteComponentRenderer()`

The [`RemoteRootRenderer` component](#remoterootrenderer) needs a map of which Preact components to render for each remote element. These components will receive a description of the remote element, but not much more. The `createRemoteComponentRenderer()` function can be used to create a wrapper Preact component that will automatically update whenever the properties or children of the associated remote element change. The props passed to your Preact component will be the combined result of:

- The `properties` of the remote element
- The `attributes` of the remote element
- The `eventListeners` of the remote element, with each event listener being mapped to a prop named in the format `onEventName`
- The `children` of the remote element, where any children with a `slot` attribute are mapped to a prop with the same name

```tsx
import {createRemoteComponentRenderer} from '@remote-dom/preact/host';

// Imagine we are implementing the host version of our `ui-card` custom element above,
// which allows a `header` slot and `expand` event. We’ll also have it accept a `subdued` property to
// customize its appearance.

const Card = createRemoteComponentRenderer(function Card({
  header,
  subdued,
  onExpand,
  children,
}) {
  const isExpanded = useIsExpanded();

  return (
    <div
      class={[
        'Card',
        isExpanded.value && 'Card--expanded',
        subdued && 'Card--subdued',
      ]
        .filter(Boolean)
        .join(' ')}
    >
      {header && (
        <button
          class="Card__Header"
          onClick={() => {
            isExpanded.value = !isExpanded.value;
            if (isExpanded.value && onExpand) onExpand();
          }}
        >
          {header}
        </button>
      )}
      {children}
    </div>
  );
});
```

##### Host event listener props

Like with creating a [Preact wrapper in the remote environment with `createRemoteComponent()`](#event-listener-props), a host using Preact likely wants to map event listeners to conventional Preact callback props. Like with creating a Preact wrapper for the remote environment, let’s return to our `ui-card` example. To refresh, we are imagining a collapsible card element that will emit an `expand` event to the remote environment when its contents are revealed. In the remote environment, our custom element would be defined like this:

```ts
import {RemoteElement} from '@remote-dom/core/elements';

class Card extends RemoteElement {
  static get remoteEvents() {
    return ['expand'];
  }
}

customElements.define('ui-card', Card);

const card = document.createElement('ui-card');
card.textContent = 'This is the body of the card.';

card.addEventListener('expand', (event) => {
  console.log('Card expanded!', event.detail);
});
```

By default, Remote DOM will map these an event listener to a conventionally-named Preact prop — that is, `on`, followed by the pascal-case name of the event, like `onExpand`. So, when using the `createRemoteComponentRenderer()` function, you can automatically invoke the event listeners by calling the conventional prop, with the first argument you pass being set as the `detail` of the resulting remote event:

```tsx
import {createRemoteComponentRenderer} from '@remote-dom/preact/host';

const Card = createRemoteComponentRenderer(function Card({children, onExpand}) {
  return (
    <div>
      {/* when clicked, will emit the `expand` remote event with this object as the `detail` field */}
      <button onClick={() => onExpand({timestamp: Date.now()})}>Expand</button>
      {children}
    </div>
  );
});
```

The default logic also allows you to pass an `Event` object to the Preact callback. When you do so, the `detail` field of the event will be passed to the remote environment directly. This can be useful when, for example, you have an existing web component being rendered by Preact that already emits a custom event with the necessary data.

```tsx
import {createRemoteComponentRenderer} from '@remote-dom/preact/host';

const Card = createRemoteComponentRenderer(function Card({children, onExpand}) {
  return (
    // Can pass the callback directly as an event listener to create a corresponding remote event automatically.
    <ui-card onexpand={onExpand}>{children}</ui-card>
  );
});
```

If this default behavior does not work for you, you can customize which events get mapped to properties, and what prop name that event maps to. This is done by passing a second argument to `createRemoteComponentRenderer()`, an object with an `eventProps` key. Each key in this `eventProps` option should be the name of a Preact property to create on the wrapper component, and the value is an object that describes which event listener to read for that property.

```tsx
import {createRemoteComponentRenderer} from '@remote-dom/preact/host';

const Card = createRemoteComponentRenderer(
  function Card({children, onexpand}) {
    return <ui-card onexpand={onexpand}>{children}</ui-card>;
  },
  {
    eventProps: {
      // Convert the `expand` event listener into an all-lowercase `onexpand` prop, which allows the prop to be passed
      // directly as a web component event listener.
      onexpand: {event: 'expand'},
    },
  },
);
```

If your event bubbles, be careful not to call the callback unless the matching remote element for this component is actually the target of the emitted event. For example, if you had two components that both support `click` events in the remote environment, implementing the event listener like this would cause a single click on the host version of the button to trigger two separate events:

```tsx
// Remote environment: two elements that can emit the same event, each with
// an event listener attached:

import {RemoteElement} from '@remote-dom/core/elements';

class Card extends RemoteElement {
  static get remoteEvents() {
    return {
      click: {
        bubbles: true,
      },
    };
  }
}

class Button extends RemoteElement {
  static get remoteEvents() {
    return {
      click: {
        bubbles: true,
      },
    };
  }
}

customElements.define('ui-card', Card);
customElements.define('ui-button', Button);

const card = document.createElement('ui-card');
card.addEventListener('click', (event) => {
  console.log('Click event in card', event.target);
});

const button = document.createElement('ui-button');
button.textContent = 'Click me!';
button.addEventListener('click', (event) => {
  console.log('Click event in button', event.target);
});

card.append(button);

// Host: both are implemented to call their respective event listener props when clicked,
// leads to `card.addEventListener()` callback being called twice (once from the bubbling
// click on `ui-button` in the remote, and once from the bubbling in the host).

import {createRemoteComponentRenderer} from '@remote-dom/preact/host';

const Card = createRemoteComponentRenderer(function Card({children, onClick}) {
  // This `onclick` will be called, even if the `Button` was the actual target
  return <ui-card onClick={() => onClick?.()}>{children}</ui-card>;
});

const Button = createRemoteComponentRenderer(function Button({
  children,
  onClick,
}) {
  return <ui-button onClick={() => onClick?.()}>{children}</ui-button>;
});
```

To avoid this issue, you should manually check that the target of the event is the current element before calling the callback, which will prevent the event from being dispatched on ancestor elements in the remote environment:

```tsx
import {createRemoteComponentRenderer} from '@remote-dom/preact/host';

const Card = createRemoteComponentRenderer(function Card({children, onClick}) {
  // This `onclick` will be called, even if the `Button` was the actual target
  return (
    <ui-card
      onClick={(event) => {
        if (event.target === event.currentTarget) {
          onClick?.();
        }
      }}
    >
      {children}
    </ui-card>
  );
});

const Button = createRemoteComponentRenderer(function Button({
  children,
  onClick,
}) {
  return (
    <ui-button
      onClick={(event) => {
        if (event.target === event.currentTarget) {
          onClick?.();
        }
      }}
    >
      {children}
    </ui-button>
  );
});
```

If you pass the event object directly to the callback, Remote DOM will automatically apply this protection for you, so you do not need to protect against this case manually:

```tsx
import {createRemoteComponentRenderer} from '@remote-dom/preact/host';

const Card = createRemoteComponentRenderer(function Card({children, onClick}) {
  // Pass the callback directly through as an event listener.
  return <ui-card onClick={onClick}>{children}</ui-card>;
});

const Button = createRemoteComponentRenderer(function Button({
  children,
  onClick,
}) {
  return <ui-button onClick={onClick}>{children}</ui-button>;
});
```

#### `RemoteRootRenderer`

The `RemoteRootRenderer` component is used to render a tree of remote elements to the host environment using Preact. It expects a `receiver` prop, a [`SignalRemoteReceiver` instance](../signals/README.md#signalremotereceiver) that will store the state of the remote tree of elements. It also accepts a `components` prop, which provides the mapping of which Preact component to render for each remote element.

The following component shows an example of how you could render a tree of remote elements using Preact. You’ll need to hand the `receiver` object’s `connection` property to the remote environment; some examples of how to do this are shown in the [runnable Remote DOM examples](/examples/).

```tsx
// If you don’t already have this import somewhere in your project, you need
// to add it — this import adds the Preact hooks that auto-subscribe components
// to signals.
import '@preact/signals';

import {render} from 'preact';
import {
  createRemoteComponentRenderer,
  RemoteRootRenderer,
  SignalRemoteReceiver,
} from '@remote-dom/preact/host';

// Create wrapper elements to render our actual UI components in response
// to remote elements. See the `createRemoteComponentRenderer()` section above.
const Card = createRemoteComponentRenderer(UICard);

const receiver = new SignalRemoteReceiver();
// TODO: send the `receiver.connection` object to the remote environment,
// so it can send us updates about the tree of remote elements.

render(
  <RemoteRootRenderer
    receiver={receiver}
    components={new Map([['ui-card', Card]])}
  />,
  document.querySelector('#root'),
);
```

#### `RemoteFragmentRenderer`

As noted above, Remote DOM may render a `<remote-fragment>` element to wrap a Preact element that is passed as a prop to a remote element. The `RemoteFragmentRenderer` component is used to render these fragments — it simply renders each child element inside of a Preact wrapper, which prevents any unnecessary wrapper elements from being introduced in the final DOM output.

```tsx
import {render} from 'preact';
import {
  createRemoteComponentRenderer,
  RemoteRootRenderer,
  RemoteFragmentRenderer,
  SignalRemoteReceiver,
} from '@remote-dom/preact/host';

// Same setup as above...

render(
  <RemoteRootRenderer
    receiver={receiver}
    components={
      new Map([
        ['ui-card', Card],
        // We allow `remote-fragment` elements to be rendered, which is the
        // name Remote DOM gives these wrapper elements by default. If you changed
        // the name using the `slotProps.wrapper` option, match that name here.
        ['remote-fragment', RemoteFragmentRenderer],
      ])
    }
  />,
  document.querySelector('#root'),
);
```



================================================
FILE: packages/preact/CHANGELOG.md
================================================
# @remote-dom/preact

## 1.3.0

### Minor Changes

- [#538](https://github.com/Shopify/remote-dom/pull/538) [`88d4956`](https://github.com/Shopify/remote-dom/commit/88d495608de6913a084b46384aaa19a6d9e599fb) Thanks [@igor10k](https://github.com/igor10k)! - Bump signals dependency

## 1.2.3

### Patch Changes

- [#536](https://github.com/Shopify/remote-dom/pull/536) [`9abf5be`](https://github.com/Shopify/remote-dom/commit/9abf5bee323dfa522f9061ba61ce2f433a36cb4e) Thanks [@igor10k](https://github.com/igor10k)! - Use the same core dependency version for all packages

## 1.2.2

### Patch Changes

- Updated dependencies [[`8cbf2c2`](https://github.com/Shopify/remote-dom/commit/8cbf2c2a6130dd0a19088a2adf18b506f468be8b)]:
  - @remote-dom/core@1.6.0
  - @remote-dom/signals@2.0.0

## 1.2.1

### Patch Changes

- [#465](https://github.com/Shopify/remote-dom/pull/465) [`017ca02`](https://github.com/Shopify/remote-dom/commit/017ca029fb148a51115edb12b7c8ccd49d2c52eb) Thanks [@lemonmade](https://github.com/lemonmade)! - Fix `slot` to be transmitted as an attribute, not a property

- Updated dependencies [[`994e2ea`](https://github.com/Shopify/remote-dom/commit/994e2ea2f7ab0e67a2c37e5295ce86618b004518), [`017ca02`](https://github.com/Shopify/remote-dom/commit/017ca029fb148a51115edb12b7c8ccd49d2c52eb)]:
  - @remote-dom/core@1.5.1
  - @remote-dom/signals@1.1.1

## 1.2.0

### Minor Changes

- [#389](https://github.com/Shopify/remote-dom/pull/389) [`2479b21`](https://github.com/Shopify/remote-dom/commit/2479b21406f6149063bfc095dbb6c3a019386403) Thanks [@lemonmade](https://github.com/lemonmade)! - Added native support for synchronizing attributes and event listeners

  Previously, Remote DOM only offered “remote properties” as a way to synchronize element state between the host and remote environments. These remote properties effectively synchronize a subset of a custom element’s instance properties. The `RemoteElement` class offers [a declarative way to define the properties that should be synchronized](/packages/core/README.md#remote-properties).

  ```ts
  import {RemoteElement} from '@remote-dom/core/elements';

  class MyElement extends RemoteElement {
    static get remoteProperties() {
      return ['label'];
    }
  }

  customElements.define('my-element', MyElement);

  const myElement = document.createElement('my-element');
  myElement.label = 'Hello, World!';
  ```

  The same `remoteProperties` configuration can create special handling for attributes and event listeners. By default, a remote property is automatically updated when setting an [attribute](https://developer.mozilla.org/en-US/docs/Glossary/Attribute) of the same name:

  ```ts
  const myElement = document.createElement('my-element');
  myElement.setAttribute('label', 'Hello, World!');

  // myElement.label === 'Hello, World!', and this value is synchronized
  // with the host environment as a “remote property”
  ```

  Similarly, a remote property can be automatically updated when adding an event listener based on a conventional `on` property naming prefix:

  ```ts
  import {RemoteElement} from '@remote-dom/core/elements';

  class MyElement extends RemoteElement {
    static get remoteProperties() {
      return {
        onChange: {
          event: true,
        },
      };
    }
  }

  customElements.define('my-element', MyElement);

  const myElement = document.createElement('my-element');

  // This adds a callback property that is synchronized with the host environment
  myElement.onChange = () => console.log('Changed!');

  // And so does this, but using the `addEventListener` method instead
  myElement.addEventListener('change', () => console.log('Changed!'));
  ```

  These utilities are handy, but they don’t align with patterns in native DOM elements, particularly when it comes to events. Now, both of these can be represented in a fashion that is more conventional in HTML. The `remoteAttributes` configuration allows you to define a set of element attributes that will be synchronized directly the host environment, instead of being treated as instance properties:

  ```ts
  import {RemoteElement} from '@remote-dom/core/elements';

  class MyElement extends RemoteElement {
    static get remoteAttributes() {
      return ['label'];
    }

    // If you want to add instance properties, you can do it with getters and
    // setters that manipulate the attribute value:
    //
    // get label() {
    //   return this.getAttribute('label');
    // }
    //
    // set label(value) {
    //   this.setAttribute('label', value);
    // }
  }

  customElements.define('my-element', MyElement);

  const myElement = document.createElement('my-element');
  myElement.setAttribute('label', 'Hello, World!');
  ```

  Similarly, the `remoteEvents` configuration allows you to define a set of event listeners that will be synchronized directly with the host environment:

  ```ts
  import {RemoteElement} from '@remote-dom/core/elements';

  class MyElement extends RemoteElement {
    static get remoteEvents() {
      return ['change'];
    }
  }

  customElements.define('my-element', MyElement);

  const myElement = document.createElement('my-element');

  // And so does this, but using the `addEventListener` method instead
  myElement.addEventListener('change', () => console.log('Changed!'));

  // No `myElement.onChange` property is created
  ```

  The `remoteProperties` configuration will continue to be supported for cases where you want to synchronize instance properties. Because instance properties can be any JavaScript type, properties are the highest-fidelity field that can be synchronized between the remote and host environments. However, adding event listeners using the `remoteProperties.event` configuration is **deprecated and will be removed in the next major version**. You should use the `remoteEvents` configuration instead. If you were previously defining remote properties which only accepted strings, consider using the `remoteAttributes` configuration, which stores the value entirely in an HTML attribute instead.

  This change is being released in a backwards-compatible way, so you can continue to use the existing `remoteProperties` configuration on host and/or remote environments without any code changes.

  All host utilities have been updated to support the new `attributes` and `eventListeners` property that are synchronized with the remote environment. This includes updates to the [React](/packages/react/README.md#event-listener-props) and [Preact hosts to map events to conventional callback props](/packages/preact/README.md#event-listener-props), and updates to the [`DOMRemoteReceiver` class](/packages/core/README.md#domremotereceiver), which now applies fields to the host element exactly as they were applied in the remote environment:

  ```ts
  // Remote environment:

  class MyElement extends RemoteElement {
    static get remoteEvents() {
      return ['change'];
    }
  }

  customElements.define('my-element', MyElement);

  const myElement = document.createElement('my-element');

  myElement.addEventListener('change', (event) => {
    console.log('Changed! New value: ', event.detail);
  });

  // Host environment:

  class MyElement extends HTMLElement {
    connectedCallback() {
      // Emit a change event on this element, with detail that will be passed
      // to the remote environment
      this.addEventListener('change', (event) => {
        event.stopImmediatePropagation();

        this.dispatchEvent(
          new CustomEvent('change', {
            detail: this.value,
          }),
        );
      });
    }

    // Additional implementation details of the host custom element...
  }

  customElements.define('my-element', MyElement);
  ```

### Patch Changes

- Updated dependencies [[`2479b21`](https://github.com/Shopify/remote-dom/commit/2479b21406f6149063bfc095dbb6c3a019386403)]:
  - @remote-dom/signals@2.0.0
  - @remote-dom/core@1.5.0

## 1.1.0

### Minor Changes

- [#411](https://github.com/Shopify/remote-dom/pull/411) [`3bec698`](https://github.com/Shopify/remote-dom/commit/3bec6983756c4b8a6834a037ac520438ef59d28f) Thanks [@lemonmade](https://github.com/lemonmade)! - Add CommonJS export conditions

### Patch Changes

- Updated dependencies [[`3bec698`](https://github.com/Shopify/remote-dom/commit/3bec6983756c4b8a6834a037ac520438ef59d28f)]:
  - @remote-dom/signals@1.1.0
  - @remote-dom/core@1.4.0

## 1.0.2

### Patch Changes

- Updated dependencies [[`218ba3b`](https://github.com/Shopify/remote-dom/commit/218ba3bf1ff2e7518a7dcec11ffd352de70b16f8)]:
  - @remote-dom/core@1.3.0
  - @remote-dom/signals@1.0.5

## 1.0.1

### Patch Changes

- Updated dependencies [[`22e6512`](https://github.com/Shopify/remote-dom/commit/22e6512f797d97d2106f181d730d995f37c6edaf)]:
  - @remote-dom/core@1.1.0
  - @remote-dom/signals@1.0.4

## 1.0.0

### Major Changes

- [`37be652`](https://github.com/Shopify/remote-dom/commit/37be652f288d1eec170c0be13b2da516f8db5dcf) Thanks [@lemonmade](https://github.com/lemonmade)! - First release of Remote DOM. Read more about this [refactor of remote-ui on native DOM APIs](https://github.com/Shopify/remote-dom/discussions/267), and take a look at the [updated documentation](/README.md).

### Patch Changes

- Updated dependencies [[`37be652`](https://github.com/Shopify/remote-dom/commit/37be652f288d1eec170c0be13b2da516f8db5dcf)]:
  - @remote-dom/core@1.0.0
  - @remote-dom/signals@2.0.0

## 0.1.1

### Patch Changes

- Updated dependencies [[`9576a72`](https://github.com/Shopify/remote-dom/commit/9576a72fa354481621c53efde4169829fe9bfabf)]:
  - @remote-dom/core@0.1.1
  - @remote-dom/signals@1.0.1

## 0.1.0

### Minor Changes

- [`7061ded`](https://github.com/Shopify/remote-dom/commit/7061ded1da4699c6dd6a820eeb940a8af7c66d82) Thanks [@lemonmade](https://github.com/lemonmade)! - Test minor bump

### Patch Changes

- Updated dependencies [[`7061ded`](https://github.com/Shopify/remote-dom/commit/7061ded1da4699c6dd6a820eeb940a8af7c66d82)]:
  - @remote-dom/core@0.1.0
  - @remote-dom/signals@1.0.0

## 0.0.2

### Patch Changes

- [#251](https://github.com/Shopify/remote-dom/pull/251) [`5939cca`](https://github.com/Shopify/remote-dom/commit/5939cca8112417124327bd26f9e2c21f4bf9b20a) Thanks [@lemonmade](https://github.com/lemonmade)! - Test version bump

- Updated dependencies [[`5939cca`](https://github.com/Shopify/remote-dom/commit/5939cca8112417124327bd26f9e2c21f4bf9b20a), [`8e1fad4`](https://github.com/Shopify/remote-dom/commit/8e1fad4a00cfe68ff1594fbabeec10c29958685f)]:
  - @remote-dom/signals@0.0.2
  - @remote-dom/core@0.0.2



================================================
FILE: packages/preact/package.json
================================================
{
  "name": "@remote-dom/preact",
  "type": "module",
  "license": "MIT",
  "description": "Utilities for rendering Remote DOM elements using Preact",
  "publishConfig": {
    "access": "public",
    "@remote-dom/registry": "https://registry.npmjs.org"
  },
  "version": "1.3.0",
  "engines": {
    "node": ">=14.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/Shopify/remote-dom",
    "directory": "packages/preact"
  },
  "exports": {
    ".": {
      "types": "./build/typescript/index.d.ts",
      "quilt:source": "./source/index.ts",
      "quilt:esnext": "./build/esnext/index.esnext",
      "import": "./build/esm/index.mjs",
      "require": "./build/cjs/index.cjs"
    },
    "./host": {
      "types": "./build/typescript/host.d.ts",
      "quilt:source": "./source/host.ts",
      "quilt:esnext": "./build/esnext/host.esnext",
      "import": "./build/esm/host.mjs",
      "require": "./build/cjs/host.cjs"
    },
    "./html": {
      "types": "./build/typescript/html.d.ts",
      "quilt:source": "./source/html.ts",
      "quilt:esnext": "./build/esnext/html.esnext",
      "import": "./build/esm/html.mjs",
      "require": "./build/cjs/html.cjs"
    }
  },
  "types": "./build/typescript/index.d.ts",
  "typesVersions": {
    "*": {
      "host": [
        "./build/typescript/host.d.ts"
      ],
      "html": [
        "./build/typescript/html.d.ts"
      ]
    }
  },
  "sideEffects": false,
  "scripts": {
    "build": "rollup --config rollup.config.js"
  },
  "dependencies": {
    "@remote-dom/core": "workspace:^1.7.0",
    "@remote-dom/signals": "workspace:^2.1.0",
    "htm": "^3.1.1"
  },
  "peerDependencies": {
    "@preact/signals": "^1.2.0",
    "@preact/signals-core": "^1.3.0",
    "preact": "^10.0.0"
  },
  "peerDependenciesMeta": {
    "@preact/signals-core": {
      "optional": true
    },
    "preact": {
      "optional": true
    }
  },
  "devDependencies": {
    "@preact/signals": "^1.3.0",
    "@preact/signals-core": "^1.8.0",
    "@quilted/preact-testing": "^0.1.7",
    "preact": "^10.23.0"
  },
  "browserslist": [
    "defaults and not dead"
  ]
}



================================================
FILE: packages/preact/rollup.config.js
================================================
import {quiltPackage} from '@quilted/rollup/package';

export default quiltPackage({
  react: 'preact',
  commonjs: true,
});



================================================
FILE: packages/preact/tsconfig.json
================================================
{
  "extends": "@quilted/typescript/tsconfig.package.json",
  "compilerOptions": {
    "jsxImportSource": "preact"
  },
  "references": [{"path": "../core"}, {"path": "../signals"}]
}



================================================
FILE: packages/preact/vite.config.js
================================================
import {defineConfig} from 'vitest/config';
import {quiltPackage} from '@quilted/vite/package';

export default defineConfig({
  plugins: [quiltPackage({react: 'preact'})],
  test: {
    deps: {
      optimizer: {
        web: {
          // Without this, some imports for Preact get the node_modules version, and others get
          // the optimized dependency version.
          exclude: [
            'preact',
            'preact/compat',
            '@preact/signals',
            '@preact/signals-core',
          ],
        },
      },
    },
  },
});



================================================
FILE: packages/preact/source/component.tsx
================================================
import {createElement, isValidElement, cloneElement} from 'preact';
import {forwardRef} from 'preact/compat';
import type {
  RemoteElement,
  RemoteElementConstructor,
  RemoteEventListenersFromElementConstructor,
} from '@remote-dom/core/elements';

import type {
  RemoteComponentPropsFromElementConstructor,
  RemoteComponentTypeFromElementConstructor,
} from './types.ts';

export interface RemoteComponentOptions<
  Constructor extends RemoteElementConstructor<
    any,
    any,
    any,
    any
  > = RemoteElementConstructor<any, any, any, any>,
  Props extends Record<string, any> = Record<string, any>,
> {
  /**
   * Customize how Preact props are mapped to slotted child elements. By default,
   * any prop that is listed in the remote element’s class definition, and which
   * contains a valid Preact element, is turned into a `<remote-fragment>` element
   * with a `slot` attribute set to the name of the prop. You disable this behavior
   * entirely by setting this option to `false`, or customize the tag name of the
   * wrapper element by passing the `wrapper` option.
   *
   * @default true
   */
  slotProps?:
    | boolean
    | {
        /**
         * Customizes the wrapper element used on a slotted element. If `true` or omitted,
         * the wrapper element will be a `<remote-fragment>` element. If `false`, the Preact
         * element will be cloned with a `slot` prop. If a string, that wrapper element will
         * be created.
         *
         * @default 'remote-fragment'
         */
        wrapper?: boolean | string;
      };

  /**
   * Customizes the props your wrapper React component will have for event listeners
   * on the underlying custom element. The key is the prop name on the React component,
   * and the value is an options object containing the event name on the custom element.
   *
   * @example
   * ```tsx
   * const Button = createRemoteComponent('ui-button', ButtonElement, {
   *   eventProps: {
   *     onClick: {event: 'click'},
   *   },
   * });
   * ```
   */
  eventProps?: Record<
    keyof Props,
    {
      event: keyof RemoteEventListenersFromElementConstructor<Constructor>;
    }
  >;
}

/**
 * Creates a Preact component that renders a remote DOM element. This component will pass
 * through all the props from the Preact component to the remote DOM element, and will
 * convert any props that are Preact elements into a `remote-fragment` element with a `slot`
 * attribute that matches the prop name.
 *
 * @param tag The name of the remote DOM element to render
 * @param Element The constructor for the remote DOM element to render. If not provided,
 * the constructor will be looked up using `customElements.get(tag)`.
 */
export function createRemoteComponent<
  Tag extends keyof HTMLElementTagNameMap,
  ElementConstructor extends RemoteElementConstructor<
    any,
    any,
    any,
    any
  > = HTMLElementTagNameMap[Tag] extends RemoteElement<
    infer Properties,
    infer Methods,
    infer Slots,
    infer EventListeners
  >
    ? RemoteElementConstructor<Properties, Methods, Slots, EventListeners>
    : never,
  Props extends Record<string, any> = {},
>(
  tag: Tag,
  Element: ElementConstructor | undefined = customElements.get(tag) as any,
  {
    slotProps = true,
    eventProps = {} as any,
  }: RemoteComponentOptions<ElementConstructor, Props> = {},
): RemoteComponentTypeFromElementConstructor<ElementConstructor> {
  const normalizeSlotProps = Boolean(slotProps);
  const slotPropWrapperOption =
    (typeof slotProps === 'object' ? slotProps.wrapper : undefined) ?? true;
  const slotPropWrapper =
    typeof slotPropWrapperOption === 'string'
      ? slotPropWrapperOption
      : slotPropWrapperOption
        ? 'remote-fragment'
        : false;

  // @ts-expect-error I can’t make the types work :/
  const RemoteComponent: RemoteComponentTypeFromElementConstructor<ElementConstructor> =
    forwardRef<
      InstanceType<ElementConstructor>,
      RemoteComponentPropsFromElementConstructor<ElementConstructor>
    >(function RemoteComponent(props, ref) {
      const updatedProps: Record<string, any> = {ref};
      const children = toChildren(props.children);

      for (const prop in props) {
        const propValue = props[prop];

        if (prop === 'slot') {
          updatedProps.slot = propValue;
          continue;
        }

        if (
          normalizeSlotProps &&
          Element.remoteSlotDefinitions.has(prop) &&
          isValidElement(propValue)
        ) {
          if (!slotPropWrapper) {
            children.push(cloneElement(propValue, {slot: prop}));
          } else {
            children.push(
              createElement(slotPropWrapper, {slot: prop}, propValue),
            );
          }

          continue;
        }

        const eventProp = eventProps[prop];
        if (eventProp) {
          const {event} = eventProp;

          updatedProps[`on${event as string}`] = propValue;
          continue;
        }

        updatedProps[prop] = propValue;
      }

      return createElement(tag, updatedProps, ...children);
    });

  RemoteComponent.displayName = `RemoteComponent(${tag})`;

  return RemoteComponent;
}

// Simple version of React.Children.toArray()
function toChildren(value: any) {
  if (value == null) return [];
  if (Array.isArray(value)) return value;
  return [value];
}



================================================
FILE: packages/preact/source/host.ts
================================================
export {
  SignalRemoteReceiver,
  type SignalRemoteReceiverElement,
  type SignalRemoteReceiverText,
  type SignalRemoteReceiverComment,
  type SignalRemoteReceiverRoot,
  type SignalRemoteReceiverNode,
  type SignalRemoteReceiverParent,
} from '@remote-dom/signals';
export {renderRemoteNode} from './host/node.tsx';
export {
  createRemoteComponentRenderer,
  type RemoteComponentRendererOptions,
  type RemoteComponentRendererAdditionalProps,
} from './host/component.tsx';
export {RemoteFragmentRenderer} from './host/RemoteFragmentRenderer.tsx';
export {
  RemoteRootRenderer,
  type RemoteRootRendererProps,
} from './host/RemoteRootRenderer.tsx';

export {
  usePropsForRemoteElement,
  type RemoteElementPropsOptions,
} from './host/hooks.ts';

export type {
  RemoteNodeRenderOptions,
  RemoteComponentRendererMap,
  RemoteComponentRendererProps,
} from './host/types.ts';
export {REMOTE_ELEMENT_PROP} from './host/constants.ts';

export type {
  RemoteComponentProps,
  RemoteComponentTypeFromElementConstructor,
  RemoteComponentPropsFromElementConstructor,
} from './types.ts';



================================================
FILE: packages/preact/source/html.ts
================================================
export {html} from 'htm/preact';



================================================
FILE: packages/preact/source/index.ts
================================================
export {
  createRemoteComponent,
  type RemoteComponentOptions,
} from './component.tsx';
export type {
  RemoteComponentProps,
  RemoteComponentTypeFromElementConstructor,
  RemoteComponentPropsFromElementConstructor,
} from './types.ts';



================================================
FILE: packages/preact/source/types.ts
================================================
import type {ComponentChild, ComponentType, Ref} from 'preact';
import type {
  RemoteElementConstructor,
  RemotePropertiesFromElementConstructor,
  RemoteMethodsFromElementConstructor,
  RemoteSlotsFromElementConstructor,
} from '@remote-dom/core/elements';

/**
 * The props that will be passed to a Preact component when it is rendered
 * in response to a remote element. This type includes all the remote properties
 * of the underlying element, and any slotted children, converted to Preact elements
 * passed as properties with the same name as their slot.
 */
export type RemoteComponentProps<
  Properties extends Record<string, any> = {},
  _Methods extends Record<string, any> = {},
  Slots extends Record<string, any> = {},
> = Omit<Properties, keyof Slots> & {
  [Slot in keyof Slots]: ComponentChild;
} & {
  children?: ComponentChild;
};

/**
 * Converts the type for a remote element into the full set of Preact props that
 * will be passed to a component that renders that element.
 */
export type RemoteComponentPropsFromElementConstructor<
  ElementConstructor extends RemoteElementConstructor<any, any, any, any>,
> = RemoteComponentProps<
  RemotePropertiesFromElementConstructor<ElementConstructor>,
  RemoteMethodsFromElementConstructor<ElementConstructor>,
  RemoteSlotsFromElementConstructor<ElementConstructor>
> & {ref?: Ref<InstanceType<ElementConstructor>>; slot?: string};

/**
 * Converts the type for a remote element into the type of a Preact component that
 * can be used to render that element.
 */
export type RemoteComponentTypeFromElementConstructor<
  ElementConstructor extends RemoteElementConstructor<any, any, any, any>,
  AdditionalProps extends Record<string, any> = {},
> = ComponentType<
  RemoteComponentPropsFromElementConstructor<ElementConstructor> &
    AdditionalProps
>;



================================================
FILE: packages/preact/source/host/component.tsx
================================================
import type {ComponentType} from 'preact';
import {memo, useRef, useEffect, type MutableRefObject} from 'preact/compat';
import type {RemoteReceiverElement} from '@remote-dom/core/receivers';

import {
  usePropsForRemoteElement,
  type RemoteElementPropsOptions,
} from './hooks/props-for-element.tsx';
import {REMOTE_ELEMENT_PROP} from './constants.ts';
import type {RemoteComponentRendererProps} from './types.ts';

/**
 * Additional props that are added to Preact components rendered by `createRemoteComponentRenderer`.
 */
export interface RemoteComponentRendererAdditionalProps {
  /**
   * The remote element that this component is rendering.
   */
  readonly [REMOTE_ELEMENT_PROP]: RemoteReceiverElement;
}

export interface RemoteComponentRendererOptions<Props = {}>
  extends RemoteElementPropsOptions<Props> {
  /**
   * The display name of the resulting wrapper component. By default, a name derived
   * from the wrapped component is used, with a fallback to `RemoteComponentRenderer(Component)`.
   */
  name?: string;

  /**
   * Customizes the props your wrapper Preact component will have for event listeners
   * on the underlying custom element. The key is the prop name on the Preact component,
   * and the value is an options object containing the event name on the custom element.
   *
   * @example
   * ```tsx
   * const Button = createRemoteComponent(ButtonImplementation, {
   *   eventProps: {
   *     onClick: {event: 'click'},
   *   },
   * });
   *
   * function ButtonImplementation({children, onClick}) {
   *   // Default behavior: dispatch the `detail` of the event to the remote environment
   *   return <button onClick={onClick}>{children}</button>;
   *
   *   // Alternatively, dispatch a custom value to the remote environment, including potentially
   *   // omitting the event details entirely, like we do below:
   *   return <button onClick={() => onClick()}>{children}</button>;
   * }
   * ```
   */
  eventProps?: RemoteElementPropsOptions<Props>['eventProps'];
}

interface Internals extends Pick<RemoteComponentRendererProps, 'receiver'> {
  id: string;
  instanceRef: MutableRefObject<unknown>;
}

/**
 * Takes a Preact component, and returns a new component that can be used to render that
 * component from a remote element. This wrapper will handle subscribing to changes in that
 * element, and will normalize the properties on that remote element before passing them
 * to your Preact component.
 */
export function createRemoteComponentRenderer<
  Props extends Record<string, any> = {},
>(
  Component: ComponentType<Props>,
  {name, eventProps}: NoInfer<RemoteComponentRendererOptions<Props>> = {},
): ComponentType<RemoteComponentRendererProps> {
  const RemoteComponentRenderer = memo(function RemoteComponentRenderer({
    element,
    receiver,
    components,
  }: RemoteComponentRendererProps) {
    const internalsRef = useRef<Internals>();

    const {id} = element;
    const props = usePropsForRemoteElement<Props>(element, {
      receiver,
      components,
      eventProps,
    });

    (props as any)[REMOTE_ELEMENT_PROP] = element;

    if (internalsRef.current == null) {
      const internals: Internals = {
        id,
        receiver,
      } as any;

      internals.instanceRef = createImplementationRef(internals);
      internalsRef.current = internals;
    }

    internalsRef.current.id = id;
    internalsRef.current.receiver = receiver;

    useEffect(() => {
      const node = {id};

      receiver.implement(
        node,
        internalsRef.current?.instanceRef.current as any,
      );

      return () => {
        receiver.implement(node, null);
      };
    }, [id, receiver]);

    return <Component ref={internalsRef.current.instanceRef} {...props} />;
  });

  RemoteComponentRenderer.displayName =
    name ??
    `RemoteComponentRenderer(${
      Component.displayName ?? Component.name ?? 'Component'
    })`;

  return RemoteComponentRenderer;
}

function createImplementationRef(
  internals: Pick<Internals, 'id' | 'receiver'>,
): MutableRefObject<unknown> {
  let current: unknown = null;

  return {
    get current() {
      return current;
    },
    set current(implementation) {
      current = implementation;
      internals.receiver.implement(internals, implementation as any);
    },
  };
}



================================================
FILE: packages/preact/source/host/constants.ts
================================================
/**
 * The property name used to pass a remote element instance to the Preact component
 * that is configured to render it.
 */
export const REMOTE_ELEMENT_PROP = Symbol.for('remote-dom.element');



================================================
FILE: packages/preact/source/host/hooks.ts
================================================
export {
  usePropsForRemoteElement,
  type RemoteElementPropsOptions,
} from './hooks/props-for-element.tsx';



================================================
FILE: packages/preact/source/host/node.tsx
================================================
import {
  NODE_TYPE_ELEMENT,
  NODE_TYPE_TEXT,
  NODE_TYPE_COMMENT,
} from '@remote-dom/core';
import type {SignalRemoteReceiverNode} from '@remote-dom/signals';

import type {RemoteNodeRenderOptions} from './types.ts';

/**
 * Renders a remote node to the host using Preact.
 *
 * @param node The remote node to render using Preact
 */
export function renderRemoteNode(
  node: SignalRemoteReceiverNode,
  {receiver, components}: RemoteNodeRenderOptions,
) {
  switch (node.type) {
    case NODE_TYPE_ELEMENT: {
      const Component = components.get(node.element);

      if (Component == null) {
        throw new Error(
          `No component found for remote element: ${node.element}`,
        );
      }

      return (
        <Component
          key={node.id}
          element={node}
          receiver={receiver}
          components={components}
        />
      );
    }
    case NODE_TYPE_TEXT: {
      // @preact/signals knows how to convert a string signal to a text node
      return node.data;
    }
    case NODE_TYPE_COMMENT: {
      // Don’t both rendering comments
      return null;
    }
    default: {
      throw new Error(`Unknown remote node type: ${String(node)}`);
    }
  }
}



================================================
FILE: packages/preact/source/host/RemoteFragmentRenderer.tsx
================================================
import type {FunctionComponent} from 'preact';

import {renderRemoteNode} from './node.tsx';
import type {RemoteComponentRendererProps} from './types.ts';

/**
 * A component that can be used to render a list of children elements, without any
 * additional wrapping elements. This is typically used on the host to render the `remote-root`
 * element, which is a special element rendered by Remote DOM to translate between Preact
 * elements passed as properties and slotted elements.
 */
export const RemoteFragmentRenderer: FunctionComponent<RemoteComponentRendererProps> =
  function RemoteFragmentRenderer({
    element,
    receiver,
    components,
  }: RemoteComponentRendererProps) {
    const renderOptions = {receiver, components};

    return (
      <>
        {element.children.value.map((child) =>
          renderRemoteNode(child, renderOptions),
        )}
      </>
    );
  };



================================================
FILE: packages/preact/source/host/RemoteRootRenderer.tsx
================================================
import {renderRemoteNode} from './node.tsx';
import type {RemoteNodeRenderOptions} from './types.ts';

export interface RemoteRootRendererProps extends RemoteNodeRenderOptions {}

/**
 * A component that can be used to render a tree of UI elements from a remote
 * environment.
 */
export function RemoteRootRenderer(props: RemoteRootRendererProps) {
  const {receiver} = props;
  const children = receiver.root.children.value;
  return <>{children.map((child) => renderRemoteNode(child, props))}</>;
}



================================================
FILE: packages/preact/source/host/types.ts
================================================
import type {ComponentType} from 'preact';
import type {
  SignalRemoteReceiver,
  SignalRemoteReceiverElement,
} from '@remote-dom/signals';

/**
 * The context needed to render a remote node on the host.
 */
export interface RemoteNodeRenderOptions {
  /**
   * The object that maintains the state of the remote tree on the host.
   */
  receiver: SignalRemoteReceiver;

  /**
   * A map of Preact components that can render remote elements.
   */
  components: RemoteComponentRendererMap<any>;
}

/**
 * The props that are passed to a Preact component in order to render
 * a remote element.
 */
export interface RemoteComponentRendererProps extends RemoteNodeRenderOptions {
  /**
   * The element being rendered.
   */
  element: SignalRemoteReceiverElement;
}

/**
 * A map of Preact components that can render remote elements. The keys are strings
 * that correspond to the names of the elements used in the remote environment, and
 * the values are Preact components that will accept the remote elements and render
 * DOM elements. To create these components, you can use the `createRemoteComponentRenderer()`
 * utility, which takes care of subscribing to changes in the element and passing their
 * properties along to your Preact implementation.
 */
export type RemoteComponentRendererMap<Elements extends string = string> = Map<
  Elements,
  ComponentType<RemoteComponentRendererProps>
>;



================================================
FILE: packages/preact/source/host/hooks/props-for-element.tsx
================================================
import type {SignalRemoteReceiverElement} from '@remote-dom/signals';

import {renderRemoteNode} from '../node.tsx';
import type {RemoteNodeRenderOptions} from '../types.ts';

export interface RemoteElementPropsOptions<Props = {}> {
  /**
   * Customizes the props your wrapper React component will have for event listeners
   * on the underlying custom element. The key is the prop name on the React component,
   * and the value is an options object containing the event name on the custom element.
   *
   * @example
   * ```tsx
   * const props = usePropsForRemoteElement(element, {
   *   eventProps: {
   *     onClick: {event: 'click'},
   *   },
   * });
   * ```
   */
  eventProps?: {
    [K in keyof Props]?: {
      /**
       * The event name that corresponds to this prop.
       */
      event: string;
    };
  };
}

/**
 * Converts a remote element into props for a Preact element. In addition to passing along
 * the `properties` of that element, this hook will convert any child elements with a `slot`
 * property into a prop of the same name, with the value rendered to a Preact element.
 */
export function usePropsForRemoteElement<
  Props extends Record<string, any> = {},
>(
  element: SignalRemoteReceiverElement,
  options: RemoteNodeRenderOptions & RemoteElementPropsOptions<Props>,
): Props;
export function usePropsForRemoteElement<
  Props extends Record<string, any> = {},
>(
  element: SignalRemoteReceiverElement | undefined,
  options: RemoteNodeRenderOptions & RemoteElementPropsOptions<Props>,
): Props | undefined;
export function usePropsForRemoteElement<
  Props extends Record<string, any> = {},
>(
  element: SignalRemoteReceiverElement | undefined,
  options: RemoteNodeRenderOptions & RemoteElementPropsOptions<Props>,
): Props | undefined {
  if (!element) return undefined;

  const {children, properties, attributes, eventListeners} = element;
  const resolvedEventListeners = eventListeners.value;

  const reactChildren: ReturnType<typeof renderRemoteNode>[] = [];

  const resolvedProperties: Record<string, any> = {
    ...properties.value,
    ...attributes.value,
  };

  if (options.eventProps) {
    for (const [prop, eventDescription] of Object.entries(options.eventProps)) {
      const eventName = eventDescription?.event;
      if (eventName == null) continue;

      const listener = resolvedEventListeners[eventName];
      if (listener) {
        resolvedProperties[prop] = wrapEventListenerForCallback(listener);
      }
    }
  } else {
    // Assume all event listeners are allowed, and write each one as a conventional
    // Preact callback prop.
    for (const [eventName, listener] of Object.entries(
      resolvedEventListeners,
    )) {
      resolvedProperties[
        `on${eventName[0]!.toUpperCase()}${eventName.slice(1)}`
      ] = wrapEventListenerForCallback(listener);
    }
  }

  for (const child of children.value) {
    let slot: string | undefined =
      child.type === 1 ? (child.attributes.peek().slot as any) : undefined;

    if (typeof slot !== 'string') slot = undefined;

    if (slot) {
      const rendered = renderRemoteNode(child, options);
      resolvedProperties[slot] = resolvedProperties[slot] ? (
        <>
          {resolvedProperties[slot]}
          {rendered}
        </>
      ) : (
        rendered
      );
    } else {
      reactChildren.push(renderRemoteNode(child, options));
    }
  }

  return {
    ...resolvedProperties,
    children: reactChildren,
  } as unknown as Props;
}

function wrapEventListenerForCallback(listener: (...args: any[]) => any) {
  return function eventListenerCallbackWrapper(...args: any[]) {
    if (args.length === 1 && args[0] instanceof Event) {
      const event = args[0];
      if (event.target !== event.currentTarget) return;

      return 'detail' in event ? listener(event.detail) : listener();
    }

    return listener(...args);
  };
}



================================================
FILE: packages/preact/source/tests/e2e.test.tsx
================================================
// @vitest-environment jsdom

import {describe, it, expect, vi} from 'vitest';

import {render as preactRender} from 'preact';
import {
  useRef,
  useImperativeHandle,
  forwardRef,
  type PropsWithChildren,
} from 'preact/compat';

// The `SignalRemoteReceiver` library uses `@preact/signals-core`, which does not include
// the auto-updating of Preact components when they use signals. Importing this library
// applies the internal hooks that make this work.
import '@preact/signals';

import {render} from '@quilted/preact-testing';
import {matchers, type CustomMatchers} from '@quilted/preact-testing/matchers';

import {
  RemoteMutationObserver,
  createRemoteElement,
} from '@remote-dom/core/elements';
import {SignalRemoteReceiver} from '@remote-dom/signals';

import {createRemoteComponent} from '../index.ts';
import {
  RemoteRootRenderer,
  RemoteFragmentRenderer,
  createRemoteComponentRenderer,
} from '../host.ts';

expect.extend(matchers);

declare module 'vitest' {
  interface Assertion<T = any> extends CustomMatchers<T> {}
  interface AsymmetricMatchersContaining extends CustomMatchers {}
}

interface ButtonProps {
  tooltip?: string;
  disabled?: boolean;
  onPress?(): void;
  // Alias for `onPress`, to test configurable host event listener mappings
  onClick?(): void;
}

const HostButton = forwardRef(function HostButton({
  children,
  disabled,
  onPress,
  onClick,
}: PropsWithChildren<ButtonProps>) {
  return (
    <button
      disabled={disabled}
      onClick={() => (onPress ? onPress?.() : onClick?.())}
    >
      {children}
    </button>
  );
});

const RemoteButtonElement = createRemoteElement<
  ButtonProps,
  {},
  {},
  {press(): void}
>({
  attributes: ['tooltip'],
  events: ['press'],
  properties: {
    disabled: {type: Boolean},
  },
});

const HostModal = forwardRef(function HostModal(
  {
    children,
    action,
  }: PropsWithChildren<{
    action?: ChildNode;
  }>,
  ref,
) {
  const dialogRef = useRef<HTMLDialogElement>(null);

  useImperativeHandle(ref, () => ({
    open() {
      dialogRef.current?.showModal();
    },
    close() {
      dialogRef.current?.close();
    },
  }));

  return (
    <dialog ref={dialogRef}>
      {children}
      <div>{action}</div>
    </dialog>
  );
});

const RemoteModalElement = createRemoteElement<
  {},
  {
    open(): void;
    close(): void;
  },
  {
    action?: true;
  }
>({
  methods: ['open', 'close'],
  slots: ['action'],
});

const RemoteInputElement = createRemoteElement<
  {},
  {},
  {},
  {change(detail: string): void}
>({
  events: ['change'],
});

function HostInput({onChange}: {onChange?(event: Event): void}) {
  // @ts-expect-error
  return <my-custom-input oncustomchange={onChange} />;
}

customElements.define('remote-button', RemoteButtonElement);
customElements.define('remote-modal', RemoteModalElement);
customElements.define('remote-input', RemoteInputElement);

declare global {
  interface HTMLElementTagNameMap {
    'remote-button': InstanceType<typeof RemoteButtonElement>;
    'remote-modal': InstanceType<typeof RemoteModalElement>;
    'remote-input': InstanceType<typeof RemoteInputElement>;
  }
}

const RemoteButton = createRemoteComponent(
  'remote-button',
  RemoteButtonElement,
  {
    eventProps: {
      onPress: {event: 'press'},
    },
  },
);

const RemoteModal = createRemoteComponent('remote-modal', RemoteModalElement);

const components = new Map([
  ['remote-button', createRemoteComponentRenderer(HostButton)],
  ['remote-modal', createRemoteComponentRenderer(HostModal)],
  ['remote-input', createRemoteComponentRenderer(HostInput)],
  ['remote-fragment', RemoteFragmentRenderer],
]);

describe('preact', () => {
  it('can render simple remote DOM elements', async () => {
    const receiver = new SignalRemoteReceiver();
    const mutationObserver = new RemoteMutationObserver(receiver.connection);

    const remoteRoot = document.createElement('div');
    const remoteButton = document.createElement('remote-button');
    remoteButton.textContent = 'Click me!';
    remoteRoot.append(remoteButton);

    const rendered = render(
      <RemoteRootRenderer receiver={receiver} components={components} />,
    );

    expect(rendered).not.toContainPreactComponent(HostButton);

    rendered.act(() => {
      mutationObserver.observe(remoteRoot);
    });

    expect(rendered).toContainPreactComponent(HostButton);
  });

  it('can render remote DOM elements with attributes', async () => {
    const receiver = new SignalRemoteReceiver();
    const mutationObserver = new RemoteMutationObserver(receiver.connection);

    const remoteRoot = document.createElement('div');
    const remoteButton = document.createElement('remote-button');
    remoteButton.setAttribute('tooltip', 'I do cool things.');
    remoteButton.textContent = 'Click me!';
    remoteRoot.append(remoteButton);
    mutationObserver.observe(remoteRoot);

    const rendered = render(
      <RemoteRootRenderer receiver={receiver} components={components} />,
    );

    expect(rendered).toContainPreactComponent(HostButton, {
      tooltip: 'I do cool things.',
    });
  });

  it('can render remote DOM elements with simple properties', async () => {
    const receiver = new SignalRemoteReceiver();
    const mutationObserver = new RemoteMutationObserver(receiver.connection);

    const remoteRoot = document.createElement('div');
    const remoteButton = document.createElement('remote-button');
    remoteButton.disabled = true;
    remoteButton.textContent = 'Disabled button';
    remoteRoot.append(remoteButton);
    mutationObserver.observe(remoteRoot);

    const rendered = render(
      <RemoteRootRenderer receiver={receiver} components={components} />,
    );

    expect(rendered).toContainPreactComponent(HostButton, {disabled: true});
  });

  it('can render remote DOM elements with event listeners', async () => {
    const receiver = new SignalRemoteReceiver();
    const mutationObserver = new RemoteMutationObserver(receiver.connection);

    const remoteRoot = document.createElement('div');
    const remoteButton = document.createElement('remote-button');
    remoteButton.textContent = 'Click to disable';

    remoteButton.addEventListener(
      'press',
      () => {
        remoteButton.textContent = 'Already disabled';
        remoteButton.setAttribute('disabled', '');
      },
      {once: true},
    );

    remoteRoot.append(remoteButton);
    mutationObserver.observe(remoteRoot);

    const rendered = render(
      <RemoteRootRenderer receiver={receiver} components={components} />,
    );

    expect(rendered).toContainPreactComponent(HostButton, {disabled: false});

    rendered.find(HostButton)?.trigger('onPress');

    expect(rendered).toContainPreactComponent(HostButton, {disabled: true});
  });

  it('can customize the mapping of event listeners to Preact props', async () => {
    const receiver = new SignalRemoteReceiver();
    const mutationObserver = new RemoteMutationObserver(receiver.connection);

    const remoteRoot = document.createElement('div');
    const remoteButton = document.createElement('remote-button');
    remoteButton.textContent = 'Click to disable';

    remoteButton.addEventListener(
      'press',
      () => {
        remoteButton.textContent = 'Already disabled';
        remoteButton.setAttribute('disabled', '');
      },
      {once: true},
    );

    remoteRoot.append(remoteButton);
    mutationObserver.observe(remoteRoot);

    const rendered = render(
      <RemoteRootRenderer
        receiver={receiver}
        components={
          // Use the same component mapping as other tests, but replace the `remote-button` mapping
          // with one that will map the `press` event to the `onClick` prop instead of the `onPress` prop.
          new Map([
            ...components,
            [
              'remote-button',
              createRemoteComponentRenderer(HostButton, {
                eventProps: {
                  onClick: {event: 'press'},
                },
              }),
            ],
          ])
        }
      />,
    );

    expect(rendered).toContainPreactComponent(HostButton, {disabled: false});

    rendered.find(HostButton)?.trigger('onClick');

    expect(rendered).toContainPreactComponent(HostButton, {disabled: true});
  });

  it('automatically calls a mapped callback with the `detail` of a custom event that is the only argument to an event listener', async () => {
    const receiver = new SignalRemoteReceiver();
    const mutationObserver = new RemoteMutationObserver(receiver.connection);

    const remoteRoot = document.createElement('div');
    const remoteButton = document.createElement('remote-input');

    const spy = vi.fn();

    remoteButton.addEventListener(
      'change',
      (event) => {
        spy(event.detail);
      },
      {once: true},
    );

    remoteRoot.append(remoteButton);
    mutationObserver.observe(remoteRoot);

    const rendered = render(
      <RemoteRootRenderer receiver={receiver} components={components} />,
    );

    rendered
      .find('my-custom-input')!
      .domNode!.dispatchEvent(
        new CustomEvent('customchange', {detail: 'Hello world'}),
      );

    expect(spy).toHaveBeenCalledWith('Hello world');
  });

  it('can call methods on a remote DOM element by forwarding calls to the host’s implementation component ref', async () => {
    const receiver = new SignalRemoteReceiver();
    const mutationObserver = new RemoteMutationObserver(receiver.connection);

    const remoteRoot = document.createElement('div');
    const remoteModal = document.createElement('remote-modal');
    const remoteButton = document.createElement('remote-button');
    remoteButton.slot = 'action';
    remoteButton.addEventListener('press', () => {
      remoteModal.close();
    });
    remoteModal.append(remoteButton);
    remoteRoot.append(remoteModal);
    mutationObserver.observe(remoteRoot);

    const rendered = render(
      <RemoteRootRenderer receiver={receiver} components={components} />,
    );

    const closeSpy = vi.fn();
    Object.assign(rendered.find(HostModal)!.domNode!, {close: closeSpy});

    rendered.find(HostButton)?.trigger('onPress');

    expect(closeSpy).toHaveBeenCalled();
  });

  it('can render remote DOM elements wrapped as Preact components', async () => {
    const receiver = new SignalRemoteReceiver();
    const mutationObserver = new RemoteMutationObserver(receiver.connection);

    const remoteRoot = document.createElement('div');

    function Remote() {
      const ref = useRef<InstanceType<typeof RemoteModalElement>>(null);

      return (
        <RemoteModal
          ref={ref}
          action={
            <RemoteButton
              onPress={() => {
                ref.current?.close();
              }}
            >
              Close
            </RemoteButton>
          }
        >
          Modal body
        </RemoteModal>
      );
    }

    preactRender(<Remote />, remoteRoot);

    const rendered = render(
      <RemoteRootRenderer receiver={receiver} components={components} />,
    );

    rendered.act(() => {
      mutationObserver.observe(remoteRoot);
    });

    const closeSpy = vi.fn();
    Object.assign(rendered.find(HostModal)!.domNode!, {close: closeSpy});

    rendered.find(HostButton)?.trigger('onPress');

    expect(closeSpy).toHaveBeenCalled();
  });

  it('can remove the wrapper element on elements passed as properties to remote Preact components', async () => {
    const RemoteModalWithoutWrappers = createRemoteComponent(
      'remote-modal',
      RemoteModalElement,
      {
        slotProps: {wrapper: false},
      },
    );

    function Remote() {
      const ref = useRef<InstanceType<typeof RemoteModalElement>>(null);

      return (
        <RemoteModalWithoutWrappers
          ref={ref}
          action={
            <RemoteButton
              onPress={() => {
                ref.current?.close();
              }}
            >
              Close
            </RemoteButton>
          }
        >
          Modal body
        </RemoteModalWithoutWrappers>
      );
    }

    const rendered = render(<Remote />);

    expect(rendered).not.toContainPreactComponent('remote-fragment');
    expect(rendered).toContainPreactComponent(RemoteButton, {slot: 'action'});
  });

  it('can change the wrapper element on elements passed as properties to remote Preact components', async () => {
    const RemoteModalWithBoxWrapper = createRemoteComponent(
      'remote-modal',
      RemoteModalElement,
      {
        slotProps: {wrapper: 'remote-box'},
      },
    );

    function Remote() {
      const ref = useRef<InstanceType<typeof RemoteModalElement>>(null);

      return (
        <RemoteModalWithBoxWrapper
          ref={ref}
          action={
            <RemoteButton
              onPress={() => {
                ref.current?.close();
              }}
            >
              Close
            </RemoteButton>
          }
        >
          Modal body
        </RemoteModalWithBoxWrapper>
      );
    }

    const rendered = render(<Remote />);

    expect(rendered).not.toContainPreactComponent('remote-fragment');
    expect(rendered).toContainPreactComponent('remote-box');
  });
});



================================================
FILE: packages/react/README.md
================================================
# `@remote-dom/react`

Utilities for rendering Remote DOM elements using [React](https://reactjs.org/).

## Installation

```sh
npm install @remote-dom/core @remote-dom/react --save # npm
pnpm install @remote-dom/core @remote-dom/react --save # pnpm
yarn add @remote-dom/core @remote-dom/react # yarn
```

## Usage

This library provides helpers for both the “host” and “remote” environments.

The `@remote-dom/react` entry provides wrappers for [`RemoteElement` subclasses](../core/README.md#remoteelement) that add some nice React-specific features on top of core Remote DOM library. Additionally, React DOM checks for a few browser globals that are not covered in the [core DOM polyfill](/packages/core/README.md#remote-domcorepolyfill). If you are using React in a Web Worker, you will also need to import [`@remote-dom/react/polyfill`](#polyfill) _before_ `react-dom` to ensure that these globals are available.

The `@remote-dom/react/host` provides the [`RemoteReceiver` class](../core/README.md#remotereceiver) and [`RemoteRootRenderer` component](#remoterootreceiver), which are used to render a tree of remote elements to the host environment using React.

### Remote

#### Polyfill

Some versions of React DOM check for a few specific browser globals on initialization. If you are polyfilling the DOM using [`@remote-dom/core/polyfill`](/packages/core/README.md#remote-domcorepolyfill), you will also need to import `@remote-dom/react/polyfill` _before_ `react-dom` to ensure that these globals are available.

```tsx
import '@remote-dom/core/polyfill';
import '@remote-dom/react/polyfill';

import {createRoot} from 'react-dom/client';

// Render your React app, as shown in the following examples.
```

#### `createRemoteComponent()`

As of version 18, React has minimal support for custom elements. To make the React integration a bit more seamless, Remote DOM provides the `createRemoteComponent()` function to create a React wrapper component around a custom element. This wrapper component will automatically have the TypeScript prop types it should, and will correctly assign the props on the component to either attributes, properties, or event listeners.

```tsx
import {createRoot} from 'react-dom/client';
import {createRemoteComponent} from '@remote-dom/react';

const MyElementComponent = createRemoteComponent('my-element', MyElement);

createRoot(document.querySelector('#root')).render(
  <MyElementComponent label="Hello, world!" />,
);
```

More importantly, though, this wrapper will also take care of adapting some parts of the custom element API to be feel more natural in a Preact application.

##### Event listener props

Custom React components generally expose events as callback props on the component. To support this pattern, the `createRemoteComponent()` wrapper can map specific props on the resulting Preact component to event listeners on underlying custom element.

Imagine a `ui-card` element with a clickable header. When clicked, the header will emit an `expand` event to the remote environment, and reveal the children of the `ui-card` element to the user. First, we define our custom element:

```ts
import {RemoteElement} from '@remote-dom/core/elements';

class Card extends RemoteElement {
  static get remoteEvents() {
    return ['expand'];
  }
}

customElements.define('ui-card', Card);
```

Then, we use the `createRemoteComponent()` helper function to create a wrapper React component with an `onExpand` prop, mapped to the `expand` event:

```tsx
import {createRemoteComponent} from '@remote-dom/preact';

const Card = createRemoteComponent('ui-card', CardElement, {
  eventProps: {
    onExpand: {event: 'expand'},
  },
});

render(
  <Card
    onExpand={() => {
      console.log('Card expanded!');
    }}
  >
    This is the body of the card.
  </Card>,
  document.querySelector('#root'),
);
```

##### Slotted children to React elements

The `createRemoteComponent` helper also supports mapping slotted children to React elements. Each top-level slot of the element’s children will be mapped to a prop with the same name on the React component.

For example, our `ui-card` custom element could take a `header` slot for customizing the title of the card:

```ts
import {RemoteElement} from '@remote-dom/core/elements';

class Card extends RemoteElement {
  static get remoteSlots() {
    return ['header'];
  }
}

class Text extends RemoteElement {}

customElements.define('ui-card', Card);
customElements.define('ui-text', Text);
```

The `createRemoteComponent()` wrapper will allow you to pass a `header` prop to the resulting React component, which can be any other React element:

```tsx
import {createRoot} from 'react-dom/client';
import {createRemoteComponent} from '@remote-dom/react';

const Card = createRemoteComponent('ui-card', CardElement);
const Text = createRemoteComponent('ui-text', TextElement);

createRoot(document.querySelector('#root')).render(
  <Card header={<Text>Hello, world!</Text>}>
    This is the body of the card.
  </Card>,
);
```

To make this work, the wrapper component will wrap the React element prop in a `<remote-fragment>` element, and place it as a child of the parent element. So, the above example could have been written manually like this:

```tsx
import {createRoot} from 'react-dom/client';

createRoot(document.querySelector('#root')).render(
  <ui-card>
    This is the body of the card.
    <remote-fragment slot="header">
      <ui-text>Hello, world!</ui-text>
    </remote-fragment>
  </ui-card>,
);
```

To disable this behavior, you can pass `{slotProps: {wrapper: false}}` option to `createRemoteComponent()`. This will cause any element props to be cloned with a `slot` prop, instead of wrapping them in a `<remote-fragment>` element.

```tsx
import {createRoot} from 'react-dom/client';
import {createRemoteComponent} from '@remote-dom/react';

const Card = createRemoteComponent('ui-card', CardElement, {
  slotProps: {
    wrapper: false,
  },
});

const Text = createRemoteComponent('ui-text', TextElement);

createRoot(document.querySelector('#root')).render(
  <Card header={<Text>Hello, world!</Text>}>
    This is the body of the card.
  </Card>,
);

// Now, renders this tree of HTML elements:
// <ui-card>
//   This is the body of the card.
//   <ui-text slot="header">Hello, world!</ui-text>
// </ui-card>
```

### Host

#### `RemoteReceiver`

The `@remote-dom/react/host` package re-exports the [`RemoteReceiver` class from `@remote-dom/core`](../core/README.md#remotereceiver). This object will store the state of the remote tree of elements, and the [`RemoteRootRenderer` component](#remoterootrenderer) expects to receive an instance of this class in order to map the remote tree to React components.

#### `createRemoteComponentRenderer()`

The [`RemoteRootRenderer` component](#remoterootrenderer) needs a map of which React components to render for each remote element. These components will receive a description of the remote element, but not much more. The `createRemoteComponentRenderer()` function can be used to create a wrapper React component that will automatically update whenever the properties or children of the associated remote element change. The props passed to your React component will be the combined result of:

- The `properties` of the remote element
- The `attributes` of the remote element
- The `eventListeners` of the remote element, with each event listener being mapped to a prop named in the format `onEventName`
- The `children` of the remote element, where any children with a `slot` attribute are mapped to a prop with the same name

```tsx
import {createRemoteComponentRenderer} from '@remote-dom/react/host';

// Imagine we are implementing the host version of our `ui-card` custom element above,
// which allows a `header` slot. We’ll also have it accept a `subdued` property to
// customize its appearance.

const Card = createRemoteComponentRenderer(function Card({
  header,
  subdued,
  onExpand,
  children,
}) {
  const [isExpanded, setIsExpanded] = useIsExpanded();

  return (
    <div
      class={[
        'Card',
        isExpanded && 'Card--expanded',
        subdued && 'Card--subdued',
      ]
        .filter(Boolean)
        .join(' ')}
    >
      {header && (
        <button
          class="Card__Header"
          onClick={() => {
            const isExpanded = !isExpanded;
            setIsExpanded(isExpanded);
            if (isExpanded && onExpand) onExpand();
          }}
        >
          {header}
        </button>
      )}
      {children}
    </div>
  );
});
```

##### Host event listener props

Like with creating a [React wrapper in the remote environment with `createRemoteComponent()`](#event-listener-props), a host using React likely wants to map event listeners to conventional React callback props. Like with creating a React wrapper for the remote environment, let’s return to our `ui-card` example. To refresh, we are imagining a collapsible card element that will emit an `expand` event to the remote environment when its contents are revealed. In the remote environment, our custom element would be defined like this:

```ts
import {RemoteElement} from '@remote-dom/core/elements';

class Card extends RemoteElement {
  static get remoteEvents() {
    return ['expand'];
  }
}

customElements.define('ui-card', Card);

const card = document.createElement('ui-card');
card.textContent = 'This is the body of the card.';

card.addEventListener('expand', (event) => {
  console.log('Card expanded!', event.detail);
});
```

By default, Remote DOM will map these an event listener to a conventionally-named React prop — that is, `on`, followed by the pascal-case name of the event, like `onExpand`. So, when using the `createRemoteComponentRenderer()` function, you can automatically invoke the event listeners by calling the conventional prop, with the first argument you pass being set as the `detail` of the resulting remote event:

```tsx
import {createRemoteComponentRenderer} from '@remote-dom/react/host';

const Card = createRemoteComponentRenderer(function Card({children, onExpand}) {
  return (
    <div>
      {/* when clicked, will emit the `expand` remote event with this object as the `detail` field */}
      <button onClick={() => onExpand({timestamp: Date.now()})}>Expand</button>
      {children}
    </div>
  );
});
```

The default logic also allows you to pass an `Event` object to the React callback. When you do so, the `detail` field of the event will be passed to the remote environment directly. This can be useful when, for example, you have an existing web component being rendered by React that already emits a custom event with the necessary data.

```tsx
import {createRemoteComponentRenderer} from '@remote-dom/react/host';

const Card = createRemoteComponentRenderer(function Card({children, onExpand}) {
  return (
    // Can pass the callback directly as an event listener to create a corresponding remote event automatically.
    <ui-card onexpand={onExpand}>{children}</ui-card>
  );
});
```

If this default behavior does not work for you, you can customize which events get mapped to properties, and what prop name that event maps to. This is done by passing a second argument to `createRemoteComponentRenderer()`, an object with an `eventProps` key. Each key in this `eventProps` option should be the name of a React property to create on the wrapper component, and the value is an object that describes which event listener to read for that property.

```tsx
import {createRemoteComponentRenderer} from '@remote-dom/preact/host';

const Card = createRemoteComponentRenderer(
  function Card({children, onexpand}) {
    return <ui-card onexpand={onexpand}>{children}</ui-card>;
  },
  {
    eventProps: {
      // Convert the `expand` event listener into an all-lowercase `onexpand` prop, which allows the prop to be passed
      // directly as a web component event listener (in React 19+).
      onexpand: {event: 'expand'},
    },
  },
);
```

If your event bubbles, be careful not to call the callback unless the matching remote element for this component is actually the target of the emitted event. For example, if you had two components that both support `click` events in the remote environment, implementing the event listener like this would cause a single click on the host version of the button to trigger two separate events:

```tsx
// Remote environment: two elements that can emit the same event, each with
// an event listener attached:

import {RemoteElement} from '@remote-dom/core/elements';

class Card extends RemoteElement {
  static get remoteEvents() {
    return {
      click: {
        bubbles: true,
      },
    };
  }
}

class Button extends RemoteElement {
  static get remoteEvents() {
    return {
      click: {
        bubbles: true,
      },
    };
  }
}

customElements.define('ui-card', Card);
customElements.define('ui-button', Button);

const card = document.createElement('ui-card');
card.addEventListener('click', (event) => {
  console.log('Click event in card', event.target);
});

const button = document.createElement('ui-button');
button.textContent = 'Click me!';
button.addEventListener('click', (event) => {
  console.log('Click event in button', event.target);
});

card.append(button);

// Host: both are implemented to call their respective event listener props when clicked,
// leads to `card.addEventListener()` callback being called twice (once from the bubbling
// click on `ui-button` in the remote, and once from the bubbling in the host).

import {createRemoteComponentRenderer} from '@remote-dom/react/host';

const Card = createRemoteComponentRenderer(function Card({children, onClick}) {
  // This `onclick` will be called, even if the `Button` was the actual target
  return <ui-card onClick={() => onClick?.()}>{children}</ui-card>;
});

const Button = createRemoteComponentRenderer(function Button({
  children,
  onClick,
}) {
  return <ui-button onClick={() => onClick?.()}>{children}</ui-button>;
});
```

To avoid this issue, you should manually check that the target of the event is the current element before calling the callback, which will prevent the event from being dispatched on ancestor elements in the remote environment:

```tsx
import {createRemoteComponentRenderer} from '@remote-dom/react/host';

const Card = createRemoteComponentRenderer(function Card({children, onClick}) {
  // This `onclick` will be called, even if the `Button` was the actual target
  return (
    <ui-card
      onClick={(event) => {
        if (event.target === event.currentTarget) {
          onClick?.();
        }
      }}
    >
      {children}
    </ui-card>
  );
});

const Button = createRemoteComponentRenderer(function Button({
  children,
  onClick,
}) {
  return (
    <ui-button
      onClick={(event) => {
        if (event.target === event.currentTarget) {
          onClick?.();
        }
      }}
    >
      {children}
    </ui-button>
  );
});
```

If you pass the event object directly to the callback, Remote DOM will automatically apply this protection for you, so you do not need to protect against this case manually:

```tsx
import {createRemoteComponentRenderer} from '@remote-dom/react/host';

const Card = createRemoteComponentRenderer(function Card({children, onClick}) {
  // Pass the callback directly through as an event listener.
  return <ui-card onClick={onClick}>{children}</ui-card>;
});

const Button = createRemoteComponentRenderer(function Button({
  children,
  onClick,
}) {
  return <ui-button onClick={onClick}>{children}</ui-button>;
});
```

#### `RemoteRootRenderer`

The `RemoteRootRenderer` component is used to render a tree of remote elements to the host environment using React. It expects a `receiver` prop, a [`RemoteReceiver` instance](../core/README.md#remotereceiver) that will store the state of the remote tree of elements. It also accepts a `components` prop, which provides the mapping of which React component to render for each remote element.

The following component shows an example of how you could render a tree of remote elements using React. You’ll need to hand the `receiver` object’s `connection` property to the remote environment; some examples of how to do this are shown in the [runnable Remote DOM examples](/examples/).

```tsx
import {createRoot} from 'react-dom/client';
import {
  createRemoteComponentRenderer,
  RemoteRootRenderer,
  RemoteReceiver,
} from '@remote-dom/react/host';

// Create wrapper elements to render our actual UI components in response
// to remote elements. See the `createRemoteComponentRenderer()` section above.
const Card = createRemoteComponentRenderer(UICard);

const receiver = new RemoteReceiver();
// TODO: send the `receiver.connection` object to the remote environment,
// so it can send us updates about the tree of remote elements.

createRoot(document.querySelector('#root')).render(
  <RemoteRootRenderer
    receiver={receiver}
    components={new Map([['ui-card', Card]])}
  />,
);
```

#### `RemoteFragmentRenderer`

As noted above, Remote DOM may render a `<remote-fragment>` element to wrap a React element that is passed as a prop to a remote element. The `RemoteFragmentRenderer` component is used to render these fragments — it simply renders each child element inside of a React wrapper, which prevents any unnecessary wrapper elements from being introduced in the final DOM output.

```tsx
import {createRoot} from 'react-dom/client';
import {
  createRemoteComponentRenderer,
  RemoteRootRenderer,
  RemoteFragmentRenderer,
  SignalRemoteReceiver,
} from '@remote-dom/react/host';

// Same setup as above...

createRoot(document.querySelector('#root')).render(
  <RemoteRootRenderer
    receiver={receiver}
    components={
      new Map([
        ['ui-card', Card],
        // We allow `remote-fragment` elements to be rendered, which is the
        // name Remote DOM gives these wrapper elements by default. If you changed
        // the name using the `slotProps.wrapper` option, match that name here.
        ['remote-fragment', RemoteFragmentRenderer],
      ])
    }
  />,
  document.querySelector('#root'),
);
```



================================================
FILE: packages/react/CHANGELOG.md
================================================
# @remote-dom/react

## 1.2.2

### Patch Changes

- [#536](https://github.com/Shopify/remote-dom/pull/536) [`9abf5be`](https://github.com/Shopify/remote-dom/commit/9abf5bee323dfa522f9061ba61ce2f433a36cb4e) Thanks [@igor10k](https://github.com/igor10k)! - Use the same core dependency version for all packages

## 1.2.1

### Patch Changes

- [#492](https://github.com/Shopify/remote-dom/pull/492) [`59f417b`](https://github.com/Shopify/remote-dom/commit/59f417b4abe5aa5d59999200430a18f5fe1aa810) Thanks [@lemonmade](https://github.com/lemonmade)! - Apply React polyfill directly to `globalThis`

## 1.2.0

### Minor Changes

- [#389](https://github.com/Shopify/remote-dom/pull/389) [`2479b21`](https://github.com/Shopify/remote-dom/commit/2479b21406f6149063bfc095dbb6c3a019386403) Thanks [@lemonmade](https://github.com/lemonmade)! - Added native support for synchronizing attributes and event listeners

  Previously, Remote DOM only offered “remote properties” as a way to synchronize element state between the host and remote environments. These remote properties effectively synchronize a subset of a custom element’s instance properties. The `RemoteElement` class offers [a declarative way to define the properties that should be synchronized](/packages/core/README.md#remote-properties).

  ```ts
  import {RemoteElement} from '@remote-dom/core/elements';

  class MyElement extends RemoteElement {
    static get remoteProperties() {
      return ['label'];
    }
  }

  customElements.define('my-element', MyElement);

  const myElement = document.createElement('my-element');
  myElement.label = 'Hello, World!';
  ```

  The same `remoteProperties` configuration can create special handling for attributes and event listeners. By default, a remote property is automatically updated when setting an [attribute](https://developer.mozilla.org/en-US/docs/Glossary/Attribute) of the same name:

  ```ts
  const myElement = document.createElement('my-element');
  myElement.setAttribute('label', 'Hello, World!');

  // myElement.label === 'Hello, World!', and this value is synchronized
  // with the host environment as a “remote property”
  ```

  Similarly, a remote property can be automatically updated when adding an event listener based on a conventional `on` property naming prefix:

  ```ts
  import {RemoteElement} from '@remote-dom/core/elements';

  class MyElement extends RemoteElement {
    static get remoteProperties() {
      return {
        onChange: {
          event: true,
        },
      };
    }
  }

  customElements.define('my-element', MyElement);

  const myElement = document.createElement('my-element');

  // This adds a callback property that is synchronized with the host environment
  myElement.onChange = () => console.log('Changed!');

  // And so does this, but using the `addEventListener` method instead
  myElement.addEventListener('change', () => console.log('Changed!'));
  ```

  These utilities are handy, but they don’t align with patterns in native DOM elements, particularly when it comes to events. Now, both of these can be represented in a fashion that is more conventional in HTML. The `remoteAttributes` configuration allows you to define a set of element attributes that will be synchronized directly the host environment, instead of being treated as instance properties:

  ```ts
  import {RemoteElement} from '@remote-dom/core/elements';

  class MyElement extends RemoteElement {
    static get remoteAttributes() {
      return ['label'];
    }

    // If you want to add instance properties, you can do it with getters and
    // setters that manipulate the attribute value:
    //
    // get label() {
    //   return this.getAttribute('label');
    // }
    //
    // set label(value) {
    //   this.setAttribute('label', value);
    // }
  }

  customElements.define('my-element', MyElement);

  const myElement = document.createElement('my-element');
  myElement.setAttribute('label', 'Hello, World!');
  ```

  Similarly, the `remoteEvents` configuration allows you to define a set of event listeners that will be synchronized directly with the host environment:

  ```ts
  import {RemoteElement} from '@remote-dom/core/elements';

  class MyElement extends RemoteElement {
    static get remoteEvents() {
      return ['change'];
    }
  }

  customElements.define('my-element', MyElement);

  const myElement = document.createElement('my-element');

  // And so does this, but using the `addEventListener` method instead
  myElement.addEventListener('change', () => console.log('Changed!'));

  // No `myElement.onChange` property is created
  ```

  The `remoteProperties` configuration will continue to be supported for cases where you want to synchronize instance properties. Because instance properties can be any JavaScript type, properties are the highest-fidelity field that can be synchronized between the remote and host environments. However, adding event listeners using the `remoteProperties.event` configuration is **deprecated and will be removed in the next major version**. You should use the `remoteEvents` configuration instead. If you were previously defining remote properties which only accepted strings, consider using the `remoteAttributes` configuration, which stores the value entirely in an HTML attribute instead.

  This change is being released in a backwards-compatible way, so you can continue to use the existing `remoteProperties` configuration on host and/or remote environments without any code changes.

  All host utilities have been updated to support the new `attributes` and `eventListeners` property that are synchronized with the remote environment. This includes updates to the [React](/packages/react/README.md#event-listener-props) and [Preact hosts to map events to conventional callback props](/packages/preact/README.md#event-listener-props), and updates to the [`DOMRemoteReceiver` class](/packages/core/README.md#domremotereceiver), which now applies fields to the host element exactly as they were applied in the remote environment:

  ```ts
  // Remote environment:

  class MyElement extends RemoteElement {
    static get remoteEvents() {
      return ['change'];
    }
  }

  customElements.define('my-element', MyElement);

  const myElement = document.createElement('my-element');

  myElement.addEventListener('change', (event) => {
    console.log('Changed! New value: ', event.detail);
  });

  // Host environment:

  class MyElement extends HTMLElement {
    connectedCallback() {
      // Emit a change event on this element, with detail that will be passed
      // to the remote environment
      this.addEventListener('change', (event) => {
        event.stopImmediatePropagation();

        this.dispatchEvent(
          new CustomEvent('change', {
            detail: this.value,
          }),
        );
      });
    }

    // Additional implementation details of the host custom element...
  }

  customElements.define('my-element', MyElement);
  ```

### Patch Changes

- Updated dependencies [[`2479b21`](https://github.com/Shopify/remote-dom/commit/2479b21406f6149063bfc095dbb6c3a019386403)]:
  - @remote-dom/core@1.5.0

## 1.1.0

### Minor Changes

- [#411](https://github.com/Shopify/remote-dom/pull/411) [`3bec698`](https://github.com/Shopify/remote-dom/commit/3bec6983756c4b8a6834a037ac520438ef59d28f) Thanks [@lemonmade](https://github.com/lemonmade)! - Add CommonJS export conditions

### Patch Changes

- Updated dependencies [[`3bec698`](https://github.com/Shopify/remote-dom/commit/3bec6983756c4b8a6834a037ac520438ef59d28f)]:
  - @remote-dom/core@1.4.0

## 1.0.2

### Patch Changes

- [`6e1f6b6`](https://github.com/Shopify/remote-dom/commit/6e1f6b69aec1958e9e5f125bd9d16847f905efa7) Thanks [@lemonmade](https://github.com/lemonmade)! - Fix React package including `preact/jsx-runtime` imports in output

## 1.0.1

### Patch Changes

- [`2b09e04`](https://github.com/Shopify/remote-dom/commit/2b09e042ff87f047fbe98481a73d31b785c9987f) Thanks [@lemonmade](https://github.com/lemonmade)! - Ensure React polyfill includes minimal `location` and `navigator` polyfills

## 1.0.0

### Major Changes

- [`37be652`](https://github.com/Shopify/remote-dom/commit/37be652f288d1eec170c0be13b2da516f8db5dcf) Thanks [@lemonmade](https://github.com/lemonmade)! - First release of Remote DOM. Read more about this [refactor of remote-ui on native DOM APIs](https://github.com/Shopify/remote-dom/discussions/267), and take a look at the [updated documentation](/README.md).

### Patch Changes

- Updated dependencies [[`37be652`](https://github.com/Shopify/remote-dom/commit/37be652f288d1eec170c0be13b2da516f8db5dcf)]:
  - @remote-dom/core@1.0.0

## 0.1.3

### Patch Changes

- [`7398741`](https://github.com/Shopify/remote-dom/commit/7398741dc42f474d344ed98ea634bc6a255d6650) Thanks [@lemonmade](https://github.com/lemonmade)! - Mark React polyfill as having side effects

## 0.1.2

### Patch Changes

- [#269](https://github.com/Shopify/remote-dom/pull/269) [`e4629a7`](https://github.com/Shopify/remote-dom/commit/e4629a7e50057eb57f8a2f90b393fba6688d0d19) Thanks [@shopify-github-actions-access](https://github.com/apps/shopify-github-actions-access)! - Add React-specific polyfills

## 0.1.1

### Patch Changes

- Updated dependencies [[`9576a72`](https://github.com/Shopify/remote-dom/commit/9576a72fa354481621c53efde4169829fe9bfabf)]:
  - @remote-dom/core@0.1.1

## 0.1.0

### Minor Changes

- [`7061ded`](https://github.com/Shopify/remote-dom/commit/7061ded1da4699c6dd6a820eeb940a8af7c66d82) Thanks [@lemonmade](https://github.com/lemonmade)! - Test minor bump

### Patch Changes

- Updated dependencies [[`7061ded`](https://github.com/Shopify/remote-dom/commit/7061ded1da4699c6dd6a820eeb940a8af7c66d82)]:
  - @remote-dom/core@0.1.0

## 0.0.2

### Patch Changes

- [#251](https://github.com/Shopify/remote-dom/pull/251) [`5939cca`](https://github.com/Shopify/remote-dom/commit/5939cca8112417124327bd26f9e2c21f4bf9b20a) Thanks [@lemonmade](https://github.com/lemonmade)! - Test version bump

- Updated dependencies [[`5939cca`](https://github.com/Shopify/remote-dom/commit/5939cca8112417124327bd26f9e2c21f4bf9b20a), [`8e1fad4`](https://github.com/Shopify/remote-dom/commit/8e1fad4a00cfe68ff1594fbabeec10c29958685f)]:
  - @remote-dom/core@0.0.2



================================================
FILE: packages/react/package.json
================================================
{
  "name": "@remote-dom/react",
  "type": "module",
  "license": "MIT",
  "publishConfig": {
    "access": "public",
    "@remote-dom/registry": "https://registry.npmjs.org"
  },
  "version": "1.2.2",
  "engines": {
    "node": ">=18.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/Shopify/remote-dom",
    "directory": "packages/react"
  },
  "exports": {
    ".": {
      "types": "./build/typescript/index.d.ts",
      "quilt:source": "./source/index.ts",
      "quilt:esnext": "./build/esnext/index.esnext",
      "import": "./build/esm/index.mjs",
      "require": "./build/cjs/index.cjs"
    },
    "./host": {
      "types": "./build/typescript/host.d.ts",
      "quilt:source": "./source/host.ts",
      "quilt:esnext": "./build/esnext/host.esnext",
      "import": "./build/esm/host.mjs",
      "require": "./build/cjs/host.cjs"
    },
    "./html": {
      "types": "./build/typescript/html.d.ts",
      "quilt:source": "./source/html.ts",
      "quilt:esnext": "./build/esnext/html.esnext",
      "import": "./build/esm/html.mjs",
      "require": "./build/cjs/html.cjs"
    },
    "./polyfill": {
      "types": "./build/typescript/polyfill.d.ts",
      "quilt:source": "./source/polyfill.ts",
      "quilt:esnext": "./build/esnext/polyfill.esnext",
      "import": "./build/esm/polyfill.mjs",
      "require": "./build/cjs/polyfill.cjs"
    }
  },
  "types": "./build/typescript/index.d.ts",
  "typesVersions": {
    "*": {
      "host": [
        "./build/typescript/host.d.ts"
      ],
      "html": [
        "./build/typescript/html.d.ts"
      ],
      "polyfill": [
        "./build/typescript/polyfill.d.ts"
      ]
    }
  },
  "sideEffects": [
    "./source/polyfill.ts",
    "./build/esnext/polyfill.esnext",
    "./build/esm/polyfill.mjs"
  ],
  "scripts": {
    "build": "rollup --config rollup.config.js"
  },
  "dependencies": {
    "@remote-dom/core": "workspace:^1.7.0",
    "@types/react": "^18.0.0",
    "htm": "^3.1.1"
  },
  "peerDependencies": {
    "react": "^17.0.0 || ^18.0.0"
  },
  "peerDependenciesMeta": {
    "react": {
      "optional": true
    }
  },
  "devDependencies": {
    "@quilted/react-testing": "^0.6.11",
    "@types/react-dom": "^18.3.0",
    "react": "^18.3.0",
    "react-dom": "^18.3.0"
  },
  "browserslist": [
    "defaults and not dead"
  ]
}



================================================
FILE: packages/react/rollup.config.js
================================================
import {quiltPackage} from '@quilted/rollup/package';

export default quiltPackage({react: 'react', commonjs: true});



================================================
FILE: packages/react/tsconfig.json
================================================
{
  "extends": "@quilted/typescript/tsconfig.package.json",
  "references": [{"path": "../core"}, {"path": "../signals"}]
}



================================================
FILE: packages/react/vite.config.js
================================================
import {defineConfig} from 'vitest/config';
import {quiltPackage} from '@quilted/vite/package';

export default defineConfig({
  plugins: [
    quiltPackage({
      react: 'react',
    }),
  ],
  test: {
    deps: {
      optimizer: {
        web: {
          // Without this, some imports for React get the node_modules version, and others get
          // the optimized dependency version.
          exclude: ['react', 'react-dom'],
        },
      },
    },
  },
});



================================================
FILE: packages/react/source/component.tsx
================================================
import {
  useRef,
  useLayoutEffect,
  createElement,
  forwardRef,
  isValidElement,
  cloneElement,
} from 'react';
import type {
  RemoteElement,
  RemoteElementConstructor,
  RemoteEventListenersFromElementConstructor,
} from '@remote-dom/core/elements';

import type {
  RemoteComponentTypeFromElementConstructor,
  RemoteComponentPropsFromElementConstructor,
} from './types.ts';

export interface RemoteComponentOptions<
  Constructor extends RemoteElementConstructor<
    any,
    any,
    any,
    any
  > = RemoteElementConstructor<any, any, any, any>,
  Props extends Record<string, any> = Record<string, any>,
> {
  /**
   * Customize how React props are mapped to slotted child elements. By default,
   * any prop that is listed in the remote element’s class definition, and which
   * contains a valid React element, is turned into a `<remote-fragment>` element
   * with a `slot` attribute set to the name of the prop. You disable this behavior
   * entirely by setting this option to `false`, or customize the tag name of the
   * wrapper element by passing the `wrapper` option.
   *
   * @default true
   */
  slotProps?:
    | boolean
    | {
        /**
         * Customizes the wrapper element used on a slotted element. If `true` or omitted,
         * the wrapper element will be a `<remote-fragment>` element. If `false`, the React
         * element will be cloned with a `slot` prop. If a string, that wrapper element will
         * be created.
         *
         * @default 'remote-fragment'
         */
        wrapper?: boolean | string;
      };

  /**
   * Customizes the props your wrapper React component will have for event listeners
   * on the underlying custom element. The key is the prop name on the React component,
   * and the value is an options object containing the event name on the custom element.
   *
   * @example
   * ```tsx
   * const Button = createRemoteComponent('ui-button', ButtonElement, {
   *   eventProps: {
   *     onClick: {event: 'click'},
   *   },
   * });
   * ```
   */
  eventProps?: Record<
    keyof Props,
    {
      event: keyof RemoteEventListenersFromElementConstructor<Constructor>;
    }
  >;
}

/**
 * Creates a React component that renders a remote DOM element. This component will pass
 * through all the props from the React component to the remote DOM element, and will
 * convert any props that are React elements into a `remote-fragment` element with a `slot`
 * attribute that matches the prop name.
 *
 * @param tag The name of the remote DOM element to render
 * @param Element The constructor for the remote DOM element to render. If not provided,
 * the constructor will be looked up using `customElements.get(tag)`.
 */
export function createRemoteComponent<
  Tag extends keyof HTMLElementTagNameMap,
  ElementConstructor extends RemoteElementConstructor<
    any,
    any,
    any,
    any
  > = HTMLElementTagNameMap[Tag] extends RemoteElement<
    infer Properties,
    infer Methods,
    infer Slots,
    infer EventListeners
  >
    ? RemoteElementConstructor<Properties, Methods, Slots, EventListeners>
    : never,
  Props extends Record<string, any> = {},
>(
  tag: Tag,
  Element: ElementConstructor | undefined = customElements.get(tag) as any,
  {
    slotProps = true,
    eventProps = {} as any,
  }: RemoteComponentOptions<ElementConstructor, Props> = {},
): RemoteComponentTypeFromElementConstructor<ElementConstructor> {
  const normalizeSlotProps = Boolean(slotProps);
  const slotPropWrapperOption =
    (typeof slotProps === 'object' ? slotProps.wrapper : undefined) ?? true;
  const slotPropWrapper =
    typeof slotPropWrapperOption === 'string'
      ? slotPropWrapperOption
      : slotPropWrapperOption
        ? 'remote-fragment'
        : false;

  // @ts-expect-error I can’t make the types work :/
  const RemoteComponent: RemoteComponentTypeFromElementConstructor<ElementConstructor> =
    forwardRef<
      InstanceType<ElementConstructor>,
      RemoteComponentPropsFromElementConstructor<ElementConstructor>
    >(function RemoteComponent(props, ref) {
      const internalRef = useRef<any>();
      const lastRemotePropertiesRef = useRef<Record<string, any>>();

      const remoteProperties: Record<string, any> = {};
      const children = toChildren(props.children);

      for (const prop in props) {
        const propValue = props[prop];

        if (prop === 'slot') {
          remoteProperties.slot = propValue;
          continue;
        }

        if (
          normalizeSlotProps &&
          Element.remoteSlotDefinitions.has(prop) &&
          isValidElement(propValue)
        ) {
          if (!slotPropWrapper) {
            children.push(cloneElement(propValue as any, {slot: prop}));
          } else {
            children.push(
              createElement(slotPropWrapper, {slot: prop}, propValue),
            );
          }

          continue;
        }

        remoteProperties[prop] = propValue;
      }

      useLayoutEffect(() => {
        const element = internalRef.current;
        if (element == null) return;

        for (const prop in remoteProperties) {
          if (prop === 'children') continue;

          const oldValue = lastRemotePropertiesRef.current?.[prop];
          const newValue = remoteProperties[prop];

          if (oldValue === newValue) continue;

          const eventProp = eventProps[prop];
          if (eventProp) {
            const eventName = eventProp.event;
            if (oldValue) element.removeEventListener(eventName, oldValue);
            if (newValue) element.addEventListener(eventName, newValue);
            continue;
          }

          if (prop in element) {
            element[prop] = remoteProperties[prop];
            continue;
          }

          if (newValue == null) {
            element.removeAttribute(prop);
          } else {
            element.setAttribute(prop, String(newValue));
          }
        }

        lastRemotePropertiesRef.current = remoteProperties;
      });

      return createElement(
        tag,
        {
          ref: (refValue: any) => {
            internalRef.current = refValue;
            if (typeof ref === 'function') ref(refValue);
            else if (ref != null) ref.current = refValue;
          },
        },
        ...children,
      );
    });

  RemoteComponent.displayName = `RemoteComponent(${tag})`;

  return RemoteComponent;
}

// Simple version of React.Children.toArray()
function toChildren(value: any) {
  if (value == null) return [];
  if (Array.isArray(value)) return [...value];
  return [value];
}



================================================
FILE: packages/react/source/host.ts
================================================
export {
  RemoteReceiver,
  type RemoteReceiverElement,
  type RemoteReceiverText,
  type RemoteReceiverComment,
  type RemoteReceiverRoot,
  type RemoteReceiverNode,
  type RemoteReceiverParent,
} from '@remote-dom/core/receivers';

export {renderRemoteNode} from './host/node.tsx';
export {
  createRemoteComponentRenderer,
  type RemoteComponentRendererOptions,
  type RemoteComponentRendererAdditionalProps,
} from './host/component.tsx';
export {RemoteFragmentRenderer} from './host/RemoteFragmentRenderer.tsx';
export {
  RemoteTextRenderer,
  type RemoteTextRendererProps,
} from './host/RemoteTextRenderer.tsx';
export {
  RemoteRootRenderer,
  type RemoteRootRendererProps,
} from './host/RemoteRootRenderer.tsx';

export {
  useRemoteReceived,
  usePropsForRemoteElement,
  type RemoteElementPropsOptions,
} from './host/hooks.ts';

export type {
  RemoteNodeRenderOptions,
  RemoteComponentRendererMap,
  RemoteComponentRendererProps,
} from './host/types.ts';
export {
  REMOTE_ELEMENT_PROP,
  REMOTE_ELEMENT_ATTACHED_PROP,
} from './host/constants.ts';

export type {
  RemoteComponentProps,
  RemoteComponentTypeFromElementConstructor,
  RemoteComponentPropsFromElementConstructor,
} from './types.ts';



================================================
FILE: packages/react/source/html.ts
================================================
export {html} from 'htm/react';



================================================
FILE: packages/react/source/index.ts
================================================
export {
  createRemoteComponent,
  type RemoteComponentOptions,
} from './component.tsx';
export type {
  RemoteComponentProps,
  RemoteComponentTypeFromElementConstructor,
  RemoteComponentPropsFromElementConstructor,
} from './types.ts';



================================================
FILE: packages/react/source/polyfill.ts
================================================
class HTMLIFrameElement extends HTMLElement {}

// React checks whether elements are Iframes on initialization.
defineGlobalProperty('HTMLIFrameElement', {
  value: HTMLIFrameElement,
  configurable: true,
});

// React ues the `location` and `navigator` properties when printing help text in
// development, and the `Window` polyfill from Remote DOM doesn’t define these properties.
// We copy their implementation from the existing global scope when it exists, and
// provide a minimal working implementation otherwise.
defineGlobalProperty('location', {
  value: globalThis.location ?? {protocol: 'https:'},
  configurable: true,
});

defineGlobalProperty('navigator', {
  value: globalThis.navigator ?? {userAgent: ''},
  configurable: true,
});

class CSSStyleDeclaration {
  getPropertyValue(_key: string): string | null | undefined {
    return undefined;
  }

  removeProperty(_key: string) {
    // noop
  }

  setProperty(_key: string, _value?: string | null) {
    // noop
  }

  get cssText() {
    return '';
  }

  set cssText(_css) {
    // noop
  }
}

// React checks for a few properties in `document.createElement('div').style`
const STYLE = Symbol('style');
Object.defineProperty(Element.prototype, 'style', {
  configurable: true,
  get() {
    let style = this[STYLE];
    if (!style) {
      style = new CSSStyleDeclaration();
      this[STYLE] = style;
    }
    return style;
  },
  set(cssText) {
    this.style.cssText = String(cssText);
  },
});

function defineGlobalProperty(name: string, descriptor: PropertyDescriptor) {
  Object.defineProperty(window, name, descriptor);
  Object.defineProperty(globalThis, name, descriptor);
}

export {};



================================================
FILE: packages/react/source/types.ts
================================================
import type {ReactNode, ComponentType, Ref} from 'react';
import type {
  RemoteElementConstructor,
  RemotePropertiesFromElementConstructor,
  RemoteMethodsFromElementConstructor,
  RemoteSlotsFromElementConstructor,
} from '@remote-dom/core/elements';

/**
 * The props that will be passed to a React component when it is rendered
 * in response to a remote element. This type includes all the remote properties
 * of the underlying element, and any slotted children, converted to React elements
 * passed as properties with the same name as their slot.
 */
export type RemoteComponentProps<
  Properties extends Record<string, any> = {},
  _Methods extends Record<string, any> = {},
  Slots extends Record<string, any> = {},
> = Omit<Properties, keyof Slots> & {
  [Slot in keyof Slots]: ReactNode;
} & {
  children?: ReactNode;
};

/**
 * Converts the type for a remote element into the full set of React props that
 * will be passed to a component that renders that element.
 */
export type RemoteComponentPropsFromElementConstructor<
  ElementConstructor extends RemoteElementConstructor<any, any, any, any>,
> = RemoteComponentProps<
  RemotePropertiesFromElementConstructor<ElementConstructor>,
  RemoteMethodsFromElementConstructor<ElementConstructor>,
  RemoteSlotsFromElementConstructor<ElementConstructor>
> & {ref?: Ref<InstanceType<ElementConstructor>>; slot?: string};

/**
 * Converts the type for a remote element into the type of a React component that
 * can be used to render that element.
 */
export type RemoteComponentTypeFromElementConstructor<
  ElementConstructor extends RemoteElementConstructor<any, any, any, any>,
  AdditionalProps extends Record<string, any> = {},
> = ComponentType<
  RemoteComponentPropsFromElementConstructor<ElementConstructor> &
    AdditionalProps
>;



================================================
FILE: packages/react/source/host/component.tsx
================================================
import type {RemoteReceiverElement} from '@remote-dom/core/receivers';
import {
  memo,
  useRef,
  useEffect,
  type MutableRefObject,
  type ComponentType,
} from 'react';

import {useRemoteReceived} from './hooks/remote-received.ts';
import {
  usePropsForRemoteElement,
  type RemoteElementPropsOptions,
} from './hooks/props-for-element.tsx';
import {
  REMOTE_ELEMENT_PROP,
  REMOTE_ELEMENT_ATTACHED_PROP,
} from './constants.ts';
import type {RemoteComponentRendererProps} from './types.ts';

/**
 * Additional props that are added to React components rendered by `createRemoteComponentRenderer`.
 */
export interface RemoteComponentRendererAdditionalProps {
  /**
   * The remote element that this component is rendering.
   */
  readonly [REMOTE_ELEMENT_PROP]: RemoteReceiverElement;
  readonly [REMOTE_ELEMENT_ATTACHED_PROP]: boolean;
}

export interface RemoteComponentRendererOptions<Props = {}>
  extends RemoteElementPropsOptions<Props> {
  /**
   * The display name of the resulting wrapper component. By default, a name derived
   * from the wrapped component is used, with a fallback to `RemoteComponentRenderer(Component)`.
   */
  name?: string;

  /**
   * Customizes the props your wrapper React component will have for event listeners
   * on the underlying custom element. The key is the prop name on the React component,
   * and the value is an options object containing the event name on the custom element.
   *
   * @example
   * ```tsx
   * const Button = createRemoteComponent(ButtonImplementation, {
   *   eventProps: {
   *     onClick: {event: 'click'},
   *   },
   * });
   *
   * function ButtonImplementation({children, onClick}) {
   *   // Default behavior: dispatch the `detail` of the event to the remote environment
   *   return <button onClick={onClick}>{children}</button>;
   *
   *   // Alternatively, dispatch a custom value to the remote environment, including potentially
   *   // omitting the event details entirely, like we do below:
   *   return <button onClick={() => onClick()}>{children}</button>;
   * }
   * ```
   */
  eventProps?: RemoteElementPropsOptions<Props>['eventProps'];
}

interface Internals extends Pick<RemoteComponentRendererProps, 'receiver'> {
  id: string;
  instanceRef: MutableRefObject<unknown>;
}

/**
 * Takes a React component, and returns a new component that can be used to render that
 * component from a remote element. This wrapper will handle subscribing to changes in that
 * element, and will normalize the properties on that remote element before passing them
 * to your React component.
 */
export function createRemoteComponentRenderer<
  Props extends Record<string, any> = {},
>(
  Component: ComponentType<Props>,
  {name, eventProps}: NoInfer<RemoteComponentRendererOptions<Props>> = {},
): ComponentType<RemoteComponentRendererProps> {
  const RemoteComponentRenderer = memo(function RemoteComponentRenderer({
    element,
    receiver,
    components,
  }: RemoteComponentRendererProps) {
    const internalsRef = useRef<Internals>();

    const attachedElement = useRemoteReceived(element, receiver);
    const resolvedElement = attachedElement ?? element;
    const resolvedId = resolvedElement.id;

    const props = usePropsForRemoteElement<Props>(resolvedElement, {
      receiver,
      components,
      eventProps,
    });

    (props as any)[REMOTE_ELEMENT_PROP] = resolvedElement;
    (props as any)[REMOTE_ELEMENT_ATTACHED_PROP] = attachedElement != null;

    if (internalsRef.current == null) {
      const internals: Internals = {
        id: resolvedId,
        receiver,
      } as any;

      internals.instanceRef = createImplementationRef(internals);
      internalsRef.current = internals;
    }

    internalsRef.current.id = resolvedId;
    internalsRef.current.receiver = receiver;

    useEffect(() => {
      const node = {id: resolvedId};

      receiver.implement(
        node,
        internalsRef.current?.instanceRef.current as any,
      );

      return () => {
        receiver.implement(node, null);
      };
    }, [resolvedId, receiver]);

    return <Component ref={internalsRef.current.instanceRef} {...props} />;
  });

  RemoteComponentRenderer.displayName =
    name ??
    `RemoteComponentRenderer(${
      Component.displayName ?? Component.name ?? 'Component'
    })`;

  return RemoteComponentRenderer;
}

function createImplementationRef(
  internals: Pick<Internals, 'id' | 'receiver'>,
): MutableRefObject<unknown> {
  let current: unknown = null;

  return {
    get current() {
      return current;
    },
    set current(implementation) {
      current = implementation;
      internals.receiver.implement(internals, implementation as any);
    },
  };
}



================================================
FILE: packages/react/source/host/constants.ts
================================================
/**
 * The property name used to pass a remote element instance to the React component
 * that is configured to render it.
 */
export const REMOTE_ELEMENT_PROP = Symbol.for('remote-dom.element');
export const REMOTE_ELEMENT_ATTACHED_PROP = Symbol.for(
  'remote-dom.element.attached',
);



================================================
FILE: packages/react/source/host/hooks.ts
================================================
export {useRemoteReceived} from './hooks/remote-received.ts';
export {
  usePropsForRemoteElement,
  type RemoteElementPropsOptions,
} from './hooks/props-for-element.tsx';



================================================
FILE: packages/react/source/host/node.tsx
================================================
import {type RemoteReceiverNode} from '@remote-dom/core/receivers';

import {RemoteTextRenderer} from './RemoteTextRenderer.tsx';
import type {RemoteNodeRenderOptions} from './types.ts';

/**
 * Renders a remote node to the host using React.
 *
 * @param node The remote node to render using React
 */
export function renderRemoteNode(
  node: RemoteReceiverNode,
  {receiver, components}: RemoteNodeRenderOptions,
) {
  switch (node.type) {
    case 1: {
      const Component = components.get(node.element);

      if (Component == null) {
        throw new Error(
          `No component found for remote element: ${node.element}`,
        );
      }

      return (
        <Component
          key={node.id}
          element={node}
          receiver={receiver}
          components={components}
        />
      );
    }
    case 3: {
      return (
        <RemoteTextRenderer key={node.id} remote={node} receiver={receiver} />
      );
    }
    case 8: {
      return null;
    }
    default: {
      throw new Error(`Unknown remote node type: ${String(node)}`);
    }
  }
}



================================================
FILE: packages/react/source/host/RemoteFragmentRenderer.tsx
================================================
import type {FunctionComponent} from 'react';

import {renderRemoteNode} from './node.tsx';
import {useRemoteReceived} from './hooks/remote-received.ts';
import type {RemoteComponentRendererProps} from './types.ts';

/**
 * A component that can be used to render a list of children elements, without any
 * additional wrapping elements. This is typically used on the host to render the `remote-root`
 * element, which is a special element rendered by Remote DOM to translate between React
 * elements passed as properties and slotted elements.
 */
export const RemoteFragmentRenderer: FunctionComponent<RemoteComponentRendererProps> =
  function RemoteFragmentRenderer({
    element,
    receiver,
    components,
  }: RemoteComponentRendererProps) {
    const fragments = useRemoteReceived(element, receiver);

    if (!fragments) return null;

    const renderOptions = {receiver, components};

    return (
      <>
        {fragments.children.map((child) =>
          renderRemoteNode(child, renderOptions),
        )}
      </>
    );
  };



================================================
FILE: packages/react/source/host/RemoteRootRenderer.tsx
================================================
import {useRemoteReceived} from './hooks/remote-received.ts';
import {renderRemoteNode} from './node.tsx';
import type {RemoteNodeRenderOptions} from './types.ts';

export interface RemoteRootRendererProps extends RemoteNodeRenderOptions {}

/**
 * A component that can be used to render a tree of UI elements from a remote
 * environment.
 */
export function RemoteRootRenderer(props: RemoteRootRendererProps) {
  const {receiver} = props;
  const {children} = useRemoteReceived(receiver.root, receiver)!;
  return <>{children.map((child) => renderRemoteNode(child, props))}</>;
}



================================================
FILE: packages/react/source/host/RemoteTextRenderer.tsx
================================================
import type {RemoteReceiverText} from '@remote-dom/core/receivers';

import {useRemoteReceived} from './hooks/remote-received.ts';
import type {RemoteNodeRenderOptions} from './types.ts';

export interface RemoteTextRendererProps
  extends Pick<RemoteNodeRenderOptions, 'receiver'> {
  /**
   * The remote text node to render.
   */
  remote: RemoteReceiverText;
}

/**
 * Renders a remote React element to the host using React.
 */
export function RemoteTextRenderer({
  remote,
  receiver,
}: RemoteTextRendererProps) {
  const text = useRemoteReceived(remote, receiver);
  return text ? <>{text.data}</> : null;
}



================================================
FILE: packages/react/source/host/types.ts
================================================
import type {ComponentType} from 'react';
import type {
  RemoteReceiver,
  RemoteReceiverElement,
} from '@remote-dom/core/receivers';

/**
 * The context needed to render a remote node on the host.
 */
export interface RemoteNodeRenderOptions {
  /**
   * The object that maintains the state of the remote tree on the host.
   */
  receiver: RemoteReceiver;

  /**
   * A map of React components that can render remote elements.
   */
  components: RemoteComponentRendererMap<any>;
}

/**
 * The props that are passed to a React component in order to render
 * a remote element.
 */
export interface RemoteComponentRendererProps extends RemoteNodeRenderOptions {
  /**
   * The element being rendered.
   */
  element: RemoteReceiverElement;
}

/**
 * A map of React components that can render remote elements. The keys are strings
 * that correspond to the names of the elements used in the remote environment, and
 * the values are React components that will accept the remote elements and render
 * DOM elements. To create these components, you can use the `createRemoteComponentRenderer()`
 * utility, which takes care of subscribing to changes in the element and passing their
 * properties along to your React implementation.
 */
export type RemoteComponentRendererMap<Elements extends string = string> = Map<
  Elements,
  ComponentType<RemoteComponentRendererProps>
>;



================================================
FILE: packages/react/source/host/hooks/props-for-element.tsx
================================================
import type {RemoteReceiverElement} from '@remote-dom/core/receivers';

import {renderRemoteNode} from '../node.tsx';
import type {RemoteNodeRenderOptions} from '../types.ts';

export interface RemoteElementPropsOptions<Props = {}> {
  /**
   * Customizes the props your wrapper React component will have for event listeners
   * on the underlying custom element. The key is the prop name on the React component,
   * and the value is an options object containing the event name on the custom element.
   *
   * @example
   * ```tsx
   * const props = usePropsForRemoteElement(element, {
   *   eventProps: {
   *     onClick: {event: 'click'},
   *   },
   * });
   * ```
   */
  eventProps?: {
    [K in keyof Props]?: {
      /**
       * The event name that corresponds to this prop.
       */
      event: string;
    };
  };
}

/**
 * Converts a remote element into props for a React element. In addition to passing along
 * the `properties` of that element, this hook will convert any child elements with a `slot`
 * property into a prop of the same name, with the value rendered to a React element.
 */
export function usePropsForRemoteElement<
  Props extends Record<string, any> = {},
>(
  element: RemoteReceiverElement,
  options: RemoteNodeRenderOptions & RemoteElementPropsOptions<Props>,
): Props;
export function usePropsForRemoteElement<
  Props extends Record<string, any> = {},
>(
  element: RemoteReceiverElement | undefined,
  options: RemoteNodeRenderOptions & RemoteElementPropsOptions<Props>,
): Props | undefined;
export function usePropsForRemoteElement<
  Props extends Record<string, any> = {},
>(
  element: RemoteReceiverElement | undefined,
  options: RemoteNodeRenderOptions & RemoteElementPropsOptions<Props>,
): Props | undefined {
  if (!element) return undefined;

  const {children, properties, attributes, eventListeners} = element;
  const reactChildren: ReturnType<typeof renderRemoteNode>[] = [];
  const resolvedProperties: Record<string, any> = {
    ...properties,
    ...attributes,
    children: reactChildren,
  };

  if (options.eventProps) {
    for (const [prop, eventDescription] of Object.entries(options.eventProps)) {
      const eventName = eventDescription?.event;
      if (eventName == null) continue;

      const listener = eventListeners[eventName];
      if (listener) {
        resolvedProperties[prop] = wrapEventListenerForCallback(listener);
      }
    }
  } else {
    // Assume all event listeners are allowed, and write each one as a conventional
    // Preact callback prop.
    for (const [eventName, listener] of Object.entries(eventListeners)) {
      resolvedProperties[
        `on${eventName[0]!.toUpperCase()}${eventName.slice(1)}`
      ] = wrapEventListenerForCallback(listener);
    }
  }

  for (const child of children) {
    if (child.type === 1 && typeof child.attributes.slot === 'string') {
      const slot = child.attributes.slot;
      const rendered = renderRemoteNode(child, options);
      resolvedProperties[slot] = resolvedProperties[slot] ? (
        <>
          {resolvedProperties[slot]}
          {rendered}
        </>
      ) : (
        rendered
      );
    } else {
      reactChildren.push(renderRemoteNode(child, options));
    }
  }

  return resolvedProperties as unknown as Props;
}

function wrapEventListenerForCallback(listener: (...args: any[]) => any) {
  return function eventListenerCallbackWrapper(...args: any[]) {
    if (args.length === 1 && args[0] instanceof Event) {
      const event = args[0];
      if (event.target !== event.currentTarget) return;

      return 'detail' in event ? listener(event.detail) : listener();
    }

    return listener(...args);
  };
}



================================================
FILE: packages/react/source/host/hooks/remote-received.ts
================================================
import {useState, useDebugValue, useEffect} from 'react';
import type {
  RemoteReceiver,
  RemoteReceiverNode,
  RemoteReceiverRoot,
} from '@remote-dom/core/receivers';

interface ReceivedState<T extends RemoteReceiverNode | RemoteReceiverRoot> {
  receiver: RemoteReceiver;
  id: RemoteReceiverNode['id'];
  version?: RemoteReceiverNode['version'];
  value?: T;
}

/**
 * Subscribes to a remote node’s updates and returns its current value.
 */
export function useRemoteReceived<
  T extends RemoteReceiverNode | RemoteReceiverRoot,
>(remote: T, receiver: RemoteReceiver): T | undefined {
  const [state, setState] = useState<ReceivedState<T>>(() => {
    const value = receiver.get<T>(remote);

    return {
      id: remote.id,
      version: value?.version,
      value,
      receiver,
    };
  });

  let returnValue: T | undefined = state.value;

  // If parameters have changed since our last render, schedule an update with its current value.
  if (state.receiver !== receiver || state.id !== remote.id) {
    // When the consumer of this hook changes receiver or attached node, the node they switched
    // to might already be unmounted. We guard against that by making sure we don’t get null
    // back from the receiver, and storing the “attached” node in state whether it is actually
    // attached or not, so we have a paper trail of how we got here.
    const updated = receiver.get<T>(remote);

    // If the subscription has been updated, we'll schedule another update with React.
    // React will process this update immediately, so the old subscription value won't be committed.
    // It is still nice to avoid returning a mismatched value though, so let's override the return value.
    returnValue = updated;

    setState({
      receiver,
      id: remote.id,
      version: updated?.version,
      value: returnValue,
    });
  }

  useDebugValue(returnValue);

  useEffect(() => {
    const abort = new AbortController();

    const checkForUpdates = () => {
      if (abort.signal.aborted) return;

      setState((previousState) => {
        const {
          id: previousId,
          version: previousVersion,
          receiver: previousReceiver,
        } = previousState;

        const {id} = remote;

        // Ignore values from stale sources
        if (previousReceiver !== receiver || previousId !== id) {
          return previousState;
        }

        // This function is also called as part of the initial useEffect() when the
        // component mounts. It’s possible that between the initial render (when the
        // remote component was for sure attached, to the best of the host’s knowledge)
        // and the effect, the component was removed from the remote tree. You’ll see that
        // the rest of this callback is careful to handle cases where the node is in this
        // state.
        const value = receiver.get<T>(remote);
        const version = value?.version;

        // If the value hasn't changed, no update is needed.
        // Return state as-is so React can bail out and avoid an unnecessary render.
        if (previousVersion === version) {
          return previousState;
        }

        return {receiver, value, id, version};
      });
    };

    receiver.subscribe(remote, checkForUpdates, {signal: abort.signal});

    // Passive effect, so we need to check if anything has changed
    checkForUpdates();

    return () => {
      abort.abort();
    };
  }, [receiver, remote.id]);

  return returnValue;
}



================================================
FILE: packages/react/source/tests/e2e.test.tsx
================================================
// @vitest-environment jsdom

Object.assign(globalThis, {IS_REACT_ACT_ENVIRONMENT: true});

import {describe, it, expect, vi} from 'vitest';

import {createRoot} from 'react-dom/client';
import {
  useRef,
  useImperativeHandle,
  forwardRef,
  type ReactNode,
  type PropsWithChildren,
  useLayoutEffect,
} from 'react';

import {render} from '@quilted/react-testing/dom';
import {matchers, type CustomMatchers} from '@quilted/react-testing/matchers';

import {
  RemoteMutationObserver,
  createRemoteElement,
} from '@remote-dom/core/elements';
import {RemoteReceiver} from '@remote-dom/core/receivers';

import {createRemoteComponent} from '../index.ts';
import {
  RemoteRootRenderer,
  RemoteFragmentRenderer,
  createRemoteComponentRenderer,
} from '../host.ts';

expect.extend(matchers);

declare module 'vitest' {
  interface Assertion<T = any> extends CustomMatchers<T> {}
  interface AsymmetricMatchersContaining extends CustomMatchers {}
}

interface ButtonProps {
  tooltip?: string;
  disabled?: boolean;
  onPress?(): void;
  // Alias for `onPress`, to test configurable host event listener mappings
  onClick?(): void;
}

const HostButton = forwardRef(function HostButton({
  children,
  disabled,
  onPress,
  onClick,
}: PropsWithChildren<ButtonProps>) {
  return (
    <button
      disabled={disabled}
      onClick={() => (onPress ? onPress?.() : onClick?.())}
    >
      {children}
    </button>
  );
});

const RemoteButtonElement = createRemoteElement<
  ButtonProps,
  {},
  {},
  {press(): void}
>({
  attributes: ['tooltip'],
  events: ['press'],
  properties: {
    disabled: {type: Boolean},
  },
});

const HostModal = forwardRef(function HostModal(
  {
    children,
    action,
  }: PropsWithChildren<{
    action?: ReactNode;
  }>,
  ref,
) {
  const dialogRef = useRef<HTMLDialogElement>(null);

  useImperativeHandle(ref, () => ({
    open() {
      dialogRef.current?.showModal();
    },
    close() {
      dialogRef.current?.close();
    },
  }));

  return (
    <dialog ref={dialogRef}>
      {children}
      <div>{action}</div>
    </dialog>
  );
});

const RemoteModalElement = createRemoteElement<
  {},
  {
    open(): void;
    close(): void;
  },
  {
    action?: true;
  }
>({
  methods: ['open', 'close'],
  slots: ['action'],
});

const RemoteInputElement = createRemoteElement<
  {},
  {},
  {},
  {change(detail: string): void}
>({
  events: ['change'],
});

function HostInput({onChange}: {onChange?(event: Event): void}) {
  // Need to do this while React doesn’t support custom events on custom elements.
  const inputRef = useRef<HTMLElement>(null);
  useLayoutEffect(() => {
    const controller = new AbortController();

    inputRef.current?.addEventListener('customchange', (event) => {
      onChange?.(event);
    });

    return () => {
      controller.abort();
    };
  }, []);

  // @ts-expect-error
  return <my-custom-input ref={inputRef} oncustomchange={onChange} />;
}

customElements.define('remote-button', RemoteButtonElement);
customElements.define('remote-modal', RemoteModalElement);
customElements.define('remote-input', RemoteInputElement);

declare global {
  interface HTMLElementTagNameMap {
    'remote-button': InstanceType<typeof RemoteButtonElement>;
    'remote-modal': InstanceType<typeof RemoteModalElement>;
    'remote-input': InstanceType<typeof RemoteInputElement>;
  }
}

const RemoteButton = createRemoteComponent(
  'remote-button',
  RemoteButtonElement,
  {
    eventProps: {
      onPress: {event: 'press'},
    },
  },
);

const RemoteModal = createRemoteComponent('remote-modal', RemoteModalElement);

const components = new Map([
  ['remote-button', createRemoteComponentRenderer(HostButton)],
  ['remote-modal', createRemoteComponentRenderer(HostModal)],
  ['remote-input', createRemoteComponentRenderer(HostInput)],
  ['remote-fragment', RemoteFragmentRenderer],
]);

describe('react', () => {
  it('can render simple remote DOM elements', async () => {
    const receiver = new RemoteReceiver();
    const mutationObserver = new RemoteMutationObserver(receiver.connection);

    const remoteRoot = document.createElement('div');
    const remoteButton = document.createElement('remote-button');
    remoteButton.textContent = 'Click me!';
    remoteRoot.append(remoteButton);

    const rendered = render(
      <RemoteRootRenderer receiver={receiver} components={components} />,
    );

    expect(rendered).not.toContainReactComponent(HostButton);

    rendered.act(() => {
      mutationObserver.observe(remoteRoot);
    });

    expect(rendered).toContainReactComponent(HostButton);
  });

  it('can render remote DOM elements with attributes', async () => {
    const receiver = new RemoteReceiver();
    const mutationObserver = new RemoteMutationObserver(receiver.connection);

    const remoteRoot = document.createElement('div');
    const remoteButton = document.createElement('remote-button');
    remoteButton.setAttribute('tooltip', 'I do cool things.');
    remoteButton.textContent = 'Click me!';
    remoteRoot.append(remoteButton);
    mutationObserver.observe(remoteRoot);

    const rendered = render(
      <RemoteRootRenderer receiver={receiver} components={components} />,
    );

    expect(rendered).toContainReactComponent(HostButton, {
      tooltip: 'I do cool things.',
    });
  });

  it('can render remote DOM elements with simple properties', async () => {
    const receiver = new RemoteReceiver();
    const mutationObserver = new RemoteMutationObserver(receiver.connection);

    const remoteRoot = document.createElement('div');
    const remoteButton = document.createElement('remote-button');
    remoteButton.setAttribute('disabled', '');
    remoteButton.textContent = 'Disabled button';
    remoteRoot.append(remoteButton);
    mutationObserver.observe(remoteRoot);

    const rendered = render(
      <RemoteRootRenderer receiver={receiver} components={components} />,
    );

    expect(rendered).toContainReactComponent(HostButton, {disabled: true});
  });

  it('can render remote DOM elements with event listeners', async () => {
    const receiver = new RemoteReceiver();
    const mutationObserver = new RemoteMutationObserver(receiver.connection);

    const remoteRoot = document.createElement('div');
    const remoteButton = document.createElement('remote-button');
    remoteButton.textContent = 'Click to disable';

    remoteButton.addEventListener(
      'press',
      () => {
        remoteButton.textContent = 'Already disabled';
        remoteButton.setAttribute('disabled', '');
      },
      {once: true},
    );

    remoteRoot.append(remoteButton);
    mutationObserver.observe(remoteRoot);

    const rendered = render(
      <RemoteRootRenderer receiver={receiver} components={components} />,
    );

    expect(rendered).toContainReactComponent(HostButton, {disabled: false});

    rendered.find(HostButton)?.trigger('onPress');

    expect(rendered).toContainReactComponent(HostButton, {disabled: true});
  });

  it('can customize the mapping of event listeners to React props', async () => {
    const receiver = new RemoteReceiver();
    const mutationObserver = new RemoteMutationObserver(receiver.connection);

    const remoteRoot = document.createElement('div');
    const remoteButton = document.createElement('remote-button');
    remoteButton.textContent = 'Click to disable';

    remoteButton.addEventListener(
      'press',
      () => {
        remoteButton.textContent = 'Already disabled';
        remoteButton.setAttribute('disabled', '');
      },
      {once: true},
    );

    remoteRoot.append(remoteButton);
    mutationObserver.observe(remoteRoot);

    const rendered = render(
      <RemoteRootRenderer
        receiver={receiver}
        components={
          // Use the same component mapping as other tests, but replace the `remote-button` mapping
          // with one that will map the `press` event to the `onClick` prop instead of the `onPress` prop.
          new Map([
            ...components,
            [
              'remote-button',
              createRemoteComponentRenderer(HostButton, {
                eventProps: {
                  onClick: {event: 'press'},
                },
              }),
            ],
          ])
        }
      />,
    );

    expect(rendered).toContainReactComponent(HostButton, {disabled: false});

    rendered.find(HostButton)?.trigger('onClick');

    expect(rendered).toContainReactComponent(HostButton, {disabled: true});
  });

  it('automatically calls a mapped callback with the `detail` of a custom event that is the only argument to an event listener', async () => {
    const receiver = new RemoteReceiver();
    const mutationObserver = new RemoteMutationObserver(receiver.connection);

    const remoteRoot = document.createElement('div');
    const remoteButton = document.createElement('remote-input');

    const spy = vi.fn();

    remoteButton.addEventListener(
      'change',
      (event) => {
        spy(event.detail);
      },
      {once: true},
    );

    remoteRoot.append(remoteButton);
    mutationObserver.observe(remoteRoot);

    const rendered = render(
      <RemoteRootRenderer receiver={receiver} components={components} />,
    );

    rendered
      .find('my-custom-input')!
      .domNode!.dispatchEvent(
        new CustomEvent('customchange', {detail: 'Hello world'}),
      );

    expect(spy).toHaveBeenCalledWith('Hello world');
  });

  it('can call methods on a remote DOM element by forwarding calls to the host’s implementation component ref', async () => {
    const receiver = new RemoteReceiver();
    const mutationObserver = new RemoteMutationObserver(receiver.connection);

    const remoteRoot = document.createElement('div');
    const remoteModal = document.createElement('remote-modal');
    const remoteButton = document.createElement('remote-button');
    remoteButton.slot = 'action';
    remoteButton.addEventListener('press', () => {
      remoteModal.close();
    });
    remoteModal.append(remoteButton);
    remoteRoot.append(remoteModal);
    mutationObserver.observe(remoteRoot);

    const rendered = render(
      <RemoteRootRenderer receiver={receiver} components={components} />,
    );

    const closeSpy = vi.fn();
    Object.assign(rendered.find(HostModal)!.domNode!, {close: closeSpy});

    rendered.find(HostButton)?.trigger('onPress');

    expect(closeSpy).toHaveBeenCalled();
  });

  it('can render remote DOM elements wrapped as React components', async () => {
    const receiver = new RemoteReceiver();
    const mutationObserver = new RemoteMutationObserver(receiver.connection);

    const remoteRoot = document.createElement('div');

    function Remote() {
      const ref = useRef<InstanceType<typeof RemoteModalElement>>(null);

      return (
        <RemoteModal
          ref={ref}
          action={
            <RemoteButton
              onPress={() => {
                ref.current?.close();
              }}
            >
              Close
            </RemoteButton>
          }
        >
          Modal body
        </RemoteModal>
      );
    }

    const rendered = render(
      <RemoteRootRenderer receiver={receiver} components={components} />,
    );

    // Dedicated `act()` so that React actually renders the remote elements,
    // before we start observing the remote DOM node for changes.
    rendered.act(() => {
      createRoot(remoteRoot).render(<Remote />);
    });

    rendered.act(() => {
      mutationObserver.observe(remoteRoot);
    });

    const closeSpy = vi.fn();
    Object.assign(rendered.find(HostModal)!.domNode!, {close: closeSpy});

    rendered.find(HostButton)?.trigger('onPress');

    expect(closeSpy).toHaveBeenCalled();
  });

  it('can remove the wrapper element on elements passed as properties to remote React components', async () => {
    const RemoteModalWithoutWrappers = createRemoteComponent(
      'remote-modal',
      RemoteModalElement,
      {
        slotProps: {wrapper: false},
      },
    );

    function Remote() {
      const ref = useRef<InstanceType<typeof RemoteModalElement>>(null);

      return (
        <RemoteModalWithoutWrappers
          ref={ref}
          action={
            <RemoteButton
              onPress={() => {
                ref.current?.close();
              }}
            >
              Close
            </RemoteButton>
          }
        >
          Modal body
        </RemoteModalWithoutWrappers>
      );
    }

    const rendered = render(<Remote />);

    expect(rendered).not.toContainReactComponent('remote-fragment');
    expect(rendered).toContainReactComponent(RemoteButton, {slot: 'action'});
  });

  it('can change the wrapper element on elements passed as properties to remote React components', async () => {
    const RemoteModalWithoutWrappers = createRemoteComponent(
      'remote-modal',
      RemoteModalElement,
      {
        slotProps: {wrapper: 'remote-box'},
      },
    );

    function Remote() {
      const ref = useRef<InstanceType<typeof RemoteModalElement>>(null);

      return (
        <RemoteModalWithoutWrappers
          ref={ref}
          action={
            <RemoteButton
              onPress={() => {
                ref.current?.close();
              }}
            >
              Close
            </RemoteButton>
          }
        >
          Modal body
        </RemoteModalWithoutWrappers>
      );
    }

    const rendered = render(<Remote />);

    expect(rendered).not.toContainReactComponent('remote-fragment');
    expect(rendered).toContainReactComponent('remote-box');
  });
});



================================================
FILE: packages/signals/README.md
================================================
# `@remote-dom/signals`

This library provides a `SignalRemoteReceiver` class, which allows you to map a remote tree of DOM elements into a collection of [`@preact/signals` `Signal` objects](https://preactjs.com/guide/v10/signals/).

## Installation

```sh
npm install @remote-dom/signals --save
pnpm install @remote-dom/signals --save
yarn add @remote-dom/signals
```

## Usage

### `SignalRemoteReceiver`

A `SignalRemoteReceiver` stores remote elements into a basic JavaScript representation, with mutable properties and children stored in signals. This representation allows for fine-grained subscriptions and computed values based on the contents of the remote tree. This custom receiver is used by the the [`@remote-dom/preact` library](https://github.com/Shopify/remote-dom/blob/main/packages/preact#remoterenderer) in order to map the remote tree to Preact components.

An empty remote receiver can be created using the `SignalRemoteReceiver` constructor:

```ts
import {SignalRemoteReceiver} from '@remote-dom/signals';

const receiver = new SignalRemoteReceiver();
```

To support functions being passed over `postMessage`, you may need a way to manually manage memory for remote properties as they are received. `SignalRemoteReceiver` lets you accomplish this by passing the `retain` and `release` options to the constructor, which are called when new remote properties are received and when they are overwritten, respectively:

```ts
// This library is not included with Remote DOM, but it pairs
// well with it in allowing you to pass functions between
// JavaScript environments without leaking memory, by manually
// managing the memory for those functions.
import {retain, release} from '@quilted/threads';
import {SignalRemoteReceiver} from '@remote-dom/signals';

const receiver = new SignalRemoteReceiver({retain, release});
```

#### `SignalRemoteReceiver.connection`

Each `SignalRemoteReceiver` has a `connection` property, which can be passed to a [`RemoteMutationObserver`](/packages/core/README.md#remotemutationobserver) or [`RemoteRootElement`](/packages/core/README.md#remoterootelement) in the remote environment. This object, which the library refers to as a `RemoteConnection`, is responsible for communicating changes between the remote environment and host environments.

```ts
// In the host environment:
import {SignalRemoteReceiver} from '@remote-dom/signals';

const receiver = new SignalRemoteReceiver();

// In the remote environment:
import {RemoteMutationObserver} from '@remote-dom/core/elements';

const observer = new RemoteMutationObserver(receiver.connection);
```

#### `SignalRemoteReceiver.root`

Each `SignalRemoteReceiver` also has a `root` property, which defines the object that all remote element representations will be attached to. This object has a `children` property, which will be a signal containing a list of child text and element nodes, which may themselves have additional children.

```ts
import {SignalRemoteReceiver} from '@remote-dom/signals';

const receiver = new SignalRemoteReceiver();
const root = receiver.root;
// {
//   children: signal([]),
//   ...
// }

// You can use the signals in the root object to compute other signals,
// or use any of the standard signal APIs to interact with them:

import {effect} from '@preact/signals';

// @preact/signals will re-run this function whenever the `root.children.value`
// signal changes; this is, whenever children are added or removed from
// the root node of the remote tree.
effect(() => {
  console.log(`Receiver has ${root.children.value.length} children`);
});
```

#### `SignalRemoteReceiver.implement()`

`SignalRemoteReceiver.implement()` lets you define how [remote methods](/packages/core/README.md#remote-methods) are implemented for a particular element. The first argument to this method is the element you want to implement methods for, and the second is an object that provides the implementation for each supported method.

For example, in the example below, we implement a `alert()` method on the root element, which can then be called from the remote environment:

```ts
// In the host environment:
import {SignalRemoteReceiver} from '@remote-dom/signals';

const receiver = new SignalRemoteReceiver();

receiver.implement(receiver.root, {
  alert(message) {
    window.alert(message);
  },
});

// In the remote environment:
import {RemoteRootElement} from '@remote-dom/core/elements';

customElements.define('remote-root', RemoteRootElement);

const root = document.createElement('remote-root');
root.connect(receiver.connection);

root.callRemoteMethod('alert', 'Hello, world!');
```

#### `SignalRemoteReceiver.get()`

`SignalRemoteReceiver.get()` fetches the latest state of a remote element that has been received from the remote environment.

```ts
import {SignalRemoteReceiver} from '@remote-dom/signals';

const receiver = new SignalRemoteReceiver();

receiver.get(receiver.root) === receiver.root; // true
```



================================================
FILE: packages/signals/CHANGELOG.md
================================================
# @remote-dom/signals

## 2.1.0

### Minor Changes

- [#533](https://github.com/Shopify/remote-dom/pull/533) [`a9a88ab`](https://github.com/Shopify/remote-dom/commit/a9a88abe4ba81b253f0cc6cdd5e82a25bbe908c1) Thanks [@igor10k](https://github.com/igor10k)! - Make `removeChild` less strict in receivers

### Patch Changes

- [#535](https://github.com/Shopify/remote-dom/pull/535) [`79419d9`](https://github.com/Shopify/remote-dom/commit/79419d9377013a979ebc4ece53f59d9a9a893094) Thanks [@igor10k](https://github.com/igor10k)! - Move internal peer dependencies to dependencies

- Updated dependencies [[`a9a88ab`](https://github.com/Shopify/remote-dom/commit/a9a88abe4ba81b253f0cc6cdd5e82a25bbe908c1)]:
  - @remote-dom/core@1.7.0

## 2.0.0

### Patch Changes

- Updated dependencies [[`8cbf2c2`](https://github.com/Shopify/remote-dom/commit/8cbf2c2a6130dd0a19088a2adf18b506f468be8b)]:
  - @remote-dom/core@1.6.0

## 1.1.2

### Patch Changes

- [#517](https://github.com/Shopify/remote-dom/pull/517) [`99a8e1a`](https://github.com/Shopify/remote-dom/commit/99a8e1ad8d441619a33a5a4c3f2424fe1ccbe8df) Thanks [@lemonmade](https://github.com/lemonmade)! - Fix missing attributes and event listeners on root receiver elements

- Updated dependencies [[`99a8e1a`](https://github.com/Shopify/remote-dom/commit/99a8e1ad8d441619a33a5a4c3f2424fe1ccbe8df)]:
  - @remote-dom/core@1.5.2

## 1.1.1

### Patch Changes

- Updated dependencies [[`2479b21`](https://github.com/Shopify/remote-dom/commit/2479b21406f6149063bfc095dbb6c3a019386403)]:
  - @remote-dom/core@1.5.0

## 1.1.0

### Minor Changes

- [#411](https://github.com/Shopify/remote-dom/pull/411) [`3bec698`](https://github.com/Shopify/remote-dom/commit/3bec6983756c4b8a6834a037ac520438ef59d28f) Thanks [@lemonmade](https://github.com/lemonmade)! - Add CommonJS export conditions

### Patch Changes

- Updated dependencies [[`3bec698`](https://github.com/Shopify/remote-dom/commit/3bec6983756c4b8a6834a037ac520438ef59d28f)]:
  - @remote-dom/core@1.4.0

## 1.0.5

### Patch Changes

- Updated dependencies [[`218ba3b`](https://github.com/Shopify/remote-dom/commit/218ba3bf1ff2e7518a7dcec11ffd352de70b16f8)]:
  - @remote-dom/core@1.3.0

## 1.0.4

### Patch Changes

- Updated dependencies [[`040e7c5`](https://github.com/Shopify/remote-dom/commit/040e7c5dde658596ccbf883e2d3810955790eff0), [`894d6f3`](https://github.com/Shopify/remote-dom/commit/894d6f3396ebb2e1de7e91b1a445aa0a39195bb9)]:
  - @remote-dom/core@1.2.0

## 1.0.3

### Patch Changes

- Updated dependencies [[`22e6512`](https://github.com/Shopify/remote-dom/commit/22e6512f797d97d2106f181d730d995f37c6edaf)]:
  - @remote-dom/core@1.1.0

## 1.0.2

### Patch Changes

- Updated dependencies [[`37be652`](https://github.com/Shopify/remote-dom/commit/37be652f288d1eec170c0be13b2da516f8db5dcf)]:
  - @remote-dom/core@1.0.0

## 1.0.1

### Patch Changes

- Updated dependencies [[`9576a72`](https://github.com/Shopify/remote-dom/commit/9576a72fa354481621c53efde4169829fe9bfabf)]:
  - @remote-dom/core@0.1.1

## 1.0.0

### Minor Changes

- [`7061ded`](https://github.com/Shopify/remote-dom/commit/7061ded1da4699c6dd6a820eeb940a8af7c66d82) Thanks [@lemonmade](https://github.com/lemonmade)! - Test minor bump

### Patch Changes

- Updated dependencies [[`7061ded`](https://github.com/Shopify/remote-dom/commit/7061ded1da4699c6dd6a820eeb940a8af7c66d82)]:
  - @remote-dom/core@0.1.0

## 0.0.2

### Patch Changes

- [#251](https://github.com/Shopify/remote-dom/pull/251) [`5939cca`](https://github.com/Shopify/remote-dom/commit/5939cca8112417124327bd26f9e2c21f4bf9b20a) Thanks [@lemonmade](https://github.com/lemonmade)! - Test version bump

- Updated dependencies [[`5939cca`](https://github.com/Shopify/remote-dom/commit/5939cca8112417124327bd26f9e2c21f4bf9b20a), [`8e1fad4`](https://github.com/Shopify/remote-dom/commit/8e1fad4a00cfe68ff1594fbabeec10c29958685f)]:
  - @remote-dom/core@0.0.2



================================================
FILE: packages/signals/package.json
================================================
{
  "name": "@remote-dom/signals",
  "type": "module",
  "license": "MIT",
  "publishConfig": {
    "access": "public",
    "@remote-dom/registry": "https://registry.npmjs.org"
  },
  "version": "2.1.0",
  "engines": {
    "node": ">=14.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/Shopify/remote-dom",
    "directory": "packages/signals"
  },
  "exports": {
    ".": {
      "types": "./build/typescript/index.d.ts",
      "quilt:source": "./source/index.ts",
      "quilt:esnext": "./build/esnext/index.esnext",
      "import": "./build/esm/index.mjs",
      "require": "./build/cjs/index.cjs"
    }
  },
  "types": "./build/typescript/index.d.ts",
  "scripts": {
    "build": "rollup --config ./rollup.config.js"
  },
  "peerDependencies": {
    "@preact/signals-core": "^1.3.0"
  },
  "peerDependenciesMeta": {
    "@preact/signals-core": {
      "optional": true
    }
  },
  "devDependencies": {
    "@preact/signals-core": "^1.8.0"
  },
  "browserslist": [
    "defaults and not dead"
  ],
  "dependencies": {
    "@remote-dom/core": "workspace:^1.7.0"
  }
}



================================================
FILE: packages/signals/rollup.config.js
================================================
import {quiltPackage} from '@quilted/rollup/package';

export default quiltPackage({commonjs: true});



================================================
FILE: packages/signals/tsconfig.json
================================================
{
  "extends": "@quilted/typescript/tsconfig.package.json",
  "references": [{"path": "../core"}]
}



================================================
FILE: packages/signals/source/index.ts
================================================
export * from './SignalRemoteReceiver.ts';



================================================
FILE: packages/signals/source/SignalRemoteReceiver.ts
================================================
import {
  signal,
  batch,
  type ReadonlySignal,
  type Signal,
} from '@preact/signals-core';

import {
  ROOT_ID,
  NODE_TYPE_ROOT,
  NODE_TYPE_ELEMENT,
  NODE_TYPE_COMMENT,
  NODE_TYPE_TEXT,
  UPDATE_PROPERTY_TYPE_PROPERTY,
  UPDATE_PROPERTY_TYPE_ATTRIBUTE,
  UPDATE_PROPERTY_TYPE_EVENT_LISTENER,
  createRemoteConnection,
  type RemoteConnection,
  type RemoteNodeSerialization,
  type RemoteTextSerialization,
  type RemoteCommentSerialization,
  type RemoteElementSerialization,
} from '@remote-dom/core';
import type {RemoteReceiverOptions} from '@remote-dom/core/receivers';

/**
 * Represents a text node of a remote tree in a plain JavaScript format, with
 * the text content (the `data` property) wrapped in a signal.
 */
export interface SignalRemoteReceiverText
  extends Omit<RemoteTextSerialization, 'data'> {
  readonly data: ReadonlySignal<RemoteTextSerialization['data']>;
}

/**
 * Represents a comment node of a remote tree in a plain JavaScript format, with
 * the text content (the `data` property) wrapped in a signal.
 */
export interface SignalRemoteReceiverComment
  extends Omit<RemoteCommentSerialization, 'data'> {
  readonly data: ReadonlySignal<RemoteCommentSerialization['data']>;
}

/**
 * Represents an element node of a remote tree in a plain JavaScript format, with
 * the `properties` and `children` properties each wrapped in a signal.
 */
export interface SignalRemoteReceiverElement
  extends Omit<
    RemoteElementSerialization,
    'children' | 'properties' | 'attributes' | 'eventListeners'
  > {
  readonly properties: ReadonlySignal<
    NonNullable<RemoteElementSerialization['properties']>
  >;
  readonly attributes: ReadonlySignal<
    NonNullable<RemoteElementSerialization['attributes']>
  >;
  readonly eventListeners: ReadonlySignal<
    NonNullable<RemoteElementSerialization['eventListeners']>
  >;
  readonly children: ReadonlySignal<readonly SignalRemoteReceiverNode[]>;
}

/**
 * Represents the root of a remote tree in a plain JavaScript format, with
 * the `properties` and `children` properties each wrapped in a signal.
 */
export interface SignalRemoteReceiverRoot {
  readonly id: typeof ROOT_ID;
  readonly type: typeof NODE_TYPE_ROOT;
  readonly properties: ReadonlySignal<
    NonNullable<RemoteElementSerialization['properties']>
  >;
  readonly attributes: ReadonlySignal<
    NonNullable<RemoteElementSerialization['attributes']>
  >;
  readonly eventListeners: ReadonlySignal<
    NonNullable<RemoteElementSerialization['eventListeners']>
  >;
  readonly children: ReadonlySignal<readonly SignalRemoteReceiverNode[]>;
}

/**
 * Represents any node that can be stored in the host representation of the remote tree.
 */
export type SignalRemoteReceiverNode =
  | SignalRemoteReceiverText
  | SignalRemoteReceiverComment
  | SignalRemoteReceiverElement;

export type SignalRemoteReceiverNodeOrRoot =
  | SignalRemoteReceiverNode
  | SignalRemoteReceiverRoot;

/**
 * Represents any node that can be a parent in the remote tree.
 */
export type SignalRemoteReceiverParent =
  | SignalRemoteReceiverElement
  | SignalRemoteReceiverRoot;

/**
 * A `SignalRemoteReceiver` stores remote elements into a basic JavaScript representation,
 * with mutable properties and children stored in signals. This representation allows
 * for fine-grained subscriptions and computed values based on the contents of the remote
 * tree. This custom receiver is used by the the [`@remote-dom/preact` library](https://github.com/Shopify/remote-dom/blob/main/packages/preact#remoterenderer)
 * in order to map the remote tree to Preact components.
 */
export class SignalRemoteReceiver {
  /**
   * Represents the root node of the remote tree. This node is always defined,
   * and you will likely be most interested in its `children` property, which
   * contains the top-level elements of the remote tree.
   */
  readonly root: SignalRemoteReceiverRoot = {
    id: ROOT_ID,
    type: NODE_TYPE_ROOT,
    properties: signal({}),
    attributes: signal({}),
    eventListeners: signal({}),
    children: signal([]),
  };

  /**
   * An object that can synchronize a tree of elements between two JavaScript
   * environments. This object acts as a “thin waist”, allowing for efficient
   * communication of changes between a “remote” environment (usually, a JavaScript
   * sandbox, such as an `iframe` or Web Worker) and a “host” environment
   * (usually, a top-level browser page).
   */
  readonly connection: RemoteConnection;

  private readonly attached = new Map<
    string | typeof ROOT_ID,
    SignalRemoteReceiverNodeOrRoot
  >([[ROOT_ID, this.root]]);

  private readonly parents = new Map<string, string | typeof ROOT_ID>();
  private readonly implementations = new Map<
    string,
    Record<string, (...args: unknown[]) => unknown>
  >();

  constructor({retain, release}: RemoteReceiverOptions = {}) {
    const {attached, parents} = this;

    const baseConnection = createRemoteConnection({
      call: (id, method, ...args) => {
        const implementation = this.implementations.get(id);
        const implementationMethod = implementation?.[method];

        if (typeof implementationMethod !== 'function') {
          throw new Error(
            `Node ${id} does not implement the ${method}() method`,
          );
        }

        return implementationMethod(...args);
      },
      insertChild: (id, child, index) => {
        const parent = attached.get(id) as SignalRemoteReceiverParent;
        const newChildren = [...parent.children.peek()];

        const normalizedChild = attach(child, parent);

        if (index === newChildren.length) {
          newChildren.push(normalizedChild);
        } else {
          newChildren.splice(index, 0, normalizedChild);
        }

        (parent.children as any).value = newChildren;
      },
      removeChild: (id, index) => {
        const parent = attached.get(id) as SignalRemoteReceiverParent;

        const newChildren = [...parent.children.peek()];

        const [removed] = newChildren.splice(index, 1);

        if (!removed) {
          return;
        }

        (parent.children as any).value = newChildren;

        detach(removed);
      },
      updateProperty: (
        id,
        property,
        value,
        type = UPDATE_PROPERTY_TYPE_PROPERTY,
      ) => {
        const element = attached.get(id) as SignalRemoteReceiverElement;

        let updateSignal: Signal<Record<string, any>>;

        switch (type) {
          case UPDATE_PROPERTY_TYPE_PROPERTY:
            updateSignal = element.properties;
            break;
          case UPDATE_PROPERTY_TYPE_ATTRIBUTE:
            updateSignal = element.attributes;
            break;
          case UPDATE_PROPERTY_TYPE_EVENT_LISTENER:
            updateSignal = element.eventListeners;
            break;
        }

        const oldUpdateObject = updateSignal.peek();
        const oldValue = oldUpdateObject[property];

        if (Object.is(oldValue, value)) return;

        retain?.(value);

        const newUpdateObject = {...oldUpdateObject};
        newUpdateObject[property] = value;
        updateSignal.value = newUpdateObject;

        // If the slot changes, inform parent nodes so they can
        // re-parent it appropriately.
        if (property === 'slot') {
          const parentId = this.parents.get(id);

          const parent =
            parentId == null
              ? parentId
              : (attached.get(parentId) as SignalRemoteReceiverParent);

          if (parent) {
            (parent.children as any).value = [...parent.children.peek()];
          }
        }

        release?.(oldValue);
      },
      updateText: (id, newText) => {
        const text = attached.get(id) as SignalRemoteReceiverText;
        (text.data as any).value = newText;
      },
    });

    this.connection = {
      call: baseConnection.call,
      mutate(records) {
        batch(() => {
          baseConnection.mutate(records);
        });
      },
    };

    function attach(
      child: RemoteNodeSerialization,
      parent: SignalRemoteReceiverParent,
    ): SignalRemoteReceiverNode {
      let normalizedChild: SignalRemoteReceiverNode;

      switch (child.type) {
        case NODE_TYPE_TEXT:
        case NODE_TYPE_COMMENT: {
          const {id, type, data} = child;

          normalizedChild = {
            id,
            type,
            data: signal(data),
          } satisfies SignalRemoteReceiverText | SignalRemoteReceiverComment;

          break;
        }
        case NODE_TYPE_ELEMENT: {
          const {
            id,
            type,
            element,
            children,
            properties,
            attributes,
            eventListeners,
          } = child;
          retain?.(properties);
          retain?.(eventListeners);

          const resolvedChildren: SignalRemoteReceiverNode[] = [];

          normalizedChild = {
            id,
            type,
            element,
            children: signal(
              resolvedChildren as readonly SignalRemoteReceiverNode[],
            ),
            properties: signal(properties ?? {}),
            attributes: signal(attributes ?? {}),
            eventListeners: signal(eventListeners ?? {}),
          } satisfies SignalRemoteReceiverElement;

          for (const grandChild of children) {
            resolvedChildren.push(attach(grandChild, normalizedChild));
          }

          break;
        }
        default: {
          throw new Error(`Unknown node type: ${JSON.stringify(child)}`);
        }
      }

      attached.set(normalizedChild.id, normalizedChild);
      parents.set(normalizedChild.id, parent.id);

      return normalizedChild;
    }

    function detach(child: SignalRemoteReceiverNode) {
      attached.delete(child.id);
      parents.delete(child.id);

      if (release && 'properties' in child) {
        release(child.properties.peek());
      }

      if ('children' in child) {
        for (const grandChild of child.children.peek()) {
          detach(grandChild);
        }
      }
    }
  }

  /**
   * Lets you define how [remote methods](https://github.com/Shopify/remote-dom/blob/main/packages/core#remotemethods)
   * are implemented for a particular element in the tree.
   *
   * @param node The remote node to subscribe for changes.
   * @param implementation A record containing the methods to expose for the passed node.
   *
   * @example
   * // In the host environment:
   * import {SignalRemoteReceiver} from '@remote-dom/signals';
   *
   * const receiver = new SignalRemoteReceiver();
   *
   * receiver.implement(receiver.root, {
   *   alert(message) {
   *     window.alert(message);
   *   },
   * });
   *
   * // In the remote environment:
   * import {RemoteRootElement} from '@remote-dom/core/elements';
   *
   * customElements.define('remote-root', RemoteRootElement);
   *
   * const root = document.createElement('remote-root');
   * root.connect(receiver.connection);
   *
   * root.callRemoteMethod('alert', 'Hello, world!');
   */
  implement<T extends SignalRemoteReceiverNodeOrRoot>(
    {id}: Pick<T, 'id'>,
    implementation?: Record<string, (...args: unknown[]) => unknown> | null,
  ) {
    if (implementation == null) {
      this.implementations.delete(id);
    } else {
      this.implementations.set(id, implementation);
    }
  }

  /**
   * Fetches the latest state of a remote element that has been
   * received from the remote environment.
   *
   * @param node The remote node to fetch.
   * @returns The current state of the remote node, or `undefined` if the node is not connected to the remote tree.
   *
   * @example
   * import {SignalRemoteReceiver} from '@remote-dom/signals';
   *
   * const receiver = new SignalRemoteReceiver();
   *
   * receiver.get(receiver.root) === receiver.root; // true
   */
  get<T extends SignalRemoteReceiverNodeOrRoot>({
    id,
  }: Pick<T, 'id'>): T | undefined {
    return this.attached.get(id) as any;
  }
}



================================================
FILE: .changeset/README.md
================================================
# Changesets

Hello and welcome! This folder has been automatically generated by `@changesets/cli`, a build tool that works
with multi-package repos, or single-package repos to help you version and publish your code. You can
find the full documentation for it [in our repository](https://github.com/changesets/changesets)

We have a quick list of common questions to get you started engaging with this project in
[our documentation](https://github.com/changesets/changesets/blob/main/docs/common-questions.md)



================================================
FILE: .changeset/config.json
================================================
{
  "$schema": "https://unpkg.com/@changesets/config@2.2.0/schema.json",
  "changelog": ["@changesets/changelog-github", {"repo": "Shopify/remote-dom"}],
  "commit": false,
  "fixed": [],
  "linked": [],
  "access": "public",
  "baseBranch": "main",
  "updateInternalDependencies": "minor",
  "ignore": []
}



================================================
FILE: .github/dependabot.yml
================================================
# @see https://docs.github.com/github/administering-a-repository/configuration-options-for-dependency-updates

version: 2
updates:
  - package-ecosystem: 'npm'
    directory: '/'
    schedule:
      interval: 'daily'

  - package-ecosystem: 'github-actions'
    directory: '/'
    schedule:
      interval: 'daily'



================================================
FILE: .github/workflows/changesets-reminder.yml
================================================
name: Changelog Reminder

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    paths:
      - 'packages/*/source/**'
      - 'packages/*/package.json'
      - '!*.test.*'
      - '!*.md'

jobs:
  remind:
    name: Changeset Reminder
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: ${{ !github.event.pull_request.draft && !startsWith(github.head_ref, 'changeset-release/') }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      - uses: mskelton/changelog-reminder-action@41fc0852a6e00fc4506a5d7b8a4178062743133a # v3.0.0
        with:
          changelogRegex: "\\.changeset"
          message: >
            We detected some changes in public packages, and there are no updates in the `.changeset` directory.

            If the changes are user-facing and should cause a version bump, run `pnpm changeset` to track your changes and include them in the next release CHANGELOG.

            If you are making simple updates to repo configuration, examples, or documentation, you do not need to add a changeset.



================================================
FILE: .github/workflows/changesets.yml
================================================
name: Changesets

on:
  push:
    branches: [main]

concurrency: ${{ github.workflow }}-${{ github.ref }}

jobs:
  changesets:
    name: Changesets 🦋
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          # This makes Actions fetch all Git history so that Changesets can generate changelogs with the correct commits
          fetch-depth: 0
          # This (plus the GITHUB_TOKEN on the changeset action) allow other workflows to run on the PR that changesets creates.
          token: ${{ secrets.SHOPIFY_GH_ACCESS_TOKEN }}

      - uses: ./.github/workflows/actions/prepare
      # @see https://github.com/changesets/action
      - uses: changesets/action@06245a4e0a36c064a573d4150030f5ec548e4fcc # v1.4.10
        with:
          title: 'Publish packages 🚀'
          commit: 'Publish packages'
          version: pnpm version-bump
          publish: pnpm changeset tag
        env:
          GITHUB_TOKEN: ${{ secrets.SHOPIFY_GH_ACCESS_TOKEN }}



================================================
FILE: .github/workflows/checks.yml
================================================
name: Checks

on:
  workflow_call:

jobs:
  lint:
    name: Lint 💅
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      - uses: ./.github/workflows/actions/prepare
      - run: pnpm run lint

  type-check:
    name: Type check 🧮
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      - uses: ./.github/workflows/actions/prepare
      - run: pnpm run type-check

  test:
    name: Tests 🧪
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      - uses: ./.github/workflows/actions/prepare
      - run: pnpm run test

  e2e:
    name: Playwright E2E 🎭
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      - uses: ./.github/workflows/actions/prepare
      - run: pnpm exec playwright install --with-deps
      - run: pnpm exec playwright test
      - uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        if: ${{ !cancelled() }}
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30



================================================
FILE: .github/workflows/ci.yml
================================================
name: CI

on:
  pull_request:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  checks:
    name: Checks 📝
    uses: ./.github/workflows/checks.yml



================================================
FILE: .github/workflows/cla.yml
================================================
name: Contributor License Agreement (CLA)

on:
  pull_request_target:
    types: [opened, synchronize]
  issue_comment:
    types: [created]

jobs:
  cla:
    runs-on: ubuntu-latest
    if: |
      (github.event.issue.pull_request 
        && !github.event.issue.pull_request.merged_at
        && contains(github.event.comment.body, 'signed')
      ) 
      || (github.event.pull_request && !github.event.pull_request.merged)
    steps:
      - uses: Shopify/shopify-cla-action@v1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          cla-token: ${{ secrets.CLA_TOKEN }}



================================================
FILE: .github/workflows/deploy.yml
================================================
name: Deploy

on:
  push:
    branches: [main]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  checks:
    name: Checks 📝
    uses: ./.github/workflows/checks.yml

  deploy:
    name: Deploy 🚀
    needs: [checks]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      - uses: ./.github/workflows/actions/prepare
      - run: pnpm run type-check
      - run: pnpm run build
      - run: pnpm run deploy
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}



================================================
FILE: .github/workflows/preview-versions.yml
================================================
name: Preview versions

on:
  workflow_dispatch:
  push:
    branches:
      - changeset-release/main

jobs:
  preview:
    name: Preview 🔮
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      - uses: ./.github/workflows/actions/prepare

      # Changeset entries are consumed on this branch. We need to reset the
      # changeset files so that the snapshot command knows the correct packages,
      # and does not accidentally publish the new, non-preview version numbers
      # prematurely.
      - name: Reset changeset entries
        run: |
          git fetch origin main
          git checkout origin/main -- .changeset

      - run: pnpm run type-check
      - run: pnpm run build

      - name: Deploy preview versions to NPM
        run: |
          pnpm changeset version --snapshot preview
          pnpm changeset publish --tag preview --no-git-tag
        env:
          GITHUB_TOKEN: ${{ secrets.SHOPIFY_GH_ACCESS_TOKEN }}
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}



================================================
FILE: .github/workflows/snapit.yml
================================================
name: Snapit

on:
  issue_comment:
    types:
      - created

jobs:
  snapit:
    name: Snapit
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          token: ${{ secrets.SHOPIFY_GH_ACCESS_TOKEN }}

      - uses: ./.github/workflows/actions/prepare

      - name: Create snapshot
        uses: Shopify/snapit@v0.0.14
        env:
          GITHUB_TOKEN: ${{ secrets.SHOPIFY_GH_ACCESS_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        with:
          build_script: pnpm build:snapit
          comment_command: /snapit



================================================
FILE: .github/workflows/actions/prepare/action.yml
================================================
name: Prepare repo
runs:
  using: 'composite'
  steps:
    - uses: pnpm/action-setup@e9540b3eafaf84907c087a645d3258bfaa861427 # v3.0.0
    - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
      with:
        cache: pnpm
        registry-url: 'https://registry.npmjs.org'
        node-version-file: '.nvmrc'
    - name: Enable Corepack
      run: corepack enable && pnpm -v
      shell: bash
    - name: Install dependencies
      run: pnpm install --frozen-lockfile && pnpm prune
      shell: bash


