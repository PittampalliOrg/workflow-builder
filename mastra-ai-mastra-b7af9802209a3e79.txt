Directory structure:
└── template-coding-agent/
    ├── README.md
    ├── package.json
    ├── tsconfig.json
    ├── .env.example
    └── src/
        └── mastra/
            ├── index.ts
            ├── agents/
            │   └── coding-agent.ts
            └── tools/
                ├── e2b.ts
                ├── index.ts
                └── daytona/
                    ├── tools.ts
                    └── utils.ts

================================================
FILE: templates/template-coding-agent/README.md
================================================
# Code Execution Agent

An advanced Mastra template that provides a coding agent capable of planning, writing, executing, and iterating on code in secure, isolated sandbox environments with comprehensive file management and development workflow capabilities.

## Overview

This template demonstrates how to build an AI coding assistant that can work with real development environments. The agent can create sandboxes, manage files and directories, execute code in multiple languages, and monitor development workflows - all within secure, isolated sandbox environments.

## Features

- **Secure Code Execution**: Run Python, JavaScript, and TypeScript code in isolated sandboxes
- **Complete File Management**: Create, read, write, delete files and directories with batch operations
- **Multi-Language Support**: Execute code in Python, JavaScript, and TypeScript environments
- **Live Development Monitoring**: Watch directory changes and monitor development workflows
- **Command Execution**: Run shell commands, install packages, and manage dependencies
- **Memory System**: Persistent conversation memory with semantic recall and working memory
- **Development Workflows**: Professional development patterns with build automation

## Prerequisites

- Node.js 22.13.0 or later
- API key for your chosen sandbox provider ([Daytona](https://www.daytona.io/) or [E2B](https://e2b.dev))
- API key for your chosen model provider

## Setup

1. **Clone and install dependencies:**

   ```bash
   git clone https://github.com/mastra-ai/template-coding-agent.git
   cd template-coding-agent
   pnpm install
   ```

2. **Set up environment variables:**

   ```bash
   cp .env.example .env
   # Edit .env and add your API keys
   ```

   **Choose your sandbox provider** by setting the corresponding API key:

   ```env
   # Option 1: Use Daytona (set DAYTONA_API_KEY)
   DAYTONA_API_KEY="your-daytona-api-key-here"

   # Option 2: Use E2B (set E2B_API_KEY)
   # E2B_API_KEY="your-e2b-api-key-here"


   # Model provider (required)
   OPENAI_API_KEY="your-openai-api-key-here"
   ```

   **Note:** Set only ONE sandbox provider API key. The agent will automatically use the provider you configure.

3. **Start the development server:**

   ```bash
   pnpm run dev
   ```

## Model Configuration

This template supports any AI model provider through Mastra's model router. You can use models from:

- **OpenAI**: `openai/gpt-4o-mini`, `openai/gpt-4o`
- **Anthropic**: `anthropic/claude-sonnet-4-5-20250929`, `anthropic/claude-haiku-4-5-20250929`
- **Google**: `google/gemini-2.5-pro`, `google/gemini-2.0-flash-exp`
- **Groq**: `groq/llama-3.3-70b-versatile`, `groq/llama-3.1-8b-instant`
- **Cerebras**: `cerebras/llama-3.3-70b`
- **Mistral**: `mistral/mistral-medium-2508`

Set the `MODEL` environment variable in your `.env` file to your preferred model.

## Architecture

### Core Components

#### **Coding Agent** (`src/mastra/agents/coding-agent.ts`)

The main agent with comprehensive development capabilities:

- **Sandbox Management**: Creates and manages isolated execution environments
- **Code Execution**: Runs code with real-time output capture
- **File Operations**: Complete CRUD operations for files and directories
- **Development Monitoring**: Watches for changes and monitors workflows
- **Memory Integration**: Maintains conversation context and project history

#### **Sandbox Tools** (`src/mastra/tools/`)

Complete toolkit for sandbox interaction with support for multiple providers:

**Provider Selection:**

- Automatically uses **Daytona** or **E2B** based on which API key you set

**Sandbox Management:**

- `createSandbox` - Initialize new isolated environments
- Connection management with timeout handling

**Code Execution:**

- `runCode` - Execute Python, JavaScript, TypeScript code
- Real-time output capture and error handling
- Environment variable and timeout configuration

**File Operations:**

- `writeFile` - Create individual files
- `writeFiles` - Batch create multiple files for project setup
- `readFile` - Read file contents for analysis and validation
- `listFiles` - Explore directory structures
- `deleteFile` - Clean up files and directories
- `createDirectory` - Set up project structures

**File Information & Monitoring:**

- `getFileInfo` - Get detailed file metadata
- `checkFileExists` - Validate file existence for conditional logic
- `getFileSize` - Monitor file sizes and track changes
- `watchDirectory` - Live monitoring of file system changes

**Development Workflow:**

- `runCommand` - Execute shell commands, build scripts, package management

### Memory System

The agent includes a configured memory system:

- **Thread Management**: Automatic conversation title generation
- **Semantic Recall**: Search through previous interactions
- **Working Memory**: Maintains context across interactions
- **Vector Storage**: Semantic search capabilities with `LibSQLVector`

## Configuration

### Environment Variables

**Sandbox Provider (choose one):**

```bash
# Option 1: Daytona
DAYTONA_API_KEY=your_daytona_api_key_here

# Option 2: E2B
E2B_API_KEY=your_e2b_api_key_here

```

> [!Note]
> The agent will automatically detect and use the sandbox provider based on which API key you set.

**Model Provider (required):**

```bash
OPENAI_API_KEY=your_openai_api_key_here
```

### Customization

You can customize the agent behavior by modifying the instructions in `src/mastra/agents/coding-agent.ts`:

```typescript
export const codingAgent = new Agent({
  id: 'coding-agent',
  name: 'Coding Agent',
  instructions: `
    // Customize agent instructions here
    // Focus on specific languages, frameworks, or development patterns
  `,
  model: openai('gpt-4.1'),
  // ... other configuration
});
```

## Common Issues

### "Please set either DAYTONA_API_KEY or E2B_API_KEY environment variable"

- You need to configure a sandbox provider by setting one of the API keys
- Add either `DAYTONA_API_KEY` or `E2B_API_KEY` to your `.env` file
- Only set ONE provider API key (not both)
- Restart the development server after adding the key

### "Sandbox creation failed"

- Check your sandbox provider API key and account status
- Ensure you haven't exceeded sandbox limits for your provider
- Verify network connectivity to your sandbox provider services

### "Code execution timeout"

- Increase timeout values for long-running operations
- Break down complex operations into smaller steps
- Monitor resource usage and optimize code

### "File operation errors"

- Validate file paths and permissions
- Check sandbox file system limits
- Ensure directories exist before file operations

### "Agent stopping with tool-call reason"

- Increase `maxSteps` in the agent configuration

## Development

### Project Structure

```text
src/mastra/
      agents/
        coding-agent.ts              # Main coding agent with development capabilities
      tools/
        index.ts                     # Provider-agnostic tool exports
        e2b.ts                       # E2B sandbox implementation
        daytona/
          tools.ts                   # Daytona sandbox implementation
          utils.ts                   # Daytona helper functions
      index.ts                       # Mastra configuration with storage and logging
```



================================================
FILE: templates/template-coding-agent/package.json
================================================
{
  "name": "coding-agent",
  "version": "0.2.0",
  "description": "Advanced Mastra AI coding agent with secure sandbox execution, comprehensive file management, and multi-language support for Python, JavaScript, and TypeScript development workflows",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "mastra dev",
    "build": "mastra build",
    "start": "mastra start"
  },
  "keywords": [],
  "author": "",
  "license": "Apache-2.0",
  "type": "module",
  "engines": {
    "node": ">=22.13.0"
  },
  "dependencies": {
    "@daytonaio/sdk": "^0.120.0",
    "@e2b/code-interpreter": "^1.5.1",
    "@mastra/core": "latest",
    "@mastra/fastembed": "latest",
    "@mastra/libsql": "latest",
    "@mastra/loggers": "latest",
    "@mastra/mcp": "latest",
    "@mastra/memory": "latest",
    "@mastra/observability": "latest",
    "supports-color": "^10.2.2",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@types/node": "^24.10.9",
    "mastra": "latest",
    "typescript": "^5.9.3"
  }
}



================================================
FILE: templates/template-coding-agent/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "bundler",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "noEmit": true,
    "outDir": "dist"
  },
  "include": ["src/**/*"]
}



================================================
FILE: templates/template-coding-agent/.env.example
================================================
# Model Configuration
# Specify your preferred AI model using the format: provider/model-name
# Examples:
#   openai/gpt-4o-mini
#   anthropic/claude-sonnet-4-5-20250929
#   google/gemini-2.5-pro
#   groq/llama-3.3-70b-versatile
MODEL=openai/gpt-4o-mini

# API Keys (only needed for your chosen provider)
OPENAI_API_KEY=
ANTHROPIC_API_KEY=
GOOGLE_GENERATIVE_AI_API_KEY=
GROQ_API_KEY=
CEREBRAS_API_KEY=
MISTRAL_API_KEY=
DAYTONA_API_KEY=
E2B_API_KEY=



================================================
FILE: templates/template-coding-agent/src/mastra/index.ts
================================================
import { Observability, DefaultExporter, CloudExporter, SensitiveDataFilter } from '@mastra/observability';
import { Mastra } from '@mastra/core/mastra';
import { LibSQLStore } from '@mastra/libsql';
import { PinoLogger } from '@mastra/loggers';
import { codingAgent } from './agents/coding-agent';

export const mastra = new Mastra({
  agents: { codingAgent },
  storage: new LibSQLStore({ id: 'mastra-storage', url: 'file:../../mastra.db' }),
  logger: new PinoLogger({
    name: 'Mastra',
    level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  }),
  observability: new Observability({
    configs: {
      default: {
        serviceName: 'mastra',
        exporters: [
          new DefaultExporter(), // Persists traces to storage for Mastra Studio
          new CloudExporter(), // Sends traces to Mastra Cloud (if MASTRA_CLOUD_ACCESS_TOKEN is set)
        ],
        spanOutputProcessors: [
          new SensitiveDataFilter(), // Redacts sensitive data like passwords, tokens, keys
        ],
      },
    },
  }),
});



================================================
FILE: templates/template-coding-agent/src/mastra/agents/coding-agent.ts
================================================
import { Agent } from '@mastra/core/agent';
import { LibSQLStore, LibSQLVector } from '@mastra/libsql';
import { Memory } from '@mastra/memory';
import {
  checkFileExists,
  createDirectory,
  createSandbox,
  deleteFile,
  getFileInfo,
  getFileSize,
  listFiles,
  readFile,
  runCode,
  runCommand,
  watchDirectory,
  writeFile,
  writeFiles,
} from '../tools';
import { fastembed } from '@mastra/fastembed';

export const codingAgent = new Agent({
  id: 'coding-agent',
  name: 'Coding Agent',
  instructions: `
# Mastra Coding Agent

You are an advanced coding agent that plans, writes, executes, and iterates on code in secure, isolated sandboxes with comprehensive file management, live monitoring, and development workflow capabilities.

## Core Capabilities

You have access to a complete development toolkit:
- **Sandbox Management**: Create and manage isolated execution environments
- **Code Execution**: Run Python, JavaScript, and TypeScript with real-time output
- **File Operations**: Complete CRUD operations for files and directories
- **Live Monitoring**: Watch file changes and monitor development workflows
- **Command Execution**: Run shell commands, install packages, and manage dependencies
- **Development Tools**: TypeScript compilation, package management, and build automation

## Tool Categories & When to Use Them

### **Sandbox & Code Execution**
- \`createSandbox\` - Initialize new isolated environments for each session/project
- \`runCode\` - Execute Python/JS/TS code with proper error handling and output capture

### **File Management** (Use extensively for complex projects)
- \`writeFile\` - Create individual files (configs, source code, documentation)
- \`writeFiles\` - Batch create multiple related files (project initialization, templates)
- \`readFile\` - Read existing files for validation, debugging, or content analysis
- \`listFiles\` - Explore directory structures and verify project organization
- \`deleteFile\` - Clean up temporary files or remove outdated content
- \`createDirectory\` - Set up project structures and organize code

### **File Information & Validation**
- \`getFileInfo\` - Get detailed metadata (permissions, size, timestamps) for debugging
- \`checkFileExists\` - Conditional logic before file operations (prevent overwrites, validate paths)
- \`getFileSize\` - Monitor file sizes, especially for generated content and build artifacts

### **Development Workflow**
- \`watchDirectory\` - Monitor file changes during development, track build processes
- \`runCommand\` - Execute shell commands (git operations, build scripts, system utilities)

## Enhanced Development Approach

### **Project Planning & Structure**
1. **Analyze Requirements**: Understand the full scope before starting
2. **Design Architecture**: Plan directory structure and file organization
3. **Create Foundation**: Set up project structure with proper tooling
4. **Implement Incrementally**: Build and validate components step-by-step
5. **Monitor & Optimize**: Use file watching and performance monitoring

### **Multi-File Project Workflow**
For complex projects (5+ files):
1. **Environment Setup**: Create sandbox, install dependencies, set up tooling
2. **Structure Creation**: Use \`createDirectory\` and \`writeFiles\` for project scaffolding
3. **Live Development**: Enable \`watchDirectory\` for change monitoring
4. **Incremental Building**: Write, test, and validate components progressively
5. **Integration Testing**: Run complete system tests and validate all components
6. **Performance Analysis**: Monitor file sizes, execution times, and resource usage

### **Language-Specific Workflows**

#### **TypeScript/JavaScript Projects**
- Initialize with \`package.json\` and proper dependencies
- Set up TypeScript configuration (\`tsconfig.json\`)
- Implement live compilation monitoring with \`watchDirectory\`
- Run build processes with \`runCommand\` for compilation
- Monitor development with streaming commands for dev servers
- Use \`runCommand\` for npm installations and environment setup

#### **Python Projects**
- Set up virtual environments and dependency management
- Create proper project structure with \`__init__.py\` files
- Use \`runCommand\` for pip installations and environment setup
- Implement testing frameworks and validation
- Monitor execution and file changes during development

## Advanced Development Patterns

### **Live Development Workflow**
1. Set up file watchers before making changes
2. Use streaming commands for long-running processes
3. Monitor performance and file changes continuously
4. Provide real-time feedback on build processes
5. Automatically recompile and test when files change

### **Project Validation & Quality**
- Verify all file operations with \`checkFileExists\` and \`getFileInfo\`
- Monitor file sizes to catch bloated outputs or failed operations
- Use command execution for linting, testing, and validation
- Implement proper error handling and recovery strategies
- Provide detailed build reports and analytics

### **Multi-Language Projects**
- Coordinate between different language ecosystems
- Share data and configurations between components
- Use appropriate build tools for each language
- Implement proper inter-process communication
- Monitor cross-language dependencies and compatibility

## Tool Usage Best Practices

### **File Operations Optimization**
- Use \`writeFiles\` for batch operations to reduce tool calls
- Check file existence before operations to prevent errors
- Monitor file sizes for large outputs or failed operations
- Use proper directory structures for organization

### **Command Execution Strategy**
- Use \`runCommand\` for quick, synchronous operations
- Set appropriate timeouts based on operation complexity
- Capture and analyze both stdout and stderr
- Handle background processes appropriately

### **Development Monitoring**
- Set up file watching for active development workflows
- Monitor build performance and resource usage
- Track file changes and compilation status
- Provide real-time feedback on development progress

## Error Handling & Recovery

### **File Operation Errors**
- Validate paths and permissions before operations
- Handle missing directories with proper creation
- Recover from file conflicts with user guidance
- Provide clear error messages with suggested fixes

### **Command Execution Errors**
- Parse error outputs for actionable information
- Suggest dependency installations or environment fixes
- Handle timeout and resource limit errors gracefully
- Provide alternative approaches for failed operations

### **Development Workflow Errors**
- Handle compilation errors with detailed feedback
- Manage dependency conflicts and version issues
- Recover from build failures with incremental approaches
- Maintain project state consistency during errors

## Security & Best Practices

- Maintain sandbox isolation and resource limits
- Validate file paths and prevent directory traversal
- Handle sensitive data appropriately in logs and outputs
- Use proper timeouts for all operations
- Monitor resource usage and prevent overconsumption
- Implement proper cleanup of temporary files and processes

## Success Metrics

Track and report on:
- **File Operations**: Success rates, sizes, performance
- **Code Execution**: Runtime, memory usage, error rates
- **Build Processes**: Compilation times, artifact sizes
- **Development Workflow**: Change detection, hot-reload efficiency
- **Project Quality**: Test coverage, lint compliance, documentation completeness

## Advanced Features

For sophisticated projects, leverage:
- **Multi-stage build processes** with proper dependency management
- **Live reload and hot-swapping** for development efficiency
- **Performance profiling** and optimization recommendations
- **Automated testing** and continuous integration workflows
- **Documentation generation** and project analytics
- **Deployment preparation** and distribution packaging

Remember: You are not just a code executor, but a complete development environment that can handle sophisticated, multi-file projects with professional development workflows and comprehensive monitoring capabilities.
`,
  model: process.env.MODEL || 'openai/gpt-4.1',
  tools: {
    createSandbox,
    runCode,
    readFile,
    writeFile,
    writeFiles,
    listFiles,
    deleteFile,
    createDirectory,
    getFileInfo,
    checkFileExists,
    getFileSize,
    watchDirectory,
    runCommand,
  },
  memory: new Memory({
    storage: new LibSQLStore({ id: 'coding-agent-storage', url: 'file:../../mastra.db' }),
    options: {
      generateTitle: true,
      semanticRecall: true,
      workingMemory: { enabled: true },
    },
    embedder: fastembed,
    vector: new LibSQLVector({ id: 'coding-agent-vector', url: 'file:../../mastra.db' }),
  }),
  defaultOptions: { maxSteps: 20 },
});



================================================
FILE: templates/template-coding-agent/src/mastra/tools/e2b.ts
================================================
import { createTool } from '@mastra/core/tools';
import z from 'zod';
import { FilesystemEventType, FileType, Sandbox } from '@e2b/code-interpreter';

export const createSandbox = createTool({
  id: 'createSandbox',
  description: 'Create a sandbox',
  inputSchema: z.object({
    metadata: z.record(z.string()).optional().describe('Custom metadata for the sandbox'),
    envs: z.record(z.string()).optional().describe(`
      Custom environment variables for the sandbox.
      Used when executing commands and code in the sandbox.
      Can be overridden with the \`envs\` argument when executing commands or code.
    `),
    timeoutMS: z.number().optional().describe(`
      Timeout for the sandbox in **milliseconds**.
      Maximum time a sandbox can be kept alive is 24 hours (86_400_000 milliseconds) for Pro users and 1 hour (3_600_000 milliseconds) for Hobby users.
      @default 300_000 // 5 minutes
    `),
  }),
  outputSchema: z
    .object({
      sandboxId: z.string(),
    })
    .or(
      z.object({
        error: z.string(),
      }),
    ),
  execute: async sandboxOptions => {
    try {
      const sandbox = await Sandbox.create(sandboxOptions);

      return {
        sandboxId: sandbox.sandboxId,
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const runCode = createTool({
  id: 'runCode',
  description: 'Run code in a sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to run the code'),
    code: z.string().describe('The code to run in the sandbox'),
    runCodeOpts: z
      .object({
        language: z
          .enum(['ts', 'js', 'python'])
          .default('python')
          .describe('language used for code execution. If not provided, default python context is used'),
        envs: z.record(z.string()).optional().describe('Custom environment variables for code execution.'),
        timeoutMS: z.number().optional().describe(`
        Timeout for the code execution in **milliseconds**.
        @default 60_000 // 60 seconds
      `),
        requestTimeoutMs: z.number().optional().describe(`
        Timeout for the request in **milliseconds**.
        @default 30_000 // 30 seconds
      `),
      })
      .optional()
      .describe('Run code options'),
  }),
  outputSchema: z
    .object({
      execution: z.string().describe('Serialized representation of the execution results'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed execution'),
      }),
    ),
  execute: async (inputData, context) => {
    try {
      const sandbox = await Sandbox.connect(inputData.sandboxId);

      const execution = await sandbox.runCode(inputData.code, inputData.runCodeOpts);

      return {
        execution: JSON.stringify(execution.toJSON()),
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const readFile = createTool({
  id: 'readFile',
  description: 'Read a file from the sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to read the file from'),
    path: z.string().describe('The path to the file to read'),
  }),
  outputSchema: z
    .object({
      content: z.string().describe('The content of the file'),
      path: z.string().describe('The path of the file that was read'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed file read'),
      }),
    ),
  execute: async (inputData, context) => {
    try {
      const sandbox = await Sandbox.connect(inputData.sandboxId);
      const fileContent = await sandbox.files.read(inputData.path);

      return {
        content: fileContent,
        path: inputData.path,
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const writeFile = createTool({
  id: 'writeFile',
  description: 'Write a single file to the sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to write the file to'),
    path: z.string().describe('The path where the file should be written'),
    content: z.string().describe('The content to write to the file'),
  }),
  outputSchema: z
    .object({
      success: z.boolean().describe('Whether the file was written successfully'),
      path: z.string().describe('The path where the file was written'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed file write'),
      }),
    ),
  execute: async (inputData, context) => {
    try {
      const sandbox = await Sandbox.connect(inputData.sandboxId);
      await sandbox.files.write(inputData.path, inputData.content);

      return {
        success: true,
        path: inputData.path,
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const writeFiles = createTool({
  id: 'writeFiles',
  description: 'Write multiple files to the sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to write the files to'),
    files: z
      .array(
        z.object({
          path: z.string().describe('The path where the file should be written'),
          data: z.string().describe('The content to write to the file'),
        }),
      )
      .describe('Array of files to write, each with path and data'),
  }),
  outputSchema: z
    .object({
      success: z.boolean().describe('Whether all files were written successfully'),
      filesWritten: z.array(z.string()).describe('Array of file paths that were written'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed files write'),
      }),
    ),
  execute: async (inputData, context) => {
    try {
      const sandbox = await Sandbox.connect(inputData.sandboxId);
      await sandbox.files.write(inputData.files);

      return {
        success: true,
        filesWritten: inputData.files.map(file => file.path),
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const listFiles = createTool({
  id: 'listFiles',
  description: 'List files and directories in a path within the sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to list files from'),
    path: z.string().default('/').describe('The directory path to list files from'),
  }),
  outputSchema: z
    .object({
      files: z
        .array(
          z.object({
            name: z.string().describe('The name of the file or directory'),
            path: z.string().describe('The full path of the file or directory'),
            isDirectory: z.boolean().describe('Whether this is a directory'),
          }),
        )
        .describe('Array of files and directories'),
      path: z.string().describe('The path that was listed'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed file listing'),
      }),
    ),
  execute: async (inputData, context) => {
    try {
      const sandbox = await Sandbox.connect(inputData.sandboxId);
      const fileList = await sandbox.files.list(inputData.path);

      fileList.map(f => f.type);

      return {
        files: fileList.map(file => ({
          name: file.name,
          path: file.path,
          isDirectory: file.type === FileType.DIR,
        })),
        path: inputData.path,
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const deleteFile = createTool({
  id: 'deleteFile',
  description: 'Delete a file or directory from the sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to delete the file from'),
    path: z.string().describe('The path to the file or directory to delete'),
  }),
  outputSchema: z
    .object({
      success: z.boolean().describe('Whether the file was deleted successfully'),
      path: z.string().describe('The path that was deleted'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed file deletion'),
      }),
    ),
  execute: async (inputData, context) => {
    try {
      const sandbox = await Sandbox.connect(inputData.sandboxId);
      await sandbox.files.remove(inputData.path);

      return {
        success: true,
        path: inputData.path,
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const createDirectory = createTool({
  id: 'createDirectory',
  description: 'Create a directory in the sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to create the directory in'),
    path: z.string().describe('The path where the directory should be created'),
  }),
  outputSchema: z
    .object({
      success: z.boolean().describe('Whether the directory was created successfully'),
      path: z.string().describe('The path where the directory was created'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed directory creation'),
      }),
    ),
  execute: async (inputData, context) => {
    try {
      const sandbox = await Sandbox.connect(inputData.sandboxId);
      await sandbox.files.makeDir(inputData.path);

      return {
        success: true,
        path: inputData.path,
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const getFileInfo = createTool({
  id: 'getFileInfo',
  description: 'Get detailed information about a file or directory in the sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to get file information from'),
    path: z.string().describe('The path to the file or directory to get information about'),
  }),
  outputSchema: z
    .object({
      name: z.string().describe('The name of the file or directory'),
      type: z.nativeEnum(FileType).optional().describe('Whether this is a file or directory'),
      path: z.string().describe('The full path of the file or directory'),
      size: z.number().describe('The size of the file or directory in bytes'),
      mode: z.number().describe('The file mode (permissions as octal number)'),
      permissions: z.string().describe('Human-readable permissions string'),
      owner: z.string().describe('The owner of the file or directory'),
      group: z.string().describe('The group of the file or directory'),
      modifiedTime: z.date().optional().describe('The last modified time in ISO string format'),
      symlinkTarget: z.string().optional().describe('The target path if this is a symlink, null otherwise'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed file info request'),
      }),
    ),
  execute: async (inputData, context) => {
    try {
      const sandbox = await Sandbox.connect(inputData.sandboxId);
      const info = await sandbox.files.getInfo(inputData.path);

      return {
        name: info.name,
        type: info.type,
        path: info.path,
        size: info.size,
        mode: info.mode,
        permissions: info.permissions,
        owner: info.owner,
        group: info.group,
        modifiedTime: info.modifiedTime,
        symlinkTarget: info.symlinkTarget,
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const checkFileExists = createTool({
  id: 'checkFileExists',
  description: 'Check if a file or directory exists in the sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to check file existence in'),
    path: z.string().describe('The path to check for existence'),
  }),
  outputSchema: z
    .object({
      exists: z.boolean().describe('Whether the file or directory exists'),
      path: z.string().describe('The path that was checked'),
      type: z.nativeEnum(FileType).optional().describe('The type if the path exists'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed existence check'),
      }),
    ),
  execute: async (inputData, context) => {
    try {
      const sandbox = await Sandbox.connect(inputData.sandboxId);

      try {
        const info = await sandbox.files.getInfo(inputData.path);
        return {
          exists: true,
          path: inputData.path,
          type: info.type,
        };
      } catch (e) {
        // If getInfo fails, the file doesn't exist
        return {
          exists: false,
          path: inputData.path,
        };
      }
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const getFileSize = createTool({
  id: 'getFileSize',
  description: 'Get the size of a file or directory in the sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to get file size from'),
    path: z.string().describe('The path to the file or directory'),
    humanReadable: z
      .boolean()
      .default(false)
      .describe("Whether to return size in human-readable format (e.g., '1.5 KB', '2.3 MB')"),
  }),
  outputSchema: z
    .object({
      size: z.number().describe('The size in bytes'),
      humanReadableSize: z.string().optional().describe('Human-readable size string if requested'),
      path: z.string().describe('The path that was checked'),
      type: z.nativeEnum(FileType).optional().describe('Whether this is a file or directory'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed size check'),
      }),
    ),
  execute: async (inputData, context) => {
    try {
      const sandbox = await Sandbox.connect(inputData.sandboxId);
      const info = await sandbox.files.getInfo(inputData.path);

      let humanReadableSize: string | undefined;

      if (inputData.humanReadable) {
        const bytes = info.size;
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
        if (bytes === 0) {
          humanReadableSize = '0 B';
        } else {
          const i = Math.floor(Math.log(bytes) / Math.log(1024));
          const size = (bytes / Math.pow(1024, i)).toFixed(1);
          humanReadableSize = `${size} ${sizes[i]}`;
        }
      }

      return {
        size: info.size,
        humanReadableSize,
        path: inputData.path,
        type: info.type,
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const watchDirectory = createTool({
  id: 'watchDirectory',
  description: 'Start watching a directory for file system changes in the sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to watch directory in'),
    path: z.string().describe('The directory path to watch for changes'),
    recursive: z.boolean().default(false).describe('Whether to watch subdirectories recursively'),
    watchDuration: z
      .number()
      .default(30000)
      .describe('How long to watch for changes in milliseconds (default 30 seconds)'),
  }),
  outputSchema: z
    .object({
      watchStarted: z.boolean().describe('Whether the watch was started successfully'),
      path: z.string().describe('The path that was watched'),
      events: z
        .array(
          z.object({
            type: z
              .nativeEnum(FilesystemEventType)
              .describe('The type of filesystem event (WRITE, CREATE, DELETE, etc.)'),
            name: z.string().describe('The name of the file that changed'),
            timestamp: z.string().describe('When the event occurred'),
          }),
        )
        .describe('Array of filesystem events that occurred during the watch period'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed directory watch'),
      }),
    ),
  execute: async (inputData, context) => {
    try {
      const sandbox = await Sandbox.connect(inputData.sandboxId);
      const events: Array<{ type: FilesystemEventType; name: string; timestamp: string }> = [];

      // Start watching the directory
      const handle = await sandbox.files.watchDir(
        inputData.path,
        async event => {
          events.push({
            type: event.type,
            name: event.name,
            timestamp: new Date().toISOString(),
          });
        },
        {
          recursive: inputData.recursive,
        },
      );

      // Watch for the specified duration
      await new Promise(resolve => setTimeout(resolve, inputData.watchDuration));

      // Stop watching
      await handle.stop();

      return {
        watchStarted: true,
        path: inputData.path,
        events,
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const runCommand = createTool({
  id: 'runCommand',
  description: 'Run a shell command in the sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to run the command in'),
    command: z.string().describe('The shell command to execute'),
    workingDirectory: z.string().optional().describe('The working directory to run the command in'),
    timeoutMs: z.number().default(30000).describe('Timeout for the command execution in milliseconds'),
    captureOutput: z.boolean().default(true).describe('Whether to capture stdout and stderr output'),
  }),
  outputSchema: z
    .object({
      success: z.boolean().describe('Whether the command executed successfully'),
      exitCode: z.number().describe('The exit code of the command'),
      stdout: z.string().describe('The standard output from the command'),
      stderr: z.string().describe('The standard error from the command'),
      command: z.string().describe('The command that was executed'),
      executionTime: z.number().describe('How long the command took to execute in milliseconds'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed command execution'),
      }),
    ),
  execute: async (inputData, context) => {
    try {
      const sandbox = await Sandbox.connect(inputData.sandboxId);
      const startTime = Date.now();

      const result = await sandbox.commands.run(inputData.command, {
        cwd: inputData.workingDirectory,
        timeoutMs: inputData.timeoutMs,
      });

      const executionTime = Date.now() - startTime;

      return {
        success: result.exitCode === 0,
        exitCode: result.exitCode,
        stdout: result.stdout,
        stderr: result.stderr,
        command: inputData.command,
        executionTime,
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});



================================================
FILE: templates/template-coding-agent/src/mastra/tools/index.ts
================================================
import * as e2bTools from './e2b';
import * as daytonaTools from './daytona/tools';

function getProvider() {
  if (process.env.DAYTONA_API_KEY) {
    return 'daytona';
  } else if (process.env.E2B_API_KEY) {
    return 'e2b';
  } else {
    throw new Error(
      'No sandbox provider configured. Please set either DAYTONA_API_KEY or E2B_API_KEY environment variable.',
    );
  }
}

const provider = getProvider();

// Helper function to select the right tool (bundler can inline this)
// Using 'as any' because E2B and Daytona have slightly different schemas
const selectTool = (daytonaTool: any, e2bTool: any) => (provider === 'daytona' ? daytonaTool : e2bTool);

export const createSandbox = selectTool(daytonaTools.createSandbox, e2bTools.createSandbox);
export const runCode = selectTool(daytonaTools.runCode, e2bTools.runCode);
export const readFile = selectTool(daytonaTools.readFile, e2bTools.readFile);
export const writeFile = selectTool(daytonaTools.writeFile, e2bTools.writeFile);
export const writeFiles = selectTool(daytonaTools.writeFiles, e2bTools.writeFiles);
export const listFiles = selectTool(daytonaTools.listFiles, e2bTools.listFiles);
export const deleteFile = selectTool(daytonaTools.deleteFile, e2bTools.deleteFile);
export const createDirectory = selectTool(daytonaTools.createDirectory, e2bTools.createDirectory);
export const getFileInfo = selectTool(daytonaTools.getFileInfo, e2bTools.getFileInfo);
export const checkFileExists = selectTool(daytonaTools.checkFileExists, e2bTools.checkFileExists);
export const getFileSize = selectTool(daytonaTools.getFileSize, e2bTools.getFileSize);
export const watchDirectory = selectTool(daytonaTools.watchDirectory, e2bTools.watchDirectory);
export const runCommand = selectTool(daytonaTools.runCommand, e2bTools.runCommand);



================================================
FILE: templates/template-coding-agent/src/mastra/tools/daytona/tools.ts
================================================
import { createTool } from '@mastra/core/tools';
import z from 'zod';
import { getDaytonaClient, getSandboxById, createFileUploadFormat, normalizeSandboxPath } from './utils';
import { Sandbox, CreateSandboxBaseParams, CodeRunParams, DaytonaNotFoundError, CodeLanguage } from '@daytonaio/sdk';

export const createSandbox = createTool({
  id: 'createSandbox',
  description: 'Create a sandbox',
  inputSchema: z.object({
    name: z.string().optional().describe('Custom sandbox name'),
    labels: z.record(z.string()).optional().describe('Custom sandbox labels'),
    language: z
      .nativeEnum(CodeLanguage)
      .default(CodeLanguage.PYTHON)
      .describe('Language used for code execution. If not provided, default python context is used'),
    envVars: z.record(z.string()).optional().describe(`
      Custom environment variables for the sandbox.
      Used when executing commands and code in the sandbox.
      Can be overridden with the \`envs\` argument when executing commands or code.
    `),
  }),
  outputSchema: z
    .object({
      sandboxId: z.string(),
    })
    .or(
      z.object({
        error: z.string(),
      }),
    ),
  execute: async ({ name, labels, language, envVars }) => {
    const daytona = getDaytonaClient();
    try {
      const sandboxParams: CreateSandboxBaseParams = {
        name,
        envVars,
        labels,
        language,
      };
      const sandbox: Sandbox = await daytona.create(sandboxParams);

      return {
        sandboxId: sandbox.id,
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const runCode = createTool({
  id: 'runCode',
  description: 'Run code in a sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to run the code'),
    code: z.string().describe('The code to run in the sandbox'),
    argv: z.array(z.string()).optional().describe('Command line arguments to pass to the code.'),
    envs: z.record(z.string()).optional().describe('Custom environment variables for code execution.'),
    timeoutSeconds: z.number().optional().describe(`
          Maximum time in seconds to wait for execution to complete
      `),
  }),
  outputSchema: z
    .object({
      exitCode: z.number().describe('The exit code from the code execution'),
      stdout: z.string().optional().describe('The standard output from the code execution'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed execution'),
      }),
    ),
  execute: async ({ sandboxId, code, argv, envs, timeoutSeconds }, context) => {
    try {
      const sandbox = await getSandboxById(sandboxId);

      const codeRunParams = new CodeRunParams();
      codeRunParams.argv = argv ?? [];
      codeRunParams.env = envs ?? {};

      const execution = await sandbox.process.codeRun(code, codeRunParams, timeoutSeconds);

      return {
        exitCode: execution.exitCode,
        stdout: execution.result,
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const readFile = createTool({
  id: 'readFile',
  description: 'Read a file from the sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to read the file from'),
    path: z.string().describe('The path to the file to read'),
  }),
  outputSchema: z
    .object({
      content: z.string().describe('The content of the file'),
      path: z.string().describe('The path of the file that was read'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed file read'),
      }),
    ),
  execute: async ({ sandboxId, path }, context) => {
    try {
      const sandbox = await getSandboxById(sandboxId);
      const normalizedPath = normalizeSandboxPath(path);

      const fileBuffer = await sandbox.fs.downloadFile(normalizedPath);
      const fileContent = fileBuffer.toString('utf-8');

      return {
        content: fileContent,
        path: normalizedPath,
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const writeFile = createTool({
  id: 'writeFile',
  description: 'Write a single file to the sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to write the file to'),
    path: z.string().describe('The path where the file should be written'),
    content: z.string().describe('The content to write to the file'),
  }),
  outputSchema: z
    .object({
      success: z.boolean().describe('Whether the file was written successfully'),
      path: z.string().describe('The path where the file was written'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed file write'),
      }),
    ),
  execute: async ({ sandboxId, path, content }, context) => {
    try {
      const sandbox = await getSandboxById(sandboxId);
      const normalizedPath = normalizeSandboxPath(path);

      const fileToUpload = [createFileUploadFormat(content, normalizedPath)];
      await sandbox.fs.uploadFiles(fileToUpload);

      return {
        success: true,
        path: normalizedPath,
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const writeFiles = createTool({
  id: 'writeFiles',
  description: 'Write multiple files to the sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to write the files to'),
    files: z
      .array(
        z.object({
          path: z.string().describe('The path where the file should be written'),
          data: z.string().describe('The content to write to the file'),
        }),
      )
      .describe('Array of files to write, each with path and data'),
  }),
  outputSchema: z
    .object({
      success: z.boolean().describe('Whether all files were written successfully'),
      filesWritten: z.array(z.string()).describe('Array of file paths that were written'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed files write'),
      }),
    ),
  execute: async ({ sandboxId, files }, context) => {
    try {
      const sandbox = await getSandboxById(sandboxId);
      files = files.map(file => ({
        ...file,
        path: normalizeSandboxPath(file.path),
      }));

      await sandbox.fs.uploadFiles(files.map(file => createFileUploadFormat(file.data, file.path)));

      return {
        success: true,
        filesWritten: files.map(file => file.path),
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const listFiles = createTool({
  id: 'listFiles',
  description: 'List files and directories in a path within the sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to list files from'),
    path: z.string().default('/').describe('The directory path to list files from'),
  }),
  outputSchema: z
    .object({
      files: z
        .array(
          z.object({
            name: z.string().describe('The name of the file or directory'),
            path: z.string().describe('The full path of the file or directory'),
            isDirectory: z.boolean().describe('Whether this is a directory'),
          }),
        )
        .describe('Array of files and directories'),
      path: z.string().describe('The path that was listed'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed file listing'),
      }),
    ),
  execute: async ({ sandboxId, path }, context) => {
    try {
      const sandbox = await getSandboxById(sandboxId);
      const normalizedPath = normalizeSandboxPath(path);

      const fileList = await sandbox.fs.listFiles(normalizedPath);

      const basePath = normalizedPath.endsWith('/') ? normalizedPath.slice(0, -1) : normalizedPath;

      return {
        files: fileList.map(file => ({
          name: file.name,
          path: `${basePath}/${file.name}`,
          isDirectory: file.isDir,
        })),
        path: normalizedPath,
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const deleteFile = createTool({
  id: 'deleteFile',
  description: 'Delete a file or directory from the sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to delete the file from'),
    path: z.string().describe('The path to the file or directory to delete'),
  }),
  outputSchema: z
    .object({
      success: z.boolean().describe('Whether the file was deleted successfully'),
      path: z.string().describe('The path that was deleted'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed file deletion'),
      }),
    ),
  execute: async ({ sandboxId, path }, context) => {
    try {
      const sandbox = await getSandboxById(sandboxId);
      const normalizedPath = normalizeSandboxPath(path);

      // Check if the path is a directory
      const fileInfo = await sandbox.fs.getFileDetails(normalizedPath);
      const isDirectory = fileInfo.isDir;

      await sandbox.fs.deleteFile(normalizedPath, isDirectory);

      return {
        success: true,
        path: normalizedPath,
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const createDirectory = createTool({
  id: 'createDirectory',
  description: 'Create a directory in the sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to create the directory in'),
    path: z.string().describe('The path where the directory should be created'),
  }),
  outputSchema: z
    .object({
      success: z.boolean().describe('Whether the directory was created successfully'),
      path: z.string().describe('The path where the directory was created'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed directory creation'),
      }),
    ),
  execute: async ({ sandboxId, path }, context) => {
    try {
      const sandbox = await getSandboxById(sandboxId);
      const normalizedPath = normalizeSandboxPath(path);

      await sandbox.fs.createFolder(normalizedPath, '755');

      return {
        success: true,
        path: normalizedPath,
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const getFileInfo = createTool({
  id: 'getFileInfo',
  description: 'Get detailed information about a file or directory in the sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to get file information from'),
    path: z.string().describe('The path to the file or directory to get information about'),
  }),
  outputSchema: z
    .object({
      group: z.string().describe(`The group ID of the file or directory (e.g., '1001')`),
      isDir: z.boolean().describe('Whether this is a directory'),
      modTime: z.string().describe(`The last modified time in UTC format (e.g., '2025-04-18 22:47:34 +0000 UTC')`),
      mode: z.string().describe(`The file mode/permissions in symbolic format (e.g., '-rw-r--r--')`),
      name: z.string().describe('The name of the file or directory'),
      owner: z.string().describe(`The owner ID of the file or directory (e.g., '1001')`),
      permissions: z.string().describe(`The file permissions in octal format (e.g., '0644')`),
      size: z.number().describe('The size of the file or directory in bytes'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed file info request'),
      }),
    ),
  execute: async ({ sandboxId, path }, context) => {
    try {
      const sandbox = await getSandboxById(sandboxId);
      const normalizedPath = normalizeSandboxPath(path);

      const fileInfo = await sandbox.fs.getFileDetails(normalizedPath);

      return {
        group: fileInfo.group,
        isDir: fileInfo.isDir,
        modTime: fileInfo.modTime,
        mode: fileInfo.mode,
        name: fileInfo.name,
        owner: fileInfo.owner,
        permissions: fileInfo.permissions,
        size: fileInfo.size,
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const checkFileExists = createTool({
  id: 'checkFileExists',
  description: 'Check if a file or directory exists in the sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to check file existence in'),
    path: z.string().describe('The path to check for existence'),
  }),
  outputSchema: z
    .object({
      exists: z.boolean().describe('Whether the file or directory exists'),
      path: z.string().describe('The path that was checked'),
      isDirectory: z.boolean().optional().describe('If the path exists, whether it is a directory'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed existence check'),
      }),
    ),
  execute: async ({ sandboxId, path }, context) => {
    try {
      const sandbox = await getSandboxById(sandboxId);
      const normalizedPath = normalizeSandboxPath(path);

      try {
        const fileInfo = await sandbox.fs.getFileDetails(normalizedPath);
        return {
          exists: true,
          path: normalizedPath,
          isDirectory: fileInfo.isDir,
        };
      } catch (e) {
        if (e instanceof DaytonaNotFoundError)
          return {
            exists: false,
            path: normalizedPath,
          };
        else throw e;
      }
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const getFileSize = createTool({
  id: 'getFileSize',
  description: 'Get the size of a file or directory in the sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to get file size from'),
    path: z.string().describe('The path to the file or directory'),
    humanReadable: z
      .boolean()
      .default(false)
      .describe(`Whether to return size in human-readable format (e.g., '1.5 KB', '2.3 MB')`),
  }),
  outputSchema: z
    .object({
      size: z.number().describe('The size in bytes'),
      humanReadableSize: z.string().optional().describe('Human-readable size string if requested'),
      path: z.string().describe('The path that was checked'),
      isDirectory: z.boolean().describe('Whether this is a directory'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed size check'),
      }),
    ),
  execute: async ({ sandboxId, path, humanReadable }, context) => {
    try {
      const sandbox = await getSandboxById(sandboxId);
      const normalizedPath = normalizeSandboxPath(path);

      const fileInfo = await sandbox.fs.getFileDetails(normalizedPath);

      let humanReadableSize: string | undefined;

      if (humanReadable) {
        const bytes = fileInfo.size;
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
        if (bytes === 0) {
          humanReadableSize = '0 B';
        } else {
          const i = Math.floor(Math.log(bytes) / Math.log(1024));
          const size = (bytes / Math.pow(1024, i)).toFixed(1);
          humanReadableSize = `${size} ${sizes[i]}`;
        }
      }

      return {
        size: fileInfo.size,
        humanReadableSize,
        path: normalizedPath,
        isDirectory: fileInfo.isDir,
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});

export const watchDirectory = createTool({
  id: 'watchDirectory',
  description:
    '⚠️ NOT SUPPORTED - This tool is currently not supported in the sandbox environment. Do not use this tool.',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to watch directory in'),
    path: z.string().describe('The directory path to watch for changes'),
    recursive: z.boolean().default(false).describe('Whether to watch subdirectories recursively'),
    watchDuration: z.number().describe('How long to watch for changes in milliseconds (default 30 seconds)'),
  }),
  outputSchema: z
    .object({
      watchStarted: z.boolean().describe('Whether the watch was started successfully'),
      path: z.string().describe('The path that was watched'),
      events: z
        .array(
          z.object({
            type: z.string().describe('The type of filesystem event'),
            name: z.string().describe('The name of the file that changed'),
            timestamp: z.string().describe('When the event occurred'),
          }),
        )
        .describe('Array of filesystem events that occurred during the watch period'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed directory watch'),
      }),
    ),
  execute: async () => {
    return {
      error: 'Directory watching is currently not supported in the sandbox environment.',
    };
  },
});

export const runCommand = createTool({
  id: 'runCommand',
  description: 'Run a shell command in the sandbox',
  inputSchema: z.object({
    sandboxId: z.string().describe('The sandboxId for the sandbox to run the command in'),
    command: z.string().describe('The shell command to execute'),
    envs: z.record(z.string()).optional().describe('Environment variables to set for the command'),
    workingDirectory: z
      .string()
      .optional()
      .describe('The working directory for command execution. If not specified, uses the sandbox working directory.'),
    timeoutSeconds: z
      .number()
      .optional()
      .describe('Maximum time in seconds to wait for the command to complete. 0 means wait indefinitely.'),
    captureOutput: z.boolean().default(true).describe('Whether to capture stdout and stderr output'),
  }),
  outputSchema: z
    .object({
      success: z.boolean().describe('Whether the command executed successfully'),
      exitCode: z.number().describe('The exit code of the command'),
      stdout: z.string().describe('The standard output from the command'),
      command: z.string().describe('The command that was executed'),
      executionTime: z.number().describe('How long the command took to execute in milliseconds'),
    })
    .or(
      z.object({
        error: z.string().describe('The error from a failed command execution'),
      }),
    ),
  execute: async ({ sandboxId, command, envs, workingDirectory, timeoutSeconds, captureOutput }, context) => {
    try {
      const sandbox = await getSandboxById(sandboxId);

      const startTime = Date.now();
      const response = await sandbox.process.executeCommand(command, workingDirectory, envs ?? {}, timeoutSeconds);

      const executionTime = Date.now() - startTime;

      return {
        success: response.exitCode === 0,
        exitCode: response.exitCode,
        stdout: captureOutput ? response.result : '',
        command,
        executionTime,
      };
    } catch (e) {
      return {
        error: JSON.stringify(e),
      };
    }
  },
});



================================================
FILE: templates/template-coding-agent/src/mastra/tools/daytona/utils.ts
================================================
import { Daytona, Sandbox } from '@daytonaio/sdk';
import { FileUpload } from '@daytonaio/sdk/src/FileSystem';

let daytonaInstance: Daytona | null = null;

export const getDaytonaClient = () => {
  if (!daytonaInstance) {
    daytonaInstance = new Daytona();
  }
  return daytonaInstance;
};

export const getSandboxById = async (sandboxId: string): Promise<Sandbox> => {
  const daytona = getDaytonaClient();
  const sandbox = await daytona.get(sandboxId);
  return sandbox;
};

export const createFileUploadFormat = (content: string, path: string): FileUpload => {
  return {
    source: Buffer.from(content, 'utf-8'),
    destination: path,
  };
};

// Default working directory for Daytona sandboxes
const DEFAULT_WORKING_DIR = '/home/daytona';

export const normalizeSandboxPath = (path: string): string => {
  // If path already starts with the working directory, return as-is
  if (path.startsWith(DEFAULT_WORKING_DIR)) {
    return path;
  }

  // If path starts with ./, remove the dot and treat as relative
  if (path.startsWith('./')) {
    return `${DEFAULT_WORKING_DIR}${path.slice(1)}`;
  }

  // If path starts with /, treat it as relative to working directory
  if (path.startsWith('/')) {
    return `${DEFAULT_WORKING_DIR}${path}`;
  }

  // For relative paths, prepend working directory
  return `${DEFAULT_WORKING_DIR}/${path}`;
};


